// Generated by kaoscript 0.9.0
var __ks__ = require("@kaoscript/runtime");
var Helper = __ks__.Helper, Type = __ks__.Type;
module.exports = function() {
	var __ks_Error = {};
	var __ks_SyntaxError = {};
	var __ks__ = require("@kaoscript/ast")();
	var AssignmentOperatorKind = __ks__.AssignmentOperatorKind, BinaryOperatorKind = __ks__.BinaryOperatorKind, MacroElementKind = __ks__.MacroElementKind, ModifierKind = __ks__.ModifierKind, NodeKind = __ks__.NodeKind, ReificationKind = __ks__.ReificationKind, ScopeKind = __ks__.ScopeKind, UnaryOperatorKind = __ks__.UnaryOperatorKind;
	var AST = (function() {
		var $polyadic = {};
		$polyadic[BinaryOperatorKind.Addition] = true;
		$polyadic[BinaryOperatorKind.And] = true;
		$polyadic[BinaryOperatorKind.Assignment] = false;
		$polyadic[BinaryOperatorKind.BitwiseAnd] = true;
		$polyadic[BinaryOperatorKind.BitwiseLeftShift] = true;
		$polyadic[BinaryOperatorKind.BitwiseOr] = true;
		$polyadic[BinaryOperatorKind.BitwiseRightShift] = true;
		$polyadic[BinaryOperatorKind.BitwiseXor] = true;
		$polyadic[BinaryOperatorKind.Division] = true;
		$polyadic[BinaryOperatorKind.Equality] = true;
		$polyadic[BinaryOperatorKind.GreaterThan] = true;
		$polyadic[BinaryOperatorKind.GreaterThanOrEqual] = true;
		$polyadic[BinaryOperatorKind.Inequality] = false;
		$polyadic[BinaryOperatorKind.LessThan] = true;
		$polyadic[BinaryOperatorKind.LessThanOrEqual] = true;
		$polyadic[BinaryOperatorKind.Modulo] = true;
		$polyadic[BinaryOperatorKind.Multiplication] = true;
		$polyadic[BinaryOperatorKind.NullCoalescing] = true;
		$polyadic[BinaryOperatorKind.Or] = true;
		$polyadic[BinaryOperatorKind.Subtraction] = true;
		$polyadic[BinaryOperatorKind.TypeCasting] = false;
		$polyadic[BinaryOperatorKind.TypeEquality] = false;
		$polyadic[BinaryOperatorKind.TypeInequality] = false;
		var $precedence = {};
		$precedence[BinaryOperatorKind.Addition] = 13;
		$precedence[BinaryOperatorKind.And] = 6;
		$precedence[BinaryOperatorKind.Assignment] = 3;
		$precedence[BinaryOperatorKind.BitwiseAnd] = 11;
		$precedence[BinaryOperatorKind.BitwiseLeftShift] = 12;
		$precedence[BinaryOperatorKind.BitwiseOr] = 9;
		$precedence[BinaryOperatorKind.BitwiseRightShift] = 12;
		$precedence[BinaryOperatorKind.BitwiseXor] = 10;
		$precedence[BinaryOperatorKind.Division] = 14;
		$precedence[BinaryOperatorKind.Equality] = 7;
		$precedence[BinaryOperatorKind.GreaterThan] = 8;
		$precedence[BinaryOperatorKind.GreaterThanOrEqual] = 8;
		$precedence[BinaryOperatorKind.Inequality] = 7;
		$precedence[BinaryOperatorKind.LessThan] = 8;
		$precedence[BinaryOperatorKind.LessThanOrEqual] = 8;
		$precedence[BinaryOperatorKind.Modulo] = 14;
		$precedence[BinaryOperatorKind.Multiplication] = 14;
		$precedence[BinaryOperatorKind.NullCoalescing] = 15;
		$precedence[BinaryOperatorKind.Or] = 5;
		$precedence[BinaryOperatorKind.Subtraction] = 15;
		$precedence[BinaryOperatorKind.TypeCasting] = 8;
		$precedence[BinaryOperatorKind.TypeEquality] = 8;
		$precedence[BinaryOperatorKind.TypeInequality] = 8;
		function location() {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			var __ks_i = -1;
			var descriptor = arguments[++__ks_i];
			if(descriptor === void 0 || descriptor === null) {
				throw new TypeError("'descriptor' is not nullable");
			}
			var firstToken = arguments[++__ks_i];
			if(firstToken === void 0 || firstToken === null) {
				throw new TypeError("'firstToken' is not nullable");
			}
			var __ks__;
			var lastToken = arguments.length > 2 && (__ks__ = arguments[++__ks_i]) !== void 0 ? __ks__ : null;
			if(lastToken === null) {
				if(!Type.isValue(descriptor.start)) {
					descriptor.start = firstToken.start;
				}
				descriptor.end = firstToken.end;
			}
			else {
				descriptor.start = firstToken.start;
				descriptor.end = lastToken.end;
			}
			return descriptor;
		}
		function reorderExpression(operations) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(operations === void 0 || operations === null) {
				throw new TypeError("'operations' is not nullable");
			}
			var precedences = {};
			var precedenceList = [];
			var precedence;
			for(var i = 1, __ks_0 = operations.length; i < __ks_0; i += 2) {
				precedence = $precedence[operations[i].operator.kind];
				if(precedences[precedence]) {
					++precedences[precedence];
				}
				else {
					precedences[precedence] = 1;
				}
				precedenceList.push(precedence);
			}
			precedenceList = precedenceList.sort(function(a, b) {
				if(arguments.length < 2) {
					throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
				}
				if(a === void 0 || a === null) {
					throw new TypeError("'a' is not nullable");
				}
				if(b === void 0 || b === null) {
					throw new TypeError("'b' is not nullable");
				}
				return b - a;
			});
			var count, k, operator, left;
			for(var __ks_0 = 0, __ks_1 = precedenceList.length; __ks_0 < __ks_1; ++__ks_0) {
				precedence = precedenceList[__ks_0];
				count = precedences[precedence];
				var __ks_2;
				for(k = 1, __ks_2 = operations.length; count && k < __ks_2; k += 2) {
					if($precedence[operations[k].operator.kind] === precedence) {
						--count;
						operator = operations[k];
						if(operator.kind === NodeKind.BinaryExpression) {
							left = operations[k - 1];
							if((left.kind === NodeKind.BinaryExpression) && (operator.operator.kind === left.operator.kind) && $polyadic[operator.operator.kind]) {
								operator.kind = NodeKind.PolyadicExpression;
								operator.start = left.start;
								operator.end = operations[k + 1].end;
								operator.operands = [left.left, left.right, operations[k + 1]];
							}
							else if((left.kind === NodeKind.PolyadicExpression) && (operator.operator.kind === left.operator.kind)) {
								left.operands.push(operations[k + 1]);
								left.end = operations[k + 1].end;
								operator = left;
							}
							else {
								operator.left = left;
								operator.right = operations[k + 1];
								operator.start = operator.left.start;
								operator.end = operator.right.end;
							}
						}
						else {
							operator.left = operations[k - 1];
							operator.right = operations[k + 1];
							operator.start = operator.left.start;
							operator.end = operator.right.end;
						}
						operations.splice(k - 1, 3, operator);
						k -= 2;
					}
				}
			}
			return operations[0];
		}
		function AccessorDeclaration() {
			if(arguments.length === 1) {
				var __ks_i = -1;
				var first = arguments[++__ks_i];
				if(first === void 0 || first === null) {
					throw new TypeError("'first' is not nullable");
				}
				return location({
					kind: NodeKind.AccessorDeclaration
				}, first);
			}
			else if(arguments.length === 3) {
				var __ks_i = -1;
				var body = arguments[++__ks_i];
				if(body === void 0 || body === null) {
					throw new TypeError("'body' is not nullable");
				}
				var first = arguments[++__ks_i];
				if(first === void 0 || first === null) {
					throw new TypeError("'first' is not nullable");
				}
				var last = arguments[++__ks_i];
				if(last === void 0 || last === null) {
					throw new TypeError("'last' is not nullable");
				}
				return location({
					kind: NodeKind.AccessorDeclaration,
					body: body.value
				}, first, last);
			}
			else {
				throw new SyntaxError("wrong number of arguments");
			}
		};
		function ArrayBinding(elements, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(elements === void 0 || elements === null) {
				throw new TypeError("'elements' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.ArrayBinding,
				elements: Helper.mapArray(elements, function(element) {
					return element.value;
				})
			}, first, last);
		}
		function ArrayComprehension(expression, loop, first, last) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(expression === void 0 || expression === null) {
				throw new TypeError("'expression' is not nullable");
			}
			if(loop === void 0 || loop === null) {
				throw new TypeError("'loop' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.ArrayComprehension,
				body: expression.value,
				loop: loop.value
			}, first, last);
		}
		function ArrayExpression(values, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(values === void 0 || values === null) {
				throw new TypeError("'values' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.ArrayExpression,
				values: Helper.mapArray(values, function(value) {
					return value.value;
				})
			}, first, last);
		}
		function ArrayRangeFI(from, til, by, first, last) {
			if(arguments.length < 5) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(from === void 0 || from === null) {
				throw new TypeError("'from' is not nullable");
			}
			if(til === void 0 || til === null) {
				throw new TypeError("'til' is not nullable");
			}
			if(by === void 0) {
				by = null;
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			var node = location({
				kind: NodeKind.ArrayRange,
				from: from.value,
				til: til.value
			}, first, last);
			if(Type.isValue(by)) {
				node.by = by.value;
			}
			return node;
		}
		function ArrayRangeFO(from, to, by, first, last) {
			if(arguments.length < 5) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(from === void 0 || from === null) {
				throw new TypeError("'from' is not nullable");
			}
			if(to === void 0 || to === null) {
				throw new TypeError("'to' is not nullable");
			}
			if(by === void 0) {
				by = null;
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			var node = location({
				kind: NodeKind.ArrayRange,
				from: from.value,
				to: to.value
			}, first, last);
			if(Type.isValue(by)) {
				node.by = by.value;
			}
			return node;
		}
		function ArrayRangeTI(then, til, by, first, last) {
			if(arguments.length < 5) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(then === void 0 || then === null) {
				throw new TypeError("'then' is not nullable");
			}
			if(til === void 0 || til === null) {
				throw new TypeError("'til' is not nullable");
			}
			if(by === void 0) {
				by = null;
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			var node = location({
				kind: NodeKind.ArrayRange,
				then: then.value,
				til: til.value
			}, first, last);
			if(Type.isValue(by)) {
				node.by = by.value;
			}
			return node;
		}
		function ArrayRangeTO(then, to, by, first, last) {
			if(arguments.length < 5) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(then === void 0 || then === null) {
				throw new TypeError("'then' is not nullable");
			}
			if(to === void 0 || to === null) {
				throw new TypeError("'to' is not nullable");
			}
			if(by === void 0) {
				by = null;
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			var node = location({
				kind: NodeKind.ArrayRange,
				then: then.value,
				to: to.value
			}, first, last);
			if(Type.isValue(by)) {
				node.by = by.value;
			}
			return node;
		}
		function AssignmentOperator(operator, first) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(operator === void 0 || operator === null) {
				throw new TypeError("'operator' is not nullable");
			}
			else if(!Type.is(operator, AssignmentOperatorKind)) {
				throw new TypeError("'operator' is not of type 'AssignmentOperatorKind'");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			return location({
				kind: BinaryOperatorKind.Assignment,
				assignment: operator
			}, first);
		}
		function AttributeDeclaration(declaration, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(declaration === void 0 || declaration === null) {
				throw new TypeError("'declaration' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.AttributeDeclaration,
				declaration: declaration.value
			}, first, last);
		}
		function AttributeExpression(name, __ks_arguments_1, first, last) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(name === void 0 || name === null) {
				throw new TypeError("'name' is not nullable");
			}
			if(__ks_arguments_1 === void 0 || __ks_arguments_1 === null) {
				throw new TypeError("'arguments' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.AttributeExpression,
				name: name.value,
				arguments: Helper.mapArray(__ks_arguments_1, function(argument) {
					return argument.value;
				})
			}, first, last);
		}
		function AttributeOperation(name, value, first, last) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(name === void 0 || name === null) {
				throw new TypeError("'name' is not nullable");
			}
			if(value === void 0 || value === null) {
				throw new TypeError("'value' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.AttributeOperation,
				name: name.value,
				value: value.value
			}, first, last);
		}
		function AwaitExpression(variables, autotype, operand, first, last) {
			if(arguments.length < 5) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(variables === void 0) {
				variables = null;
			}
			if(autotype === void 0 || autotype === null) {
				throw new TypeError("'autotype' is not nullable");
			}
			if(operand === void 0 || operand === null) {
				throw new TypeError("'operand' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			var node = location({
				kind: NodeKind.AwaitExpression,
				operation: operand.value
			}, first, last);
			if(variables !== null) {
				node.variables = Helper.mapArray(variables, function(variable) {
					return variable.value;
				});
			}
			if(autotype) {
				node.autotype = true;
			}
			return node;
		}
		function BinaryExpression() {
			if(arguments.length === 1) {
				var __ks_i = -1;
				var operator = arguments[++__ks_i];
				if(operator === void 0 || operator === null) {
					throw new TypeError("'operator' is not nullable");
				}
				return location({
					kind: NodeKind.BinaryExpression,
					operator: operator.value
				}, operator);
			}
			else if(arguments.length >= 3 && arguments.length <= 5) {
				var __ks_i = -1;
				var left = arguments[++__ks_i];
				if(left === void 0 || left === null) {
					throw new TypeError("'left' is not nullable");
				}
				var operator = arguments[++__ks_i];
				if(operator === void 0 || operator === null) {
					throw new TypeError("'operator' is not nullable");
				}
				var right = arguments[++__ks_i];
				if(right === void 0 || right === null) {
					throw new TypeError("'right' is not nullable");
				}
				var __ks__;
				var first = arguments.length > 3 && (__ks__ = arguments[++__ks_i]) !== void 0 && __ks__ !== null ? __ks__ : left;
				var last = arguments.length > 4 && (__ks__ = arguments[++__ks_i]) !== void 0 && __ks__ !== null ? __ks__ : right;
				return location({
					kind: NodeKind.BinaryExpression,
					operator: operator.value,
					left: left.value,
					right: right.value
				}, first, last);
			}
			else {
				throw new SyntaxError("wrong number of arguments");
			}
		};
		function BinaryOperator(operator, first) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(operator === void 0 || operator === null) {
				throw new TypeError("'operator' is not nullable");
			}
			else if(!Type.is(operator, BinaryOperatorKind)) {
				throw new TypeError("'operator' is not of type 'BinaryOperatorKind'");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			return location({
				kind: operator
			}, first);
		}
		function BindingElement() {
			if(arguments.length === 1) {
				var __ks_i = -1;
				var name = arguments[++__ks_i];
				if(name === void 0 || name === null) {
					throw new TypeError("'name' is not nullable");
				}
				return location({
					kind: NodeKind.BindingElement,
					name: name.value
				}, name);
			}
			else if(arguments.length === 6) {
				var __ks_i = -1;
				var name = arguments[++__ks_i];
				if(name === void 0 || name === null) {
					throw new TypeError("'name' is not nullable");
				}
				var alias = arguments[++__ks_i];
				if(alias === void 0) {
					alias = null;
				}
				var spread = arguments[++__ks_i];
				if(spread === void 0) {
					spread = null;
				}
				var defaultValue = arguments[++__ks_i];
				if(defaultValue === void 0) {
					defaultValue = null;
				}
				var first = arguments[++__ks_i];
				if(first === void 0 || first === null) {
					throw new TypeError("'first' is not nullable");
				}
				var last = arguments[++__ks_i];
				if(last === void 0 || last === null) {
					throw new TypeError("'last' is not nullable");
				}
				var node = location({
					kind: NodeKind.BindingElement,
					name: name.value
				}, first, last);
				if(Type.isValue(alias)) {
					node.alias = alias.value;
				}
				if(Type.isValue(spread)) {
					node.spread = true;
				}
				if(Type.isValue(defaultValue)) {
					node.defaultValue = defaultValue.value;
				}
				return node;
			}
			else {
				throw new SyntaxError("wrong number of arguments");
			}
		};
		function Block(attributes, statements, first, last) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(attributes === void 0 || attributes === null) {
				throw new TypeError("'attributes' is not nullable");
			}
			if(statements === void 0 || statements === null) {
				throw new TypeError("'statements' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.Block,
				attributes: Helper.mapArray(attributes, function(attribute) {
					return attribute.value;
				}),
				statements: Helper.mapArray(statements, function(statement) {
					return statement.value;
				})
			}, first, last);
		}
		function BreakStatement(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			return location({
				kind: NodeKind.BreakStatement
			}, first);
		}
		function CallExpression() {
			if(arguments.length === 4) {
				var __ks_i = -1;
				var callee = arguments[++__ks_i];
				if(callee === void 0 || callee === null) {
					throw new TypeError("'callee' is not nullable");
				}
				var __ks_arguments_1 = arguments[++__ks_i];
				if(__ks_arguments_1 === void 0 || __ks_arguments_1 === null) {
					throw new TypeError("'arguments' is not nullable");
				}
				var first = arguments[++__ks_i];
				if(first === void 0 || first === null) {
					throw new TypeError("'first' is not nullable");
				}
				var last = arguments[++__ks_i];
				if(last === void 0 || last === null) {
					throw new TypeError("'last' is not nullable");
				}
				return location({
					kind: NodeKind.CallExpression,
					scope: {
						kind: ScopeKind.This
					},
					callee: callee.value,
					arguments: Helper.mapArray(__ks_arguments_1.value, function(argument) {
						return argument.value;
					}),
					nullable: false
				}, first, last);
			}
			else if(arguments.length === 6) {
				var __ks_i = -1;
				var scope = arguments[++__ks_i];
				if(scope === void 0 || scope === null) {
					throw new TypeError("'scope' is not nullable");
				}
				var callee = arguments[++__ks_i];
				if(callee === void 0 || callee === null) {
					throw new TypeError("'callee' is not nullable");
				}
				var __ks_arguments_1 = arguments[++__ks_i];
				if(__ks_arguments_1 === void 0 || __ks_arguments_1 === null) {
					throw new TypeError("'arguments' is not nullable");
				}
				var nullable = arguments[++__ks_i];
				if(nullable === void 0 || nullable === null) {
					throw new TypeError("'nullable' is not nullable");
				}
				else if(!Type.isBoolean(nullable)) {
					throw new TypeError("'nullable' is not of type 'Boolean'");
				}
				var first = arguments[++__ks_i];
				if(first === void 0 || first === null) {
					throw new TypeError("'first' is not nullable");
				}
				var last = arguments[++__ks_i];
				if(last === void 0 || last === null) {
					throw new TypeError("'last' is not nullable");
				}
				return location({
					kind: NodeKind.CallExpression,
					scope: scope,
					callee: callee.value,
					arguments: Helper.mapArray(__ks_arguments_1.value, function(argument) {
						return argument.value;
					}),
					nullable: nullable
				}, first, last);
			}
			else {
				throw new SyntaxError("wrong number of arguments");
			}
		};
		function CallMacroExpression(callee, __ks_arguments_1, first, last) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(callee === void 0 || callee === null) {
				throw new TypeError("'callee' is not nullable");
			}
			if(__ks_arguments_1 === void 0 || __ks_arguments_1 === null) {
				throw new TypeError("'arguments' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.CallMacroExpression,
				callee: callee.value,
				arguments: Helper.mapArray(__ks_arguments_1.value, function(argument) {
					return argument.value;
				})
			}, first, last);
		}
		function CatchClause(binding, type, body, first, last) {
			if(arguments.length < 5) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(binding === void 0) {
				binding = null;
			}
			if(type === void 0) {
				type = null;
			}
			if(body === void 0 || body === null) {
				throw new TypeError("'body' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			var node = location({
				kind: NodeKind.CatchClause,
				body: body.value
			}, first, last);
			if(binding !== null) {
				node.binding = binding.value;
			}
			if(type !== null) {
				node.type = type.value;
			}
			return node;
		}
		function ClassDeclaration(name, version, __ks_extends_1, modifiers, members, first, last) {
			if(arguments.length < 7) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 7)");
			}
			if(name === void 0 || name === null) {
				throw new TypeError("'name' is not nullable");
			}
			if(version === void 0) {
				version = null;
			}
			if(__ks_extends_1 === void 0) {
				__ks_extends_1 = null;
			}
			if(modifiers === void 0 || modifiers === null) {
				throw new TypeError("'modifiers' is not nullable");
			}
			if(members === void 0 || members === null) {
				throw new TypeError("'members' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			var node = location({
				kind: NodeKind.ClassDeclaration,
				name: name.value,
				modifiers: Helper.mapArray(modifiers, function(modifier) {
					return modifier.value;
				}),
				members: Helper.mapArray(members, function(member) {
					return member.value;
				})
			}, first, last);
			if(version !== null) {
				node.version = version.value;
			}
			if(__ks_extends_1 !== null) {
				node.extends = __ks_extends_1.value;
			}
			return node;
		}
		function ConditionalExpression(condition, whenTrue, whenFalse) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(condition === void 0 || condition === null) {
				throw new TypeError("'condition' is not nullable");
			}
			if(whenTrue === void 0 || whenTrue === null) {
				throw new TypeError("'whenTrue' is not nullable");
			}
			if(whenFalse === void 0 || whenFalse === null) {
				throw new TypeError("'whenFalse' is not nullable");
			}
			return location({
				kind: NodeKind.ConditionalExpression,
				condition: condition.value,
				whenTrue: whenTrue.value,
				whenFalse: whenFalse.value
			}, condition, whenFalse);
		}
		function ContinueStatement(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			return location({
				kind: NodeKind.ContinueStatement
			}, first);
		}
		function CreateExpression(__ks_class_1, __ks_arguments_1, first, last) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(__ks_class_1 === void 0 || __ks_class_1 === null) {
				throw new TypeError("'class' is not nullable");
			}
			if(__ks_arguments_1 === void 0 || __ks_arguments_1 === null) {
				throw new TypeError("'arguments' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.CreateExpression,
				class: __ks_class_1.value,
				arguments: Helper.mapArray(__ks_arguments_1.value, function(argument) {
					return argument.value;
				})
			}, first, last);
		}
		function CurryExpression(scope, callee, __ks_arguments_1, first, last) {
			if(arguments.length < 5) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(scope === void 0 || scope === null) {
				throw new TypeError("'scope' is not nullable");
			}
			if(callee === void 0 || callee === null) {
				throw new TypeError("'callee' is not nullable");
			}
			if(__ks_arguments_1 === void 0 || __ks_arguments_1 === null) {
				throw new TypeError("'arguments' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.CurryExpression,
				scope: scope,
				callee: callee.value,
				arguments: Helper.mapArray(__ks_arguments_1.value, function(argument) {
					return argument.value;
				})
			}, first, last);
		}
		function DestroyStatement(variable, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(variable === void 0 || variable === null) {
				throw new TypeError("'variable' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.DestroyStatement,
				variable: variable.value
			}, first, last);
		}
		function DoUntilStatement(condition, body, first, last) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(condition === void 0 || condition === null) {
				throw new TypeError("'condition' is not nullable");
			}
			if(body === void 0 || body === null) {
				throw new TypeError("'body' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.DoUntilStatement,
				condition: condition.value,
				body: body.value
			}, first, last);
		}
		function DoWhileStatement(condition, body, first, last) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(condition === void 0 || condition === null) {
				throw new TypeError("'condition' is not nullable");
			}
			if(body === void 0 || body === null) {
				throw new TypeError("'body' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.DoWhileStatement,
				condition: condition.value,
				body: body.value
			}, first, last);
		}
		function EnumExpression(__ks_enum_1, member) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(__ks_enum_1 === void 0 || __ks_enum_1 === null) {
				throw new TypeError("'enum' is not nullable");
			}
			if(member === void 0 || member === null) {
				throw new TypeError("'member' is not nullable");
			}
			return location({
				kind: NodeKind.EnumExpression,
				enum: __ks_enum_1.value,
				member: member.value
			}, __ks_enum_1, member);
		}
		function EnumDeclaration(name, type, members, first, last) {
			if(arguments.length < 5) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(name === void 0 || name === null) {
				throw new TypeError("'name' is not nullable");
			}
			if(type === void 0) {
				type = null;
			}
			if(members === void 0 || members === null) {
				throw new TypeError("'members' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			var node = location({
				kind: NodeKind.EnumDeclaration,
				name: name.value,
				members: members
			}, first, last);
			if(type !== null) {
				node.type = type.value;
			}
			return node;
		}
		function EnumMember() {
			if(arguments.length === 1) {
				var __ks_i = -1;
				var name = arguments[++__ks_i];
				if(name === void 0 || name === null) {
					throw new TypeError("'name' is not nullable");
				}
				return location({
					kind: NodeKind.EnumMember,
					name: name.value
				}, name);
			}
			else if(arguments.length === 2) {
				var __ks_i = -1;
				var name = arguments[++__ks_i];
				if(name === void 0 || name === null) {
					throw new TypeError("'name' is not nullable");
				}
				var value = arguments[++__ks_i];
				if(value === void 0 || value === null) {
					throw new TypeError("'value' is not nullable");
				}
				return location({
					kind: NodeKind.EnumMember,
					name: name.value,
					value: value.value
				}, name, value);
			}
			else {
				throw new SyntaxError("wrong number of arguments");
			}
		};
		function ExportDeclaration(declarations, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(declarations === void 0 || declarations === null) {
				throw new TypeError("'declarations' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.ExportDeclaration,
				declarations: Helper.mapArray(declarations, function(declarator) {
					return declarator.value;
				})
			}, first, last);
		}
		function ExportDeclarationSpecifier(declaration) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(declaration === void 0 || declaration === null) {
				throw new TypeError("'declaration' is not nullable");
			}
			return location({
				kind: NodeKind.ExportDeclarationSpecifier,
				declaration: declaration.value
			}, declaration);
		}
		function ExportNamedSpecifier(local, exported) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(local === void 0 || local === null) {
				throw new TypeError("'local' is not nullable");
			}
			if(exported === void 0 || exported === null) {
				throw new TypeError("'exported' is not nullable");
			}
			return location({
				kind: NodeKind.ExportNamedSpecifier,
				local: local.value,
				exported: exported.value
			}, local, exported);
		}
		function ExportPropertiesSpecifier(object, properties, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(object === void 0 || object === null) {
				throw new TypeError("'object' is not nullable");
			}
			if(properties === void 0 || properties === null) {
				throw new TypeError("'properties' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.ExportPropertiesSpecifier,
				object: object.value,
				properties: properties
			}, object, last);
		}
		function ExportWildcardSpecifier(local, end) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(local === void 0 || local === null) {
				throw new TypeError("'local' is not nullable");
			}
			if(end === void 0 || end === null) {
				throw new TypeError("'end' is not nullable");
			}
			return location({
				kind: NodeKind.ExportWildcardSpecifier,
				local: local.value
			}, local, end);
		}
		function ExternDeclaration(declarations, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(declarations === void 0 || declarations === null) {
				throw new TypeError("'declarations' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.ExternDeclaration,
				declarations: Helper.mapArray(declarations, function(declarator) {
					return declarator.value;
				})
			}, first, last);
		}
		function ExternOrRequireDeclaration(declarations, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(declarations === void 0 || declarations === null) {
				throw new TypeError("'declarations' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.ExternOrRequireDeclaration,
				declarations: Helper.mapArray(declarations, function(declarator) {
					return declarator.value;
				})
			}, first, last);
		}
		function FieldDeclaration(attributes, modifiers, name, type, defaultValue, first, last) {
			if(arguments.length < 7) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 7)");
			}
			if(attributes === void 0) {
				attributes = null;
			}
			if(modifiers === void 0 || modifiers === null) {
				throw new TypeError("'modifiers' is not nullable");
			}
			if(name === void 0 || name === null) {
				throw new TypeError("'name' is not nullable");
			}
			if(type === void 0) {
				type = null;
			}
			if(defaultValue === void 0) {
				defaultValue = null;
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			var node = location({
				kind: NodeKind.FieldDeclaration,
				modifiers: Helper.mapArray(modifiers, function(modifier) {
					return modifier.value;
				}),
				name: name.value
			}, first, last);
			if(attributes !== null) {
				node.attributes = Helper.mapArray(attributes.value, function(attribute) {
					return attribute.value;
				});
			}
			if(type !== null) {
				node.type = type.value;
			}
			if(defaultValue !== null) {
				node.defaultValue = defaultValue.value;
			}
			return node;
		}
		function ForFromStatement(declaration, variable, from, til, to, by, until, __ks_while_1, when, first, last) {
			if(arguments.length < 11) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 11)");
			}
			if(declaration === void 0 || declaration === null) {
				throw new TypeError("'declaration' is not nullable");
			}
			else if(!Type.isBoolean(declaration)) {
				throw new TypeError("'declaration' is not of type 'Boolean'");
			}
			if(variable === void 0 || variable === null) {
				throw new TypeError("'variable' is not nullable");
			}
			if(from === void 0 || from === null) {
				throw new TypeError("'from' is not nullable");
			}
			if(til === void 0) {
				til = null;
			}
			if(to === void 0) {
				to = null;
			}
			if(by === void 0) {
				by = null;
			}
			if(until === void 0) {
				until = null;
			}
			if(__ks_while_1 === void 0) {
				__ks_while_1 = null;
			}
			if(when === void 0) {
				when = null;
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			var node = location({
				kind: NodeKind.ForFromStatement,
				variable: variable.value,
				from: from.value,
				declaration: declaration
			}, first, last);
			if(til !== null) {
				node.til = til.value;
			}
			else if(to !== null) {
				node.to = to.value;
			}
			if(by !== null) {
				node.by = by.value;
			}
			if(until !== null) {
				node.until = until.value;
			}
			else if(__ks_while_1 !== null) {
				node.while = __ks_while_1.value;
			}
			if(when !== null) {
				node.when = when.value;
			}
			return node;
		}
		function ForInStatement(declaration, value, index, expression, desc, from, til, to, until, __ks_while_1, when, first, last) {
			if(arguments.length < 13) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 13)");
			}
			if(declaration === void 0 || declaration === null) {
				throw new TypeError("'declaration' is not nullable");
			}
			else if(!Type.isBoolean(declaration)) {
				throw new TypeError("'declaration' is not of type 'Boolean'");
			}
			if(value === void 0) {
				value = null;
			}
			if(index === void 0) {
				index = null;
			}
			if(expression === void 0 || expression === null) {
				throw new TypeError("'expression' is not nullable");
			}
			if(desc === void 0) {
				desc = null;
			}
			if(from === void 0) {
				from = null;
			}
			if(til === void 0) {
				til = null;
			}
			if(to === void 0) {
				to = null;
			}
			if(until === void 0) {
				until = null;
			}
			if(__ks_while_1 === void 0) {
				__ks_while_1 = null;
			}
			if(when === void 0) {
				when = null;
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			var node = location({
				kind: NodeKind.ForInStatement,
				expression: expression.value,
				desc: desc !== null,
				declaration: declaration
			}, first, last);
			if(value !== null) {
				node.value = value.value;
			}
			if(index !== null) {
				node.index = index.value;
			}
			if(from !== null) {
				node.from = from.value;
			}
			if(til !== null) {
				node.til = til.value;
			}
			else if(to !== null) {
				node.to = to.value;
			}
			if(until !== null) {
				node.until = until.value;
			}
			else if(__ks_while_1 !== null) {
				node.while = __ks_while_1.value;
			}
			if(when !== null) {
				node.when = when.value;
			}
			return node;
		}
		function ForRangeStatement(declaration, value, index, from, til, to, by, until, __ks_while_1, when, first, last) {
			if(arguments.length < 12) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 12)");
			}
			if(declaration === void 0 || declaration === null) {
				throw new TypeError("'declaration' is not nullable");
			}
			else if(!Type.isBoolean(declaration)) {
				throw new TypeError("'declaration' is not of type 'Boolean'");
			}
			if(value === void 0 || value === null) {
				throw new TypeError("'value' is not nullable");
			}
			if(index === void 0) {
				index = null;
			}
			if(from === void 0 || from === null) {
				throw new TypeError("'from' is not nullable");
			}
			if(til === void 0) {
				til = null;
			}
			if(to === void 0) {
				to = null;
			}
			if(by === void 0) {
				by = null;
			}
			if(until === void 0) {
				until = null;
			}
			if(__ks_while_1 === void 0) {
				__ks_while_1 = null;
			}
			if(when === void 0) {
				when = null;
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			var node = location({
				kind: NodeKind.ForRangeStatement,
				value: value.value,
				from: from.value,
				declaration: declaration
			}, first, last);
			if(index !== null) {
				node.index = index.value;
			}
			if(til !== null) {
				node.til = til.value;
			}
			else if(to !== null) {
				node.to = to.value;
			}
			if(by !== null) {
				node.by = by.value;
			}
			if(until !== null) {
				node.until = until.value;
			}
			else if(__ks_while_1 !== null) {
				node.while = __ks_while_1.value;
			}
			if(when !== null) {
				node.when = when.value;
			}
			return node;
		}
		function ForOfStatement(declaration, key, value, expression, until, __ks_while_1, when, first, last) {
			if(arguments.length < 9) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 9)");
			}
			if(declaration === void 0 || declaration === null) {
				throw new TypeError("'declaration' is not nullable");
			}
			else if(!Type.isBoolean(declaration)) {
				throw new TypeError("'declaration' is not of type 'Boolean'");
			}
			if(key === void 0) {
				key = null;
			}
			if(value === void 0) {
				value = null;
			}
			if(expression === void 0 || expression === null) {
				throw new TypeError("'expression' is not nullable");
			}
			if(until === void 0) {
				until = null;
			}
			if(__ks_while_1 === void 0) {
				__ks_while_1 = null;
			}
			if(when === void 0) {
				when = null;
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			var node = location({
				kind: NodeKind.ForOfStatement,
				expression: expression.value,
				declaration: declaration
			}, first, last);
			if(key !== null) {
				node.key = key.value;
			}
			if(value !== null) {
				node.value = value.value;
			}
			if(until !== null) {
				node.until = until.value;
			}
			else if(__ks_while_1 !== null) {
				node.while = __ks_while_1.value;
			}
			if(when !== null) {
				node.when = when.value;
			}
			return node;
		}
		function FunctionDeclaration(name, parameters, modifiers, type, __ks_throws_1, body, first, last) {
			if(arguments.length < 8) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 8)");
			}
			if(name === void 0 || name === null) {
				throw new TypeError("'name' is not nullable");
			}
			if(parameters === void 0) {
				parameters = null;
			}
			if(modifiers === void 0) {
				modifiers = null;
			}
			if(type === void 0) {
				type = null;
			}
			if(__ks_throws_1 === void 0) {
				__ks_throws_1 = null;
			}
			if(body === void 0) {
				body = null;
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			var node = location({
				kind: NodeKind.FunctionDeclaration,
				name: name.value
			}, first, last);
			if(parameters === null) {
				node.parameters = [];
			}
			else {
				node.parameters = Helper.mapArray(parameters.value, function(parameter) {
					return parameter.value;
				});
			}
			if(modifiers === null) {
				node.modifiers = [];
			}
			else {
				node.modifiers = Helper.mapArray(modifiers.value, function(modifier) {
					return modifier.value;
				});
			}
			if(type !== null) {
				node.type = type.value;
			}
			if(__ks_throws_1 === null) {
				node.throws = [];
			}
			else {
				node.throws = Helper.mapArray(__ks_throws_1.value, function(__ks_throw_1) {
					return __ks_throw_1.value;
				});
			}
			if(body !== null) {
				node.body = body.value;
			}
			return node;
		}
		function FunctionExpression(parameters, modifiers, type, body, first, last) {
			if(arguments.length < 6) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 6)");
			}
			if(parameters === void 0 || parameters === null) {
				throw new TypeError("'parameters' is not nullable");
			}
			if(modifiers === void 0) {
				modifiers = null;
			}
			if(type === void 0) {
				type = null;
			}
			if(body === void 0) {
				body = null;
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			var node = location({
				kind: NodeKind.FunctionExpression,
				parameters: Helper.mapArray(parameters.value, function(parameter) {
					return parameter.value;
				})
			}, first, last);
			if(modifiers === null) {
				node.modifiers = [];
			}
			else {
				node.modifiers = Helper.mapArray(modifiers.value, function(modifier) {
					return modifier.value;
				});
			}
			if(type !== null) {
				node.type = type.value;
			}
			if(body !== null) {
				node.body = body.value;
			}
			return node;
		}
		function IfExpression(condition, whenTrue, whenFalse, first, last) {
			if(arguments.length < 5) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(condition === void 0 || condition === null) {
				throw new TypeError("'condition' is not nullable");
			}
			if(whenTrue === void 0 || whenTrue === null) {
				throw new TypeError("'whenTrue' is not nullable");
			}
			if(whenFalse === void 0) {
				whenFalse = null;
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			var node = location({
				kind: NodeKind.IfExpression,
				condition: condition.value,
				whenTrue: whenTrue.value
			}, first, last);
			if(whenFalse !== null) {
				node.whenFalse = whenFalse.value;
			}
			return node;
		}
		function IfStatement(condition, whenTrue, whenFalse, first, last) {
			if(arguments.length < 5) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(condition === void 0 || condition === null) {
				throw new TypeError("'condition' is not nullable");
			}
			if(whenTrue === void 0 || whenTrue === null) {
				throw new TypeError("'whenTrue' is not nullable");
			}
			if(whenFalse === void 0) {
				whenFalse = null;
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			var node = location({
				kind: NodeKind.IfStatement,
				condition: condition.value,
				whenTrue: whenTrue.value
			}, first, last);
			if(whenFalse !== null) {
				node.whenFalse = whenFalse.value;
			}
			return node;
		}
		function ImplementDeclaration(variable, properties, first, last) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(variable === void 0 || variable === null) {
				throw new TypeError("'variable' is not nullable");
			}
			if(properties === void 0 || properties === null) {
				throw new TypeError("'properties' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.ImplementDeclaration,
				variable: variable.value,
				properties: Helper.mapArray(properties, function(property) {
					return property.value;
				})
			}, first, last);
		}
		function ImportDeclaration(declarations, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(declarations === void 0 || declarations === null) {
				throw new TypeError("'declarations' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.ImportDeclaration,
				declarations: Helper.mapArray(declarations, function(declaration) {
					return declaration.value;
				})
			}, first, last);
		}
		function ImportDeclarator(source, specifiers, __ks_arguments_1, first, last) {
			if(arguments.length < 5) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(source === void 0 || source === null) {
				throw new TypeError("'source' is not nullable");
			}
			if(specifiers === void 0 || specifiers === null) {
				throw new TypeError("'specifiers' is not nullable");
			}
			if(__ks_arguments_1 === void 0) {
				__ks_arguments_1 = null;
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			var node = location({
				kind: NodeKind.ImportDeclarator,
				source: source.value,
				specifiers: Helper.mapArray(specifiers, function(specifier) {
					return specifier.value;
				})
			}, first, last);
			if(__ks_arguments_1 !== null) {
				node.arguments = Helper.mapArray(__ks_arguments_1, function(argument) {
					return argument.value;
				});
			}
			return node;
		}
		function ImportNamespaceSpecifier(local, specifiers, first, last) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(local === void 0 || local === null) {
				throw new TypeError("'local' is not nullable");
			}
			if(specifiers === void 0) {
				specifiers = null;
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			var node = location({
				kind: NodeKind.ImportNamespaceSpecifier,
				local: local.value
			}, first, last);
			if(specifiers !== null) {
				node.specifiers = Helper.mapArray(specifiers, function(specifier) {
					return specifier.value;
				});
			}
			return node;
		}
		function ImportSpecifier(imported, local, first, last) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(imported === void 0 || imported === null) {
				throw new TypeError("'imported' is not nullable");
			}
			if(local === void 0 || local === null) {
				throw new TypeError("'local' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.ImportSpecifier,
				imported: imported.value,
				local: local.value
			}, first, last);
		}
		function Identifier(name, first) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(name === void 0 || name === null) {
				throw new TypeError("'name' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			return location({
				kind: NodeKind.Identifier,
				name: name
			}, first);
		}
		function IncludeAgainDeclaration(files, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(files === void 0 || files === null) {
				throw new TypeError("'files' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.IncludeAgainDeclaration,
				files: files
			}, first, last);
		}
		function IncludeDeclaration(files, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(files === void 0 || files === null) {
				throw new TypeError("'files' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.IncludeDeclaration,
				files: files
			}, first, last);
		}
		function LambdaExpression(parameters, modifiers, type, body, first, last) {
			if(arguments.length < 6) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 6)");
			}
			if(parameters === void 0 || parameters === null) {
				throw new TypeError("'parameters' is not nullable");
			}
			if(modifiers === void 0) {
				modifiers = null;
			}
			if(type === void 0) {
				type = null;
			}
			if(body === void 0 || body === null) {
				throw new TypeError("'body' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			var node = location({
				kind: NodeKind.LambdaExpression,
				modifiers: [],
				parameters: Helper.mapArray(parameters.value, function(parameter) {
					return parameter.value;
				}),
				body: body.value
			}, first, last);
			if(modifiers === null) {
				node.modifiers = [];
			}
			else {
				node.modifiers = Helper.mapArray(modifiers.value, function(modifier) {
					return modifier.value;
				});
			}
			if(type !== null) {
				node.type = type.value;
			}
			return node;
		}
		function Literal() {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			var __ks_i = -1;
			var value = arguments[++__ks_i];
			if(value === void 0 || value === null) {
				throw new TypeError("'value' is not nullable");
			}
			var first = arguments[++__ks_i];
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var __ks__;
			var last = arguments.length > 2 && (__ks__ = arguments[++__ks_i]) !== void 0 ? __ks__ : null;
			return location({
				kind: NodeKind.Literal,
				value: value
			}, first, last);
		}
		function MacroDeclaration(name, parameters, body, first, last) {
			if(arguments.length < 5) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(name === void 0 || name === null) {
				throw new TypeError("'name' is not nullable");
			}
			if(parameters === void 0 || parameters === null) {
				throw new TypeError("'parameters' is not nullable");
			}
			if(body === void 0 || body === null) {
				throw new TypeError("'body' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.MacroDeclaration,
				name: name.value,
				parameters: Helper.mapArray(parameters.value, function(parameter) {
					return parameter.value;
				}),
				body: body.value
			}, first, last);
		}
		function MacroExpression(elements, multilines, first, last) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(elements === void 0 || elements === null) {
				throw new TypeError("'elements' is not nullable");
			}
			if(multilines === void 0 || multilines === null) {
				throw new TypeError("'multilines' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.MacroExpression,
				elements: Helper.mapArray(elements, function(element) {
					return element.value;
				}),
				multilines: multilines
			}, first, last);
		}
		function MacroElementExpression(expression, reification, first, last) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(expression === void 0 || expression === null) {
				throw new TypeError("'expression' is not nullable");
			}
			if(reification === void 0) {
				reification = null;
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			var node = location({
				kind: MacroElementKind.Expression,
				expression: expression.value
			}, first, last);
			if(reification === null) {
				node.reification = {
					kind: ReificationKind.Expression
				};
			}
			else {
				node.reification = reification;
			}
			return node;
		}
		function MacroElementLiteral(value, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(value === void 0 || value === null) {
				throw new TypeError("'value' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: MacroElementKind.Literal,
				value: value
			}, first, last);
		}
		function MacroElementNewLine(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			return location({
				kind: MacroElementKind.NewLine
			}, first);
		}
		function MacroReification(value, first) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(value === void 0 || value === null) {
				throw new TypeError("'value' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(value === "a") {
				return location({
					kind: ReificationKind.Arguments
				}, first);
			}
			else if(value === "b") {
				return location({
					kind: ReificationKind.Block
				}, first);
			}
			else if(value === "e") {
				return location({
					kind: ReificationKind.Expression
				}, first);
			}
			else if(value === "i") {
				return location({
					kind: ReificationKind.Identifier
				}, first);
			}
		}
		function MemberExpression() {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			var __ks_i = -1;
			var object = arguments[++__ks_i];
			if(object === void 0 || object === null) {
				throw new TypeError("'object' is not nullable");
			}
			var property = arguments[++__ks_i];
			if(property === void 0 || property === null) {
				throw new TypeError("'property' is not nullable");
			}
			var computed = arguments[++__ks_i];
			if(computed === void 0 || computed === null) {
				throw new TypeError("'computed' is not nullable");
			}
			var nullable = arguments[++__ks_i];
			if(nullable === void 0 || nullable === null) {
				throw new TypeError("'nullable' is not nullable");
			}
			var __ks__;
			var first = arguments.length > 4 && (__ks__ = arguments[++__ks_i]) !== void 0 && __ks__ !== null ? __ks__ : object;
			var last = arguments.length > 5 && (__ks__ = arguments[++__ks_i]) !== void 0 && __ks__ !== null ? __ks__ : property;
			return location({
				kind: NodeKind.MemberExpression,
				object: object.value,
				property: property.value,
				computed: computed,
				nullable: nullable
			}, first, last);
		}
		function MethodDeclaration(attributes, modifiers, name, parameters, type, __ks_throws_1, body, first, last) {
			if(arguments.length < 9) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 9)");
			}
			if(attributes === void 0) {
				attributes = null;
			}
			if(modifiers === void 0 || modifiers === null) {
				throw new TypeError("'modifiers' is not nullable");
			}
			if(name === void 0 || name === null) {
				throw new TypeError("'name' is not nullable");
			}
			if(parameters === void 0 || parameters === null) {
				throw new TypeError("'parameters' is not nullable");
			}
			if(type === void 0) {
				type = null;
			}
			if(__ks_throws_1 === void 0) {
				__ks_throws_1 = null;
			}
			if(body === void 0) {
				body = null;
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			var node = location({
				kind: NodeKind.MethodDeclaration,
				modifiers: Helper.mapArray(modifiers, function(modifier) {
					return modifier.value;
				}),
				name: name.value,
				parameters: Helper.mapArray(parameters.value, function(parameter) {
					return parameter.value;
				})
			}, first, last);
			if(attributes !== null) {
				node.attributes = Helper.mapArray(attributes.value, function(attribute) {
					return attribute.value;
				});
			}
			if(type !== null) {
				node.type = type.value;
			}
			if(__ks_throws_1 === null) {
				node.throws = [];
			}
			else {
				node.throws = Helper.mapArray(__ks_throws_1.value, function(__ks_throw_1) {
					return __ks_throw_1.value;
				});
			}
			if(body !== null) {
				node.body = body.value;
			}
			return node;
		}
		function Modifier() {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			var __ks_i = -1;
			var kind = arguments[++__ks_i];
			if(kind === void 0 || kind === null) {
				throw new TypeError("'kind' is not nullable");
			}
			var first = arguments[++__ks_i];
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var __ks__;
			var last = arguments.length > 2 && (__ks__ = arguments[++__ks_i]) !== void 0 ? __ks__ : null;
			return location({
				kind: kind
			}, first, last);
		}
		function Module(attributes, body, parser) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(attributes === void 0 || attributes === null) {
				throw new TypeError("'attributes' is not nullable");
			}
			if(body === void 0 || body === null) {
				throw new TypeError("'body' is not nullable");
			}
			if(parser === void 0 || parser === null) {
				throw new TypeError("'parser' is not nullable");
			}
			else if(!Type.is(parser, Parser)) {
				throw new TypeError("'parser' is not of type 'Parser'");
			}
			return location({
				kind: NodeKind.Module,
				attributes: Helper.mapArray(attributes, function(attribute) {
					return attribute.value;
				}),
				body: body,
				start: {
					line: 1,
					column: 1
				}
			}, parser.position());
		}
		function MutatorDeclaration() {
			if(arguments.length === 1) {
				var __ks_i = -1;
				var first = arguments[++__ks_i];
				if(first === void 0 || first === null) {
					throw new TypeError("'first' is not nullable");
				}
				return location({
					kind: NodeKind.MutatorDeclaration
				}, first);
			}
			else if(arguments.length === 3) {
				var __ks_i = -1;
				var body = arguments[++__ks_i];
				if(body === void 0 || body === null) {
					throw new TypeError("'body' is not nullable");
				}
				var first = arguments[++__ks_i];
				if(first === void 0 || first === null) {
					throw new TypeError("'first' is not nullable");
				}
				var last = arguments[++__ks_i];
				if(last === void 0 || last === null) {
					throw new TypeError("'last' is not nullable");
				}
				return location({
					kind: NodeKind.MutatorDeclaration,
					body: body.value
				}, first, last);
			}
			else {
				throw new SyntaxError("wrong number of arguments");
			}
		};
		function NamedArgument(name, value) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(name === void 0 || name === null) {
				throw new TypeError("'name' is not nullable");
			}
			if(value === void 0 || value === null) {
				throw new TypeError("'value' is not nullable");
			}
			return location({
				kind: NodeKind.NamedArgument,
				name: name.value,
				value: value.value
			}, name, value);
		}
		function Nullable(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			return location({
				kind: NodeKind.TypeReference,
				typeName: {
					kind: NodeKind.Identifier,
					name: "any"
				},
				nullable: true
			}, first);
		}
		function NamespaceDeclaration(modifiers, name, statements, first, last) {
			if(arguments.length < 5) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(modifiers === void 0 || modifiers === null) {
				throw new TypeError("'modifiers' is not nullable");
			}
			if(name === void 0 || name === null) {
				throw new TypeError("'name' is not nullable");
			}
			if(statements === void 0 || statements === null) {
				throw new TypeError("'statements' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.NamespaceDeclaration,
				modifiers: Helper.mapArray(modifiers, function(modifier) {
					return modifier.value;
				}),
				name: name.value,
				statements: Helper.mapArray(statements, function(statement) {
					return statement.value;
				})
			}, first, last);
		}
		function NumericExpression(value, first) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(value === void 0 || value === null) {
				throw new TypeError("'value' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			return location({
				kind: NodeKind.NumericExpression,
				value: value
			}, first);
		}
		function ObjectBinding(elements, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(elements === void 0 || elements === null) {
				throw new TypeError("'elements' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.ObjectBinding,
				elements: Helper.mapArray(elements, function(element) {
					return element.value;
				})
			}, first, last);
		}
		function ObjectExpression(properties, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(properties === void 0 || properties === null) {
				throw new TypeError("'properties' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.ObjectExpression,
				properties: Helper.mapArray(properties, function(property) {
					return property.value;
				})
			}, first, last);
		}
		function ObjectMember() {
			if(arguments.length === 1) {
				var __ks_i = -1;
				var name = arguments[++__ks_i];
				if(name === void 0 || name === null) {
					throw new TypeError("'name' is not nullable");
				}
				return location({
					kind: NodeKind.ObjectMember,
					name: name.value
				}, name, name);
			}
			else if(arguments.length === 2) {
				var __ks_i = -1;
				var name = arguments[++__ks_i];
				if(name === void 0 || name === null) {
					throw new TypeError("'name' is not nullable");
				}
				var value = arguments[++__ks_i];
				if(value === void 0 || value === null) {
					throw new TypeError("'value' is not nullable");
				}
				return location({
					kind: NodeKind.ObjectMember,
					name: name.value,
					value: value.value
				}, name, value);
			}
			else if(arguments.length === 5) {
				var __ks_i = -1;
				var attributes = arguments[++__ks_i];
				if(attributes === void 0) {
					attributes = null;
				}
				var name = arguments[++__ks_i];
				if(name === void 0 || name === null) {
					throw new TypeError("'name' is not nullable");
				}
				var value = arguments[++__ks_i];
				if(value === void 0 || value === null) {
					throw new TypeError("'value' is not nullable");
				}
				var first = arguments[++__ks_i];
				if(first === void 0 || first === null) {
					throw new TypeError("'first' is not nullable");
				}
				var last = arguments[++__ks_i];
				if(last === void 0 || last === null) {
					throw new TypeError("'last' is not nullable");
				}
				var node = location({
					kind: NodeKind.ObjectMember,
					name: name.value,
					value: value.value
				}, first, last);
				if(attributes !== null) {
					node.attributes = Helper.mapArray(attributes.value, function(attribute) {
						return attribute.value;
					});
				}
				return node;
			}
			else {
				throw new SyntaxError("wrong number of arguments");
			}
		};
		function ObjectReference(properties, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(properties === void 0 || properties === null) {
				throw new TypeError("'properties' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.TypeReference,
				typeName: {
					kind: NodeKind.Identifier,
					name: "object"
				},
				properties: properties
			}, first, last);
		}
		function ObjectMemberReference(name, type) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(name === void 0 || name === null) {
				throw new TypeError("'name' is not nullable");
			}
			if(type === void 0 || type === null) {
				throw new TypeError("'type' is not nullable");
			}
			var node;
			return node = location({
				kind: NodeKind.ObjectMember,
				name: name.value,
				type: type.value
			}, name, type);
		}
		function OmittedExpression(spread, first) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(spread === void 0 || spread === null) {
				throw new TypeError("'spread' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var node = location({
				kind: NodeKind.OmittedExpression
			}, first);
			if(spread) {
				node.spread = true;
			}
			else {
				node.end = node.start;
			}
			return node;
		}
		function PropertyDeclaration(attributes, modifiers, name, type, defaultValue, accessor, mutator, first, last) {
			if(arguments.length < 9) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 9)");
			}
			if(attributes === void 0) {
				attributes = null;
			}
			if(modifiers === void 0 || modifiers === null) {
				throw new TypeError("'modifiers' is not nullable");
			}
			if(name === void 0 || name === null) {
				throw new TypeError("'name' is not nullable");
			}
			if(type === void 0) {
				type = null;
			}
			if(defaultValue === void 0) {
				defaultValue = null;
			}
			if(accessor === void 0) {
				accessor = null;
			}
			if(mutator === void 0) {
				mutator = null;
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			var node = location({
				kind: NodeKind.PropertyDeclaration,
				modifiers: Helper.mapArray(modifiers, function(modifier) {
					return modifier.value;
				}),
				name: name.value
			}, first, last);
			if(attributes !== null) {
				node.attributes = Helper.mapArray(attributes.value, function(attribute) {
					return attribute.value;
				});
			}
			if(type !== null) {
				node.type = type.value;
			}
			if(defaultValue !== null) {
				node.defaultValue = defaultValue.value;
			}
			if(accessor !== null) {
				node.accessor = accessor.value;
			}
			if(mutator !== null) {
				node.mutator = mutator.value;
			}
			return node;
		}
		function Parameter() {
			if(arguments.length === 1) {
				var __ks_i = -1;
				var name = arguments[++__ks_i];
				if(name === void 0 || name === null) {
					throw new TypeError("'name' is not nullable");
				}
				return location({
					kind: NodeKind.Parameter,
					modifiers: [],
					name: name.value
				}, name, name);
			}
			else if(arguments.length === 6) {
				var __ks_i = -1;
				var name = arguments[++__ks_i];
				if(name === void 0) {
					name = null;
				}
				var type = arguments[++__ks_i];
				if(type === void 0) {
					type = null;
				}
				var modifiers = arguments[++__ks_i];
				if(modifiers === void 0 || modifiers === null) {
					throw new TypeError("'modifiers' is not nullable");
				}
				var defaultValue = arguments[++__ks_i];
				if(defaultValue === void 0) {
					defaultValue = null;
				}
				var first = arguments[++__ks_i];
				if(first === void 0 || first === null) {
					throw new TypeError("'first' is not nullable");
				}
				var last = arguments[++__ks_i];
				if(last === void 0 || last === null) {
					throw new TypeError("'last' is not nullable");
				}
				var node = location({
					kind: NodeKind.Parameter,
					modifiers: modifiers
				}, first, last);
				if(name !== null) {
					node.name = name.value;
				}
				if(type !== null) {
					node.type = type.value;
				}
				if(defaultValue !== null) {
					node.defaultValue = defaultValue.value;
				}
				return node;
			}
			else {
				throw new SyntaxError("wrong number of arguments");
			}
		};
		function RegularExpression(value, first) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(value === void 0 || value === null) {
				throw new TypeError("'value' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			return location({
				kind: NodeKind.RegularExpression,
				value: value
			}, first);
		}
		function RequireDeclaration(declarations, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(declarations === void 0 || declarations === null) {
				throw new TypeError("'declarations' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.RequireDeclaration,
				declarations: Helper.mapArray(declarations, function(declarator) {
					return declarator.value;
				})
			}, first, last);
		}
		function RequireOrExternDeclaration(declarations, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(declarations === void 0 || declarations === null) {
				throw new TypeError("'declarations' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.RequireOrExternDeclaration,
				declarations: Helper.mapArray(declarations, function(declarator) {
					return declarator.value;
				})
			}, first, last);
		}
		function RequireOrImportDeclaration(declarations, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(declarations === void 0 || declarations === null) {
				throw new TypeError("'declarations' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.RequireOrImportDeclaration,
				declarations: Helper.mapArray(declarations, function(declaration) {
					return declaration.value;
				})
			}, first, last);
		}
		function RestModifier(min, max, first, last) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(min === void 0 || min === null) {
				throw new TypeError("'min' is not nullable");
			}
			if(max === void 0 || max === null) {
				throw new TypeError("'max' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: ModifierKind.Rest,
				arity: {
					min: min,
					max: max
				}
			}, first, last);
		}
		function ReturnStatement() {
			if(arguments.length === 1) {
				var __ks_i = -1;
				var first = arguments[++__ks_i];
				if(first === void 0 || first === null) {
					throw new TypeError("'first' is not nullable");
				}
				return location({
					kind: NodeKind.ReturnStatement
				}, first, first);
			}
			else if(arguments.length === 3) {
				var __ks_i = -1;
				var value = arguments[++__ks_i];
				if(value === void 0 || value === null) {
					throw new TypeError("'value' is not nullable");
				}
				var first = arguments[++__ks_i];
				if(first === void 0 || first === null) {
					throw new TypeError("'first' is not nullable");
				}
				var last = arguments[++__ks_i];
				if(last === void 0 || last === null) {
					throw new TypeError("'last' is not nullable");
				}
				return location({
					kind: NodeKind.ReturnStatement,
					value: value.value
				}, first, last);
			}
			else {
				throw new SyntaxError("wrong number of arguments");
			}
		};
		function Scope() {
			if(arguments.length === 1) {
				var __ks_i = -1;
				var scope = arguments[++__ks_i];
				if(scope === void 0 || scope === null) {
					throw new TypeError("'scope' is not nullable");
				}
				else if(!Type.is(scope, ScopeKind)) {
					throw new TypeError("'scope' is not of type 'ScopeKind'");
				}
				return {
					kind: scope
				};
			}
			else if(arguments.length === 2) {
				var __ks_i = -1;
				var scope = arguments[++__ks_i];
				if(scope === void 0 || scope === null) {
					throw new TypeError("'scope' is not nullable");
				}
				else if(!Type.is(scope, ScopeKind)) {
					throw new TypeError("'scope' is not of type 'ScopeKind'");
				}
				var value = arguments[++__ks_i];
				if(value === void 0 || value === null) {
					throw new TypeError("'value' is not nullable");
				}
				return {
					kind: scope,
					value: value.value
				};
			}
			else {
				throw new SyntaxError("wrong number of arguments");
			}
		};
		function SequenceExpression(expressions, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(expressions === void 0 || expressions === null) {
				throw new TypeError("'expressions' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.SequenceExpression,
				expressions: Helper.mapArray(expressions, function(expression) {
					return expression.value;
				})
			}, first, last);
		}
		function SwitchClause(conditions, bindings, filter, body, first, last) {
			if(arguments.length < 6) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 6)");
			}
			if(conditions === void 0) {
				conditions = null;
			}
			if(bindings === void 0) {
				bindings = null;
			}
			if(filter === void 0) {
				filter = null;
			}
			if(body === void 0 || body === null) {
				throw new TypeError("'body' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			var node = location({
				kind: NodeKind.SwitchClause,
				body: body.value
			}, first, last);
			if(conditions === null) {
				node.conditions = [];
			}
			else {
				node.conditions = Helper.mapArray(conditions, function(condition) {
					return condition.value;
				});
			}
			if(bindings === null) {
				node.bindings = [];
			}
			else {
				node.bindings = Helper.mapArray(bindings.value, function(binding) {
					return binding.value;
				});
			}
			if(filter !== null) {
				node.filter = filter.value;
			}
			return node;
		}
		function SwitchConditionArray(values, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(values === void 0 || values === null) {
				throw new TypeError("'values' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.SwitchConditionArray,
				values: Helper.mapArray(values, function(value) {
					return value.value;
				})
			}, first, last);
		}
		function SwitchConditionObject(members, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(members === void 0 || members === null) {
				throw new TypeError("'members' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.SwitchConditionObject,
				members: Helper.mapArray(members, function(member) {
					return member.value;
				})
			}, first, last);
		}
		function SwitchConditionRangeFO(from, to) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(from === void 0 || from === null) {
				throw new TypeError("'from' is not nullable");
			}
			if(to === void 0 || to === null) {
				throw new TypeError("'to' is not nullable");
			}
			return location({
				kind: NodeKind.SwitchConditionRange,
				from: from.value,
				to: to.value
			}, from, to);
		}
		function SwitchConditionType(type, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(type === void 0 || type === null) {
				throw new TypeError("'type' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.SwitchConditionType,
				type: type.value
			}, first, last);
		}
		function SwitchExpression(expression, clauses, first, last) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(expression === void 0 || expression === null) {
				throw new TypeError("'expression' is not nullable");
			}
			if(clauses === void 0 || clauses === null) {
				throw new TypeError("'clauses' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.SwitchExpression,
				expression: expression.value,
				clauses: Helper.mapArray(clauses.value, function(clause) {
					return clause;
				})
			}, first, last);
		}
		function SwitchStatement(expression, clauses, first, last) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(expression === void 0 || expression === null) {
				throw new TypeError("'expression' is not nullable");
			}
			if(clauses === void 0 || clauses === null) {
				throw new TypeError("'clauses' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.SwitchStatement,
				expression: expression.value,
				clauses: Helper.mapArray(clauses.value, function(clause) {
					return clause;
				})
			}, first, last);
		}
		function SwitchTypeCasting(name, type) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(name === void 0 || name === null) {
				throw new TypeError("'name' is not nullable");
			}
			if(type === void 0 || type === null) {
				throw new TypeError("'type' is not nullable");
			}
			return location({
				kind: NodeKind.SwitchTypeCasting,
				name: name.value,
				type: type.value
			}, name, type);
		}
		function TemplateExpression(elements, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(elements === void 0 || elements === null) {
				throw new TypeError("'elements' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.TemplateExpression,
				elements: Helper.mapArray(elements, function(element) {
					return element.value;
				})
			}, first, last);
		}
		function ThisExpression(name, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(name === void 0 || name === null) {
				throw new TypeError("'name' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.ThisExpression,
				name: name.value
			}, first, last);
		}
		function ThrowStatement() {
			if(arguments.length === 1) {
				var __ks_i = -1;
				var first = arguments[++__ks_i];
				if(first === void 0 || first === null) {
					throw new TypeError("'first' is not nullable");
				}
				return location({
					kind: NodeKind.ThrowStatement
				}, first);
			}
			else if(arguments.length === 3) {
				var __ks_i = -1;
				var value = arguments[++__ks_i];
				if(value === void 0 || value === null) {
					throw new TypeError("'value' is not nullable");
				}
				var first = arguments[++__ks_i];
				if(first === void 0 || first === null) {
					throw new TypeError("'first' is not nullable");
				}
				var last = arguments[++__ks_i];
				if(last === void 0 || last === null) {
					throw new TypeError("'last' is not nullable");
				}
				return location({
					kind: NodeKind.ThrowStatement,
					value: value.value
				}, first, last);
			}
			else {
				throw new SyntaxError("wrong number of arguments");
			}
		};
		function TryStatement(body, catchClauses, catchClause, finalizer, first, last) {
			if(arguments.length < 6) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 6)");
			}
			if(body === void 0 || body === null) {
				throw new TypeError("'body' is not nullable");
			}
			if(catchClauses === void 0 || catchClauses === null) {
				throw new TypeError("'catchClauses' is not nullable");
			}
			if(catchClause === void 0) {
				catchClause = null;
			}
			if(finalizer === void 0) {
				finalizer = null;
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			var node = location({
				kind: NodeKind.TryStatement,
				body: body.value,
				catchClauses: Helper.mapArray(catchClauses, function(clause) {
					return clause.value;
				})
			}, first, last);
			if(catchClause !== null) {
				node.catchClause = catchClause.value;
			}
			if(finalizer !== null) {
				node.finalizer = finalizer.value;
			}
			return node;
		}
		function TypeReference() {
			if(arguments.length === 1) {
				var __ks_i = -1;
				var name = arguments[++__ks_i];
				if(name === void 0 || name === null) {
					throw new TypeError("'name' is not nullable");
				}
				return location({
					kind: NodeKind.TypeReference,
					typeName: name.value
				}, name);
			}
			else if(arguments.length === 5) {
				var __ks_i = -1;
				var name = arguments[++__ks_i];
				if(name === void 0 || name === null) {
					throw new TypeError("'name' is not nullable");
				}
				var parameters = arguments[++__ks_i];
				if(parameters === void 0) {
					parameters = null;
				}
				var nullable = arguments[++__ks_i];
				if(nullable === void 0) {
					nullable = null;
				}
				var first = arguments[++__ks_i];
				if(first === void 0 || first === null) {
					throw new TypeError("'first' is not nullable");
				}
				var last = arguments[++__ks_i];
				if(last === void 0 || last === null) {
					throw new TypeError("'last' is not nullable");
				}
				var node;
				if(parameters === null) {
					node = location({
						kind: NodeKind.TypeReference,
						typeName: name.value
					}, first, last);
				}
				else {
					node = location({
						kind: NodeKind.TypeReference,
						typeName: name.value,
						typeParameters: Helper.mapArray(parameters.value, function(parameter) {
							return parameter.value;
						})
					}, first, last);
				}
				if(Type.isValue(nullable) ? nullable.ok : false) {
					node.nullable = true;
				}
				return node;
			}
			else {
				throw new SyntaxError("wrong number of arguments");
			}
		};
		function TypeAliasDeclaration(name, type, first, last) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(name === void 0 || name === null) {
				throw new TypeError("'name' is not nullable");
			}
			if(type === void 0 || type === null) {
				throw new TypeError("'type' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.TypeAliasDeclaration,
				name: name.value,
				type: type.value
			}, first, last);
		}
		function UnaryExpression(operator, operand, first, last) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(operator === void 0 || operator === null) {
				throw new TypeError("'operator' is not nullable");
			}
			if(operand === void 0 || operand === null) {
				throw new TypeError("'operand' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.UnaryExpression,
				operator: operator.value,
				argument: operand.value
			}, first, last);
		}
		function UnaryOperator(operator, first) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(operator === void 0 || operator === null) {
				throw new TypeError("'operator' is not nullable");
			}
			else if(!Type.is(operator, UnaryOperatorKind)) {
				throw new TypeError("'operator' is not of type 'UnaryOperatorKind'");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			return location({
				kind: operator
			}, first);
		}
		function UnionType(types, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(types === void 0 || types === null) {
				throw new TypeError("'types' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.UnionType,
				types: Helper.mapArray(types, function(type) {
					return type.value;
				})
			}, first, last);
		}
		function UnlessExpression(condition, whenFalse, first, last) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(condition === void 0 || condition === null) {
				throw new TypeError("'condition' is not nullable");
			}
			if(whenFalse === void 0 || whenFalse === null) {
				throw new TypeError("'whenFalse' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.UnlessExpression,
				condition: condition.value,
				whenFalse: whenFalse.value
			}, first, last);
		}
		function UnlessStatement(condition, whenFalse, first, last) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(condition === void 0 || condition === null) {
				throw new TypeError("'condition' is not nullable");
			}
			if(whenFalse === void 0 || whenFalse === null) {
				throw new TypeError("'whenFalse' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.UnlessStatement,
				condition: condition.value,
				whenFalse: whenFalse.value
			}, first, last);
		}
		function UntilStatement(condition, body, first, last) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(condition === void 0 || condition === null) {
				throw new TypeError("'condition' is not nullable");
			}
			if(body === void 0 || body === null) {
				throw new TypeError("'body' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.UntilStatement,
				condition: condition.value,
				body: body.value
			}, first, last);
		}
		function VariableDeclaration() {
			if(arguments.length === 4) {
				var __ks_i = -1;
				var variables = arguments[++__ks_i];
				if(variables === void 0 || variables === null) {
					throw new TypeError("'variables' is not nullable");
				}
				var rebindable = arguments[++__ks_i];
				if(rebindable === void 0 || rebindable === null) {
					throw new TypeError("'rebindable' is not nullable");
				}
				var first = arguments[++__ks_i];
				if(first === void 0 || first === null) {
					throw new TypeError("'first' is not nullable");
				}
				var last = arguments[++__ks_i];
				if(last === void 0 || last === null) {
					throw new TypeError("'last' is not nullable");
				}
				return location({
					kind: NodeKind.VariableDeclaration,
					rebindable: rebindable,
					variables: Helper.mapArray(variables, function(variable) {
						return variable.value;
					})
				}, first, last);
			}
			else if(arguments.length === 7) {
				var __ks_i = -1;
				var variables = arguments[++__ks_i];
				if(variables === void 0 || variables === null) {
					throw new TypeError("'variables' is not nullable");
				}
				var rebindable = arguments[++__ks_i];
				if(rebindable === void 0 || rebindable === null) {
					throw new TypeError("'rebindable' is not nullable");
				}
				var equals = arguments[++__ks_i];
				if(equals === void 0 || equals === null) {
					throw new TypeError("'equals' is not nullable");
				}
				var isAwait = arguments[++__ks_i];
				if(isAwait === void 0 || isAwait === null) {
					throw new TypeError("'isAwait' is not nullable");
				}
				var expression = arguments[++__ks_i];
				if(expression === void 0 || expression === null) {
					throw new TypeError("'expression' is not nullable");
				}
				var first = arguments[++__ks_i];
				if(first === void 0 || first === null) {
					throw new TypeError("'first' is not nullable");
				}
				var last = arguments[++__ks_i];
				if(last === void 0 || last === null) {
					throw new TypeError("'last' is not nullable");
				}
				return location({
					kind: NodeKind.VariableDeclaration,
					rebindable: rebindable,
					variables: Helper.mapArray(variables, function(variable) {
						return variable.value;
					}),
					autotype: equals.value,
					await: isAwait,
					init: expression.value
				}, first, last);
			}
			else {
				throw new SyntaxError("wrong number of arguments");
			}
		};
		function VariableDeclarator() {
			if(arguments.length === 1) {
				var __ks_i = -1;
				var name = arguments[++__ks_i];
				if(name === void 0 || name === null) {
					throw new TypeError("'name' is not nullable");
				}
				return location({
					kind: NodeKind.VariableDeclarator,
					name: name.value
				}, name);
			}
			else if(arguments.length === 2) {
				var __ks_i = -1;
				var name = arguments[++__ks_i];
				if(name === void 0 || name === null) {
					throw new TypeError("'name' is not nullable");
				}
				var type = arguments[++__ks_i];
				if(type === void 0 || type === null) {
					throw new TypeError("'type' is not nullable");
				}
				return location({
					kind: NodeKind.VariableDeclarator,
					name: name.value,
					type: type.value
				}, name, type);
			}
			else if(arguments.length === 5) {
				var __ks_i = -1;
				var name = arguments[++__ks_i];
				if(name === void 0 || name === null) {
					throw new TypeError("'name' is not nullable");
				}
				var type = arguments[++__ks_i];
				if(type === void 0) {
					type = null;
				}
				var __ks_sealed_1 = arguments[++__ks_i];
				if(__ks_sealed_1 === void 0 || __ks_sealed_1 === null) {
					throw new TypeError("'sealed' is not nullable");
				}
				var first = arguments[++__ks_i];
				if(first === void 0 || first === null) {
					throw new TypeError("'first' is not nullable");
				}
				var last = arguments[++__ks_i];
				if(last === void 0 || last === null) {
					throw new TypeError("'last' is not nullable");
				}
				var node = location({
					kind: NodeKind.VariableDeclarator,
					name: name.value,
					sealed: __ks_sealed_1
				}, first, last);
				if(type !== null) {
					node.type = type.value;
				}
				return node;
			}
			else {
				throw new SyntaxError("wrong number of arguments");
			}
		};
		function WhileStatement(condition, body, first, last) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(condition === void 0 || condition === null) {
				throw new TypeError("'condition' is not nullable");
			}
			if(body === void 0 || body === null) {
				throw new TypeError("'body' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return location({
				kind: NodeKind.WhileStatement,
				condition: condition.value,
				body: body.value
			}, first, last);
		}
		return {
			reorderExpression: reorderExpression,
			AccessorDeclaration: AccessorDeclaration,
			AccessorDeclaration: AccessorDeclaration,
			ArrayBinding: ArrayBinding,
			ArrayComprehension: ArrayComprehension,
			ArrayExpression: ArrayExpression,
			ArrayRangeFI: ArrayRangeFI,
			ArrayRangeFO: ArrayRangeFO,
			ArrayRangeTI: ArrayRangeTI,
			ArrayRangeTO: ArrayRangeTO,
			AssignmentOperator: AssignmentOperator,
			AttributeDeclaration: AttributeDeclaration,
			AttributeExpression: AttributeExpression,
			AttributeOperation: AttributeOperation,
			AwaitExpression: AwaitExpression,
			BinaryExpression: BinaryExpression,
			BinaryExpression: BinaryExpression,
			BinaryOperator: BinaryOperator,
			BindingElement: BindingElement,
			BindingElement: BindingElement,
			Block: Block,
			BreakStatement: BreakStatement,
			CallExpression: CallExpression,
			CallExpression: CallExpression,
			CallMacroExpression: CallMacroExpression,
			CatchClause: CatchClause,
			ClassDeclaration: ClassDeclaration,
			ConditionalExpression: ConditionalExpression,
			ContinueStatement: ContinueStatement,
			CreateExpression: CreateExpression,
			CurryExpression: CurryExpression,
			DestroyStatement: DestroyStatement,
			DoUntilStatement: DoUntilStatement,
			DoWhileStatement: DoWhileStatement,
			EnumExpression: EnumExpression,
			EnumDeclaration: EnumDeclaration,
			EnumMember: EnumMember,
			EnumMember: EnumMember,
			ExportDeclaration: ExportDeclaration,
			ExportDeclarationSpecifier: ExportDeclarationSpecifier,
			ExportNamedSpecifier: ExportNamedSpecifier,
			ExportPropertiesSpecifier: ExportPropertiesSpecifier,
			ExportWildcardSpecifier: ExportWildcardSpecifier,
			ExternDeclaration: ExternDeclaration,
			ExternOrRequireDeclaration: ExternOrRequireDeclaration,
			FieldDeclaration: FieldDeclaration,
			ForFromStatement: ForFromStatement,
			ForInStatement: ForInStatement,
			ForRangeStatement: ForRangeStatement,
			ForOfStatement: ForOfStatement,
			FunctionDeclaration: FunctionDeclaration,
			FunctionExpression: FunctionExpression,
			IfExpression: IfExpression,
			IfStatement: IfStatement,
			ImplementDeclaration: ImplementDeclaration,
			ImportDeclaration: ImportDeclaration,
			ImportDeclarator: ImportDeclarator,
			ImportNamespaceSpecifier: ImportNamespaceSpecifier,
			ImportSpecifier: ImportSpecifier,
			Identifier: Identifier,
			IncludeAgainDeclaration: IncludeAgainDeclaration,
			IncludeDeclaration: IncludeDeclaration,
			LambdaExpression: LambdaExpression,
			Literal: Literal,
			MacroDeclaration: MacroDeclaration,
			MacroExpression: MacroExpression,
			MacroElementExpression: MacroElementExpression,
			MacroElementLiteral: MacroElementLiteral,
			MacroElementNewLine: MacroElementNewLine,
			MacroReification: MacroReification,
			MemberExpression: MemberExpression,
			MethodDeclaration: MethodDeclaration,
			Modifier: Modifier,
			Module: Module,
			MutatorDeclaration: MutatorDeclaration,
			MutatorDeclaration: MutatorDeclaration,
			NamedArgument: NamedArgument,
			Nullable: Nullable,
			NamespaceDeclaration: NamespaceDeclaration,
			NumericExpression: NumericExpression,
			ObjectBinding: ObjectBinding,
			ObjectExpression: ObjectExpression,
			ObjectMember: ObjectMember,
			ObjectMember: ObjectMember,
			ObjectMember: ObjectMember,
			ObjectReference: ObjectReference,
			ObjectMemberReference: ObjectMemberReference,
			OmittedExpression: OmittedExpression,
			PropertyDeclaration: PropertyDeclaration,
			Parameter: Parameter,
			Parameter: Parameter,
			RegularExpression: RegularExpression,
			RequireDeclaration: RequireDeclaration,
			RequireOrExternDeclaration: RequireOrExternDeclaration,
			RequireOrImportDeclaration: RequireOrImportDeclaration,
			RestModifier: RestModifier,
			ReturnStatement: ReturnStatement,
			ReturnStatement: ReturnStatement,
			Scope: Scope,
			Scope: Scope,
			SequenceExpression: SequenceExpression,
			SwitchClause: SwitchClause,
			SwitchConditionArray: SwitchConditionArray,
			SwitchConditionObject: SwitchConditionObject,
			SwitchConditionRangeFO: SwitchConditionRangeFO,
			SwitchConditionType: SwitchConditionType,
			SwitchExpression: SwitchExpression,
			SwitchStatement: SwitchStatement,
			SwitchTypeCasting: SwitchTypeCasting,
			TemplateExpression: TemplateExpression,
			ThisExpression: ThisExpression,
			ThrowStatement: ThrowStatement,
			ThrowStatement: ThrowStatement,
			TryStatement: TryStatement,
			TypeReference: TypeReference,
			TypeReference: TypeReference,
			TypeAliasDeclaration: TypeAliasDeclaration,
			UnaryExpression: UnaryExpression,
			UnaryOperator: UnaryOperator,
			UnionType: UnionType,
			UnlessExpression: UnlessExpression,
			UnlessStatement: UnlessStatement,
			UntilStatement: UntilStatement,
			VariableDeclaration: VariableDeclaration,
			VariableDeclaration: VariableDeclaration,
			VariableDeclarator: VariableDeclarator,
			VariableDeclarator: VariableDeclarator,
			VariableDeclarator: VariableDeclarator,
			WhileStatement: WhileStatement
		};
	})();
	var Token = {
		INVALID: 0,
		ABSTRACT: 1,
		AMPERSAND: 2,
		AMPERSAND_AMPERSAND: 3,
		AMPERSAND_EQUALS: 4,
		AS: 5,
		ASTERISK: 6,
		ASTERISK_ASTERISK_LEFT_ROUND: 7,
		ASTERISK_DOLLAR_LEFT_ROUND: 8,
		ASTERISK_EQUALS: 9,
		ASYNC: 10,
		AT: 11,
		AWAIT: 12,
		BINARY_NUMBER: 13,
		BREAK: 14,
		BY: 15,
		CARET: 16,
		CARET_AT_LEFT_ROUND: 17,
		CARET_CARET_LEFT_ROUND: 18,
		CARET_DOLLAR_LEFT_ROUND: 19,
		CARET_EQUALS: 20,
		CATCH: 21,
		CLASS: 22,
		CLASS_VERSION: 23,
		COLON: 24,
		COLON_COLON: 25,
		COLON_EQUALS: 26,
		COMMA: 27,
		CONST: 28,
		CONTINUE: 29,
		DECIMAL_NUMBER: 30,
		DELETE: 31,
		DESC: 32,
		DO: 33,
		DOT: 34,
		DOT_DOT: 35,
		DOT_DOT_DOT: 36,
		ELSE: 37,
		ELSE_IF: 38,
		ENUM: 39,
		EOF: 40,
		EQUALS: 41,
		EQUALS_EQUALS: 42,
		EQUALS_RIGHT_ANGLE: 43,
		EXCLAMATION: 44,
		EXCLAMATION_EQUALS: 45,
		EXCLAMATION_LEFT_ROUND: 46,
		EXCLAMATION_QUESTION_EQUALS: 47,
		EXPORT: 48,
		EXTENDS: 49,
		EXTERN: 50,
		EXTERN_REQUIRE: 51,
		FINALLY: 52,
		FOR: 53,
		FROM: 54,
		FUNC: 55,
		GET: 56,
		HASH: 57,
		HASH_EXCLAMATION_LEFT_SQUARE: 58,
		HASH_LEFT_SQUARE: 59,
		HEX_NUMBER: 60,
		IDENTIFIER: 61,
		IF: 62,
		IMPL: 63,
		IMPORT: 64,
		IMPORT_LITERAL: 65,
		IN: 66,
		INCLUDE: 67,
		INCLUDE_AGAIN: 68,
		IS: 69,
		IS_NOT: 70,
		LEFT_ANGLE: 71,
		LEFT_ANGLE_EQUALS: 72,
		LEFT_ANGLE_LEFT_ANGLE: 73,
		LEFT_ANGLE_LEFT_ANGLE_EQUALS: 74,
		LEFT_CURLY: 75,
		LEFT_ROUND: 76,
		LEFT_SQUARE: 77,
		LET: 78,
		MACRO: 79,
		MINUS: 80,
		MINUS_EQUALS: 81,
		MINUS_MINUS: 82,
		NAMESPACE: 83,
		NEW: 84,
		NEWLINE: 85,
		OCTAL_NUMBER: 86,
		OF: 87,
		ON: 88,
		PERCENT: 89,
		PERCENT_EQUALS: 90,
		PIPE: 91,
		PIPE_EQUALS: 92,
		PIPE_PIPE: 93,
		PLUS: 94,
		PLUS_EQUALS: 95,
		PLUS_PLUS: 96,
		PRIVATE: 97,
		PROTECTED: 98,
		PUBLIC: 99,
		QUESTION: 100,
		QUESTION_EQUALS: 101,
		QUESTION_DOT: 102,
		QUESTION_LEFT_ROUND: 103,
		QUESTION_LEFT_SQUARE: 104,
		QUESTION_QUESTION: 105,
		QUESTION_QUESTION_EQUALS: 106,
		RADIX_NUMBER: 107,
		REGEXP: 108,
		REQUIRE: 109,
		REQUIRE_EXTERN: 110,
		REQUIRE_IMPORT: 111,
		RETURN: 112,
		RIGHT_ANGLE: 113,
		RIGHT_ANGLE_EQUALS: 114,
		RIGHT_ANGLE_RIGHT_ANGLE: 115,
		RIGHT_ANGLE_RIGHT_ANGLE_EQUALS: 116,
		RIGHT_CURLY: 117,
		RIGHT_ROUND: 118,
		RIGHT_SQUARE: 119,
		SEALED: 120,
		SET: 121,
		SLASH: 122,
		SLASH_EQUALS: 123,
		STATIC: 124,
		STRING: 125,
		SWITCH: 126,
		TEMPLATE_BEGIN: 127,
		TEMPLATE_ELEMENT: 128,
		TEMPLATE_END: 129,
		TEMPLATE_VALUE: 130,
		THROW: 131,
		TIL: 132,
		TILDE: 133,
		TO: 134,
		TRY: 135,
		TYPE: 136,
		UNLESS: 137,
		UNTIL: 138,
		WHEN: 139,
		WHERE: 140,
		WHILE: 141,
		WITH: 142
	};
	var overhauls = {};
	overhauls[Token.CLASS_VERSION] = function(data) {
		if(arguments.length < 1) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		return data.split(".");
	};
	overhauls[Token.STRING] = function(data) {
		if(arguments.length < 1) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		return data.slice(1, -1).replace(/(^|[^\\])\\('|")/g, "$1$2");
	};
	var regex = {
		binary_number: /^0b[_0-1]+[a-zA-Z]*/,
		class_version: /^\d+(\.\d+(\.\d+)?)?/,
		decimal_number: /^[0-9][_0-9]*(?:\.[_0-9]+)?[a-zA-Z]*/,
		double_quote: /^([^\\"]|\\.)*\"/,
		hex_number: /^0x[_0-9a-fA-F]+[a-zA-Z]*/,
		macro_value: /^[^#\r\n]+/,
		octal_number: /^0o[_0-8]+[a-zA-Z]*/,
		radix_number: /^(?:[0-9]|[1-2][0-9]|3[0-6])r[_0-9a-zA-Z]+/,
		regex: /^=?(?:[^\n\r\*\\\/\[]|\\[^\n\r]|\[(?:[^\n\r\]\\]|\\[^\n\r])*\])(?:[^\n\r\\\/\[]|\\[^\n\r]|\[(?:[^\n\r\]\\]|\\[^\n\r])*\])*\/[gmi]*/,
		resource: /(^\s*\r?\n\s*)|(^\})|(^\s*\/\/[^\r\n]*\r?\n\s*)|(^\s*\/\*)|(^\S+)/,
		single_quote: /^([^\\']|\\.)*\'/,
		template: /^(?:[^`\\]|\\(?!\())+/
	};
	var M = (function() {
		function BINARY_OPERATOR(that, index) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(that === void 0 || that === null) {
				throw new TypeError("'that' is not nullable");
			}
			if(index === void 0 || index === null) {
				throw new TypeError("'index' is not nullable");
			}
			var c = that.skip(index);
			if(c === -1) {
				return Token.EOF;
			}
			else if(c === 33) {
				c = that.charAt(1);
				if(c === 61) {
					that.next(2);
					return Token.EXCLAMATION_EQUALS;
				}
				else if((c === 63) && (that.charAt(2) === 61)) {
					that.next(3);
					return Token.EXCLAMATION_QUESTION_EQUALS;
				}
			}
			else if(c === 37) {
				if(that.charAt(1) === 61) {
					that.next(2);
					return Token.PERCENT_EQUALS;
				}
				else {
					that.next(1);
					return Token.PERCENT;
				}
			}
			else if(c === 38) {
				c = that.charAt(1);
				if(c === 38) {
					that.next(2);
					return Token.AMPERSAND_AMPERSAND;
				}
				else if(c === 61) {
					that.next(2);
					return Token.AMPERSAND_EQUALS;
				}
				else {
					that.next(1);
					return Token.AMPERSAND;
				}
			}
			else if(c === 42) {
				if(that.charAt(1) === 61) {
					that.next(2);
					return Token.ASTERISK_EQUALS;
				}
				else {
					that.next(1);
					return Token.ASTERISK;
				}
			}
			else if(c === 43) {
				c = that.charAt(1);
				if(c === 61) {
					that.next(2);
					return Token.PLUS_EQUALS;
				}
				else if(c !== 43) {
					that.next(1);
					return Token.PLUS;
				}
			}
			else if(c === 45) {
				c = that.charAt(1);
				if(c === 61) {
					that.next(2);
					return Token.MINUS_EQUALS;
				}
				else if(c !== 45) {
					that.next(1);
					return Token.MINUS;
				}
			}
			else if(c === 47) {
				if(that.charAt(1) === 61) {
					that.next(2);
					return Token.SLASH_EQUALS;
				}
				else {
					that.next(1);
					return Token.SLASH;
				}
			}
			else if(c === 60) {
				c = that.charAt(1);
				if(c === 60) {
					if(that.charAt(2) === 61) {
						that.next(3);
						return Token.LEFT_ANGLE_LEFT_ANGLE_EQUALS;
					}
					else {
						that.next(2);
						return Token.LEFT_ANGLE_LEFT_ANGLE;
					}
				}
				else if(c === 61) {
					that.next(2);
					return Token.LEFT_ANGLE_EQUALS;
				}
				else {
					that.next(1);
					return Token.LEFT_ANGLE;
				}
			}
			else if(c === 61) {
				c = that.charAt(1);
				if(c === 61) {
					that.next(2);
					return Token.EQUALS_EQUALS;
				}
				else if(c !== 62) {
					that.next(1);
					return Token.EQUALS;
				}
			}
			else if(c === 62) {
				c = that.charAt(1);
				if(c === 61) {
					that.next(2);
					return Token.RIGHT_ANGLE_EQUALS;
				}
				else if(c === 62) {
					if(that.charAt(2) === 61) {
						that.next(3);
						return Token.RIGHT_ANGLE_RIGHT_ANGLE_EQUALS;
					}
					else {
						that.next(2);
						return Token.RIGHT_ANGLE_RIGHT_ANGLE;
					}
				}
				else {
					that.next(1);
					return Token.RIGHT_ANGLE;
				}
			}
			else if(c === 63) {
				c = that.charAt(1);
				if(c === 61) {
					that.next(2);
					return Token.QUESTION_EQUALS;
				}
				else if(c === 63) {
					if(that.charAt(2) === 61) {
						that.next(3);
						return Token.QUESTION_QUESTION_EQUALS;
					}
					else {
						that.next(2);
						return Token.QUESTION_QUESTION;
					}
				}
			}
			else if(c === 94) {
				c = that.charAt(1);
				if(c === 61) {
					that.next(2);
					return Token.CARET_EQUALS;
				}
				else {
					that.next(1);
					return Token.CARET;
				}
			}
			else if(c === 124) {
				c = that.charAt(1);
				if(c === 61) {
					that.next(2);
					return Token.PIPE_EQUALS;
				}
				else if(c === 124) {
					that.next(2);
					return Token.PIPE_PIPE;
				}
				else {
					that.next(1);
					return Token.PIPE;
				}
			}
			return Token.INVALID;
		}
		function EXPORT_STATEMENT(that, index) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(that === void 0 || that === null) {
				throw new TypeError("'that' is not nullable");
			}
			if(index === void 0 || index === null) {
				throw new TypeError("'index' is not nullable");
			}
			var c = that.skip(index);
			if(c === -1) {
				return Token.EOF;
			}
			else if(c === 97) {
				var identifier = that.scanIdentifier(true);
				if(identifier === "bstract") {
					return Token.ABSTRACT;
				}
				else {
					return Token.IDENTIFIER;
				}
			}
			else if(c === 99) {
				var identifier = that.scanIdentifier(true);
				if(identifier === "lass") {
					return Token.CLASS;
				}
				else if(identifier === "onst") {
					return Token.CONST;
				}
				else {
					return Token.IDENTIFIER;
				}
			}
			else if(c === 101) {
				if(that.scanIdentifier(true) === "num") {
					return Token.ENUM;
				}
				else {
					return Token.IDENTIFIER;
				}
			}
			else if(c === 102) {
				if(that.scanIdentifier(true) === "unc") {
					return Token.FUNC;
				}
				else {
					return Token.IDENTIFIER;
				}
			}
			else if(c === 108) {
				if(that.scanIdentifier(true) === "et") {
					return Token.LET;
				}
				else {
					return Token.IDENTIFIER;
				}
			}
			else if(c === 110) {
				if(that.scanIdentifier(true) === "amespace") {
					return Token.NAMESPACE;
				}
				else {
					return Token.IDENTIFIER;
				}
			}
			else if(c === 115) {
				var identifier = that.scanIdentifier(true);
				if(identifier === "ealed") {
					return Token.SEALED;
				}
				else {
					return Token.IDENTIFIER;
				}
			}
			else if(c === 116) {
				if(that.scanIdentifier(true) === "ype") {
					return Token.TYPE;
				}
				else {
					return Token.IDENTIFIER;
				}
			}
			else if((c === 36) || (c === 95) || ((c >= 65) && (c <= 90)) || ((c >= 97) && (c <= 122))) {
				that.scanIdentifier(false);
				return Token.IDENTIFIER;
			}
			return Token.INVALID;
		}
		function EXTERN_STATEMENT(that, index) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(that === void 0 || that === null) {
				throw new TypeError("'that' is not nullable");
			}
			if(index === void 0 || index === null) {
				throw new TypeError("'index' is not nullable");
			}
			var c = that.skip(index);
			if(c === -1) {
				return Token.EOF;
			}
			else if(c === 97) {
				if(that.scanIdentifier(true) === "bstract") {
					return Token.ABSTRACT;
				}
				else {
					return Token.IDENTIFIER;
				}
			}
			else if(c === 99) {
				var identifier = that.scanIdentifier(true);
				if(identifier === "lass") {
					return Token.CLASS;
				}
				else if(identifier === "onst") {
					return Token.CONST;
				}
				else {
					return Token.IDENTIFIER;
				}
			}
			else if(c === 101) {
				if((that.charAt(1) === 110) && (that.charAt(2) === 117) && (that.charAt(3) === 109) && that.isBoundary(4)) {
					that.next(4);
					return Token.ENUM;
				}
			}
			else if(c === 102) {
				if(that.scanIdentifier(true) === "unc") {
					return Token.FUNC;
				}
				else {
					return Token.IDENTIFIER;
				}
			}
			else if(c === 108) {
				if(that.scanIdentifier(true) === "et") {
					return Token.LET;
				}
				else {
					return Token.IDENTIFIER;
				}
			}
			else if(c === 110) {
				if(that.scanIdentifier(true) === "amespace") {
					return Token.NAMESPACE;
				}
				else {
					return Token.IDENTIFIER;
				}
			}
			else if(c === 115) {
				if(that.scanIdentifier(true) === "ealed") {
					return Token.SEALED;
				}
				else {
					return Token.IDENTIFIER;
				}
			}
			else if((c === 36) || (c === 95) || ((c >= 65) && (c <= 90)) || ((c >= 97) && (c <= 122))) {
				that.scanIdentifier(false);
				return Token.IDENTIFIER;
			}
			return Token.INVALID;
		}
		function MACRO(that, index) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(that === void 0 || that === null) {
				throw new TypeError("'that' is not nullable");
			}
			if(index === void 0 || index === null) {
				throw new TypeError("'index' is not nullable");
			}
			var c = that._data.charCodeAt(++index);
			if((c === 13) && (that.charAt(1) === 10)) {
				that.nextLine(2);
				return Token.NEWLINE;
			}
			else if((c === 10) || (c === 13)) {
				that.nextLine(1);
				return Token.NEWLINE;
			}
			else if(c === 35) {
				that.next(1);
				return Token.HASH;
			}
			else if(c === 40) {
				that.next(1);
				return Token.LEFT_ROUND;
			}
			else if(c === 41) {
				that.next(1);
				return Token.RIGHT_ROUND;
			}
			else if(c === 123) {
				that.next(1);
				return Token.LEFT_CURLY;
			}
			else if(c === 125) {
				that.next(1);
				return Token.RIGHT_CURLY;
			}
			var from = index;
			while(++index < that._length) {
				c = that._data.charCodeAt(index);
				if((c === 10) || (c === 13) || (c === 35) || (c === 40) || (c === 41) || (c === 123) || (c === 125)) {
					that.next(index - from);
					return Token.INVALID;
				}
			}
			if(index === (from + 1)) {
				return Token.EOF;
			}
			else {
				that.next(index - from);
				return Token.INVALID;
			}
		}
		function MODULE_STATEMENT(that, index) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(that === void 0 || that === null) {
				throw new TypeError("'that' is not nullable");
			}
			if(index === void 0 || index === null) {
				throw new TypeError("'index' is not nullable");
			}
			var c = that.skip(index);
			if(c === -1) {
				return Token.EOF;
			}
			else if(c === 101) {
				if((that.charAt(1) === 120) && (that.charAt(2) === 112) && (that.charAt(3) === 111) && (that.charAt(4) === 114) && (that.charAt(5) === 116) && that.isBoundary(6)) {
					that.next(6);
					return Token.EXPORT;
				}
				else if((that.charAt(1) === 120) && (that.charAt(2) === 116) && (that.charAt(3) === 101) && (that.charAt(4) === 114) && (that.charAt(5) === 110)) {
					if(that.charAt(6) === 124) {
						if((that.charAt(7) === 114) && (that.charAt(8) === 101) && (that.charAt(9) === 113) && (that.charAt(10) === 117) && (that.charAt(11) === 105) && (that.charAt(12) === 114) && (that.charAt(13) === 101) && that.isBoundary(14)) {
							that.next(14);
							return Token.EXTERN_REQUIRE;
						}
					}
					else if(that.isBoundary(6)) {
						that.next(6);
						return Token.EXTERN;
					}
				}
			}
			else if(c === 105) {
				if((that.charAt(1) === 110) && (that.charAt(2) === 99) && (that.charAt(3) === 108) && (that.charAt(4) === 117) && (that.charAt(5) === 100) && (that.charAt(6) === 101)) {
					if((that.charAt(7) === 32) && (that.charAt(8) === 97) && (that.charAt(9) === 103) && (that.charAt(10) === 97) && (that.charAt(11) === 105) && (that.charAt(12) === 110) && that.isBoundary(13)) {
						that.next(13);
						return Token.INCLUDE_AGAIN;
					}
					else if(that.isBoundary(7)) {
						that.next(7);
						return Token.INCLUDE;
					}
				}
			}
			else if(c === 114) {
				if((that.charAt(1) === 101) && (that.charAt(2) === 113) && (that.charAt(3) === 117) && (that.charAt(4) === 105) && (that.charAt(5) === 114) && (that.charAt(6) === 101)) {
					if(that.charAt(7) === 124) {
						if((that.charAt(8) === 101) && (that.charAt(9) === 120) && (that.charAt(10) === 116) && (that.charAt(11) === 101) && (that.charAt(12) === 114) && (that.charAt(13) === 110) && that.isBoundary(14)) {
							that.next(14);
							return Token.REQUIRE_EXTERN;
						}
						else if((that.charAt(8) === 105) && (that.charAt(9) === 109) && (that.charAt(10) === 112) && (that.charAt(11) === 111) && (that.charAt(12) === 114) && (that.charAt(13) === 116) && that.isBoundary(14)) {
							that.next(14);
							return Token.REQUIRE_IMPORT;
						}
					}
					else if(that.isBoundary(7)) {
						that.next(7);
						return Token.REQUIRE;
					}
				}
			}
			return Token.INVALID;
		}
		function NUMBER(that, index) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(that === void 0 || that === null) {
				throw new TypeError("'that' is not nullable");
			}
			if(index === void 0 || index === null) {
				throw new TypeError("'index' is not nullable");
			}
			var c = that.skip(index);
			if(c === -1) {
				return Token.EOF;
			}
			else if((c >= 48) && (c <= 57)) {
				var substr = that._data.substr(that._index);
				var match, __ks_0;
				if(Type.isValue(__ks_0 = regex.binary_number.exec(substr)) ? (match = __ks_0, true) : false) {
					that.next(match[0].length);
					return Token.BINARY_NUMBER;
				}
				else if(Type.isValue(__ks_0 = regex.octal_number.exec(substr)) ? (match = __ks_0, true) : false) {
					that.next(match[0].length);
					return Token.OCTAL_NUMBER;
				}
				else if(Type.isValue(__ks_0 = regex.hex_number.exec(substr)) ? (match = __ks_0, true) : false) {
					that.next(match[0].length);
					return Token.HEX_NUMBER;
				}
				else if(Type.isValue(__ks_0 = regex.radix_number.exec(substr)) ? (match = __ks_0, true) : false) {
					that.next(match[0].length);
					return Token.RADIX_NUMBER;
				}
				else if(Type.isValue(__ks_0 = regex.decimal_number.exec(substr)) ? (match = __ks_0, true) : false) {
					that.next(match[0].length);
					return Token.DECIMAL_NUMBER;
				}
			}
			return Token.INVALID;
		}
		function OPERAND(that, index) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(that === void 0 || that === null) {
				throw new TypeError("'that' is not nullable");
			}
			if(index === void 0 || index === null) {
				throw new TypeError("'index' is not nullable");
			}
			var c = that.skip(index);
			if(c === -1) {
				return Token.EOF;
			}
			else if(c === 34) {
				var match, __ks_0;
				if(Type.isValue(__ks_0 = regex.double_quote.exec(that.substringAt(1))) ? (match = __ks_0, true) : false) {
					that.next(match[0].length + 1);
					return Token.STRING;
				}
			}
			else if(c === 36) {
				that.scanIdentifier(false);
				return Token.IDENTIFIER;
			}
			else if(c === 39) {
				var match;
				if(Type.isValue(__ks_0 = regex.single_quote.exec(that.substringAt(1))) ? (match = __ks_0, true) : false) {
					that.next(match[0].length + 1);
					return Token.STRING;
				}
			}
			else if(c === 40) {
				that.next(1);
				return Token.LEFT_ROUND;
			}
			else if(c === 47) {
				var match;
				if(Type.isValue(__ks_0 = regex.regex.exec(that.substringAt(1))) ? (match = __ks_0, true) : false) {
					that.next(match[0].length + 1);
					return Token.REGEXP;
				}
			}
			else if(c === 64) {
				that.next(1);
				return Token.AT;
			}
			else if((c >= 65) && (c <= 90)) {
				that.scanIdentifier(false);
				return Token.IDENTIFIER;
			}
			else if(c === 91) {
				that.next(1);
				return Token.LEFT_SQUARE;
			}
			else if(c === 95) {
				that.scanIdentifier(false);
				return Token.IDENTIFIER;
			}
			else if(c === 96) {
				that.next(1);
				return Token.TEMPLATE_BEGIN;
			}
			else if(c === 97) {
				if(that.scanIdentifier(true) === "wait") {
					return Token.AWAIT;
				}
				else {
					return Token.IDENTIFIER;
				}
			}
			else if(c === 110) {
				if(that.scanIdentifier(true) === "ew") {
					return Token.NEW;
				}
				else {
					return Token.IDENTIFIER;
				}
			}
			else if((c >= 98) && (c <= 122)) {
				that.scanIdentifier(false);
				return Token.IDENTIFIER;
			}
			else if(c === 123) {
				that.next(1);
				return Token.LEFT_CURLY;
			}
			return Token.INVALID;
		}
		function OPERAND_JUNCTION(that, index) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(that === void 0 || that === null) {
				throw new TypeError("'that' is not nullable");
			}
			if(index === void 0 || index === null) {
				throw new TypeError("'index' is not nullable");
			}
			var c = that._data.charCodeAt(index + 1);
			var p = that._data.charCodeAt(index);
			if((p === 9) || (p === 32)) {
				return Token.INVALID;
			}
			else if((c === 13) && (that.charAt(1) === 10)) {
				that.nextLine(2);
				return Token.NEWLINE;
			}
			else if((c === 10) || (c === 13)) {
				that.nextLine(1);
				return Token.NEWLINE;
			}
			else if(c === 33) {
				if(that.charAt(1) === 40) {
					that.next(2);
					return Token.EXCLAMATION_LEFT_ROUND;
				}
			}
			else if(c === 40) {
				that.next(1);
				return Token.LEFT_ROUND;
			}
			else if(c === 42) {
				if(that.charAt(2) === 40) {
					c = that.charAt(1);
					if(c === 36) {
						that.next(3);
						return Token.ASTERISK_DOLLAR_LEFT_ROUND;
					}
					else if(c === 42) {
						that.next(3);
						return Token.ASTERISK_ASTERISK_LEFT_ROUND;
					}
				}
			}
			else if(c === 46) {
				if(((c = that.charAt(1)) !== 46) && (c !== 9) && (c !== 32)) {
					that.next(1);
					return Token.DOT;
				}
			}
			else if(c === 58) {
				c = that.charAt(1);
				if((c === 58) && !(((c = that.charAt(2)) === 9) || (c === 32))) {
					that.next(2);
					return Token.COLON_COLON;
				}
				else if((c !== 61) && (c !== 9) && (c !== 32)) {
					that.next(1);
					return Token.COLON;
				}
			}
			else if(c === 63) {
				c = that.charAt(1);
				if(c === 40) {
					that.next(2);
					return Token.QUESTION_LEFT_ROUND;
				}
				else if((c === 46) && !(((c = that.charAt(2)) === 9) || (c === 32))) {
					that.next(2);
					return Token.QUESTION_DOT;
				}
				else if(c === 91) {
					that.next(2);
					return Token.QUESTION_LEFT_SQUARE;
				}
			}
			else if(c === 91) {
				that.next(1);
				return Token.LEFT_SQUARE;
			}
			else if(c === 94) {
				if(that.charAt(2) === 40) {
					c = that.charAt(1);
					if(c === 36) {
						that.next(3);
						return Token.CARET_DOLLAR_LEFT_ROUND;
					}
					else if(c === 64) {
						that.next(3);
						return Token.CARET_AT_LEFT_ROUND;
					}
					else if(c === 94) {
						that.next(3);
						return Token.CARET_CARET_LEFT_ROUND;
					}
				}
			}
			return Token.INVALID;
		}
		function POSTFIX_OPERATOR(that, index) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(that === void 0 || that === null) {
				throw new TypeError("'that' is not nullable");
			}
			if(index === void 0 || index === null) {
				throw new TypeError("'index' is not nullable");
			}
			var p = that._data.charCodeAt(index);
			var c = that._data.charCodeAt(index + 1);
			if((p === 9) || (p === 32)) {
				return Token.INVALID;
			}
			else if(c === 43) {
				if(that.charAt(1) === 43) {
					that.next(2);
					return Token.PLUS_PLUS;
				}
			}
			else if(c === 45) {
				if(that.charAt(1) === 45) {
					that.next(2);
					return Token.MINUS_MINUS;
				}
			}
			else if(c === 63) {
				if(!(((c = that.charAt(1)) === 40) || (c === 46) || (c === 61) || (c === 63) || (c === 91))) {
					that.next(1);
					return Token.QUESTION;
				}
			}
			return Token.INVALID;
		}
		function PREFIX_OPERATOR(that, index) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(that === void 0 || that === null) {
				throw new TypeError("'that' is not nullable");
			}
			if(index === void 0 || index === null) {
				throw new TypeError("'index' is not nullable");
			}
			var c = that.skip(index);
			if(c === -1) {
				return Token.EOF;
			}
			else if(c === 33) {
				if(!(((c = that.charAt(1)) === 61) || ((c === 63) && (that.charAt(2) === 61)) || (c === 9) || (c === 32))) {
					that.next(1);
					return Token.EXCLAMATION;
				}
			}
			else if(c === 43) {
				if((that.charAt(1) === 43) && !(((c = that.charAt(2)) === 9) || (c === 32))) {
					that.next(2);
					return Token.PLUS_PLUS;
				}
			}
			else if(c === 45) {
				c = that.charAt(1);
				if(c === 45) {
					if(!(((c = that.charAt(2)) === 9) || (c === 32))) {
						that.next(2);
						return Token.MINUS_MINUS;
					}
				}
				else if(((c !== 61) && (c !== 9)) || (c !== 32)) {
					that.next(1);
					return Token.MINUS;
				}
			}
			else if(c === 46) {
				if((that.charAt(1) === 46) && (that.charAt(2) === 46) && !(((c = that.charAt(3)) === 9) || (c === 32))) {
					that.next(3);
					return Token.DOT_DOT_DOT;
				}
			}
			else if(c === 63) {
				if(!(((c = that.charAt(1)) === 9) || (c === 32))) {
					that.next(1);
					return Token.QUESTION;
				}
			}
			else if(c === 126) {
				if(!(((c = that.charAt(1)) === 9) || (c === 32))) {
					that.next(1);
					return Token.TILDE;
				}
			}
			return Token.INVALID;
		}
		function STATEMENT(that, index) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(that === void 0 || that === null) {
				throw new TypeError("'that' is not nullable");
			}
			if(index === void 0 || index === null) {
				throw new TypeError("'index' is not nullable");
			}
			var c = that.skip(index);
			if(c === -1) {
				return Token.EOF;
			}
			else if(c === 97) {
				if((that.charAt(1) === 98) && (that.charAt(2) === 115) && (that.charAt(3) === 116) && (that.charAt(4) === 114) && (that.charAt(5) === 97) && (that.charAt(6) === 99) && (that.charAt(7) === 116) && that.isBoundary(8)) {
					that.next(8);
					return Token.ABSTRACT;
				}
			}
			else if(c === 98) {
				if((that.charAt(1) === 114) && (that.charAt(2) === 101) && (that.charAt(3) === 97) && (that.charAt(4) === 107) && that.isBoundary(5)) {
					that.next(5);
					return Token.BREAK;
				}
			}
			else if(c === 99) {
				if((that.charAt(1) === 108) && (that.charAt(2) === 97) && (that.charAt(3) === 115) && (that.charAt(4) === 115) && that.isBoundary(5)) {
					that.next(5);
					return Token.CLASS;
				}
				else if((that.charAt(1) === 111) && (that.charAt(2) === 110) && (that.charAt(3) === 115) && (that.charAt(4) === 116) && that.isBoundary(5)) {
					that.next(5);
					return Token.CONST;
				}
				else if((that.charAt(1) === 111) && (that.charAt(2) === 110) && (that.charAt(3) === 116) && (that.charAt(4) === 105) && (that.charAt(5) === 110) && (that.charAt(6) === 117) && (that.charAt(7) === 101) && that.isBoundary(8)) {
					that.next(8);
					return Token.CONTINUE;
				}
			}
			else if(c === 100) {
				if((that.charAt(1) === 111) && that.isBoundary(2)) {
					that.next(2);
					return Token.DO;
				}
				else if((that.charAt(1) === 101) && (that.charAt(2) === 108) && (that.charAt(3) === 101) && (that.charAt(4) === 116) && (that.charAt(5) === 101) && that.isBoundary(6)) {
					that.next(6);
					return Token.DELETE;
				}
			}
			else if(c === 101) {
				if((that.charAt(1) === 110) && (that.charAt(2) === 117) && (that.charAt(3) === 109) && that.isBoundary(4)) {
					that.next(4);
					return Token.ENUM;
				}
			}
			else if(c === 102) {
				if((that.charAt(1) === 111) && (that.charAt(2) === 114) && that.isBoundary(3)) {
					that.next(3);
					return Token.FOR;
				}
				else if((that.charAt(1) === 117) && (that.charAt(2) === 110) && (that.charAt(3) === 99) && that.isBoundary(4)) {
					that.next(4);
					return Token.FUNC;
				}
			}
			else if(c === 105) {
				if((that.charAt(1) === 102) && that.isBoundary(2)) {
					that.next(2);
					return Token.IF;
				}
				else if((that.charAt(1) === 109) && (that.charAt(2) === 112) && (that.charAt(3) === 108) && that.isBoundary(4)) {
					that.next(4);
					return Token.IMPL;
				}
				else if((that.charAt(1) === 109) && (that.charAt(2) === 112) && (that.charAt(3) === 111) && (that.charAt(4) === 114) && (that.charAt(5) === 116) && that.isBoundary(6)) {
					that.next(6);
					return Token.IMPORT;
				}
			}
			else if(c === 108) {
				if((that.charAt(1) === 101) && (that.charAt(2) === 116) && that.isBoundary(3)) {
					that.next(3);
					return Token.LET;
				}
			}
			else if(c === 109) {
				if((that.charAt(1) === 97) && (that.charAt(2) === 99) && (that.charAt(3) === 114) && (that.charAt(4) === 111) && that.isBoundary(5)) {
					that.next(5);
					return Token.MACRO;
				}
			}
			else if(c === 110) {
				if((that.charAt(1) === 97) && (that.charAt(2) === 109) && (that.charAt(3) === 101) && (that.charAt(4) === 115) && (that.charAt(5) === 112) && (that.charAt(6) === 97) && (that.charAt(7) === 99) && (that.charAt(8) === 101) && that.isBoundary(9)) {
					that.next(9);
					return Token.NAMESPACE;
				}
			}
			else if(c === 114) {
				if((that.charAt(1) === 101) && (that.charAt(2) === 116) && (that.charAt(3) === 117) && (that.charAt(4) === 114) && (that.charAt(5) === 110) && that.isBoundary(6)) {
					that.next(6);
					return Token.RETURN;
				}
			}
			else if(c === 115) {
				if((that.charAt(1) === 101) && (that.charAt(2) === 97) && (that.charAt(3) === 108) && (that.charAt(4) === 101) && (that.charAt(5) === 100) && that.isBoundary(6)) {
					that.next(6);
					return Token.SEALED;
				}
				else if((that.charAt(1) === 119) && (that.charAt(2) === 105) && (that.charAt(3) === 116) && (that.charAt(4) === 99) && (that.charAt(5) === 104) && that.isBoundary(6)) {
					that.next(6);
					return Token.SWITCH;
				}
			}
			else if(c === 116) {
				if((that.charAt(1) === 104) && (that.charAt(2) === 114) && (that.charAt(3) === 111) && (that.charAt(4) === 119) && that.isBoundary(5)) {
					that.next(5);
					return Token.THROW;
				}
				else if((that.charAt(1) === 114) && (that.charAt(2) === 121) && that.isBoundary(3)) {
					that.next(3);
					return Token.TRY;
				}
				else if((that.charAt(1) === 121) && (that.charAt(2) === 112) && (that.charAt(3) === 101) && that.isBoundary(4)) {
					that.next(4);
					return Token.TYPE;
				}
			}
			else if(c === 117) {
				if((that.charAt(1) === 110) && (that.charAt(2) === 108) && (that.charAt(3) === 101) && (that.charAt(4) === 115) && (that.charAt(5) === 115) && that.isBoundary(6)) {
					that.next(6);
					return Token.UNLESS;
				}
				else if((that.charAt(1) === 110) && (that.charAt(2) === 116) && (that.charAt(3) === 105) && (that.charAt(4) === 108) && that.isBoundary(5)) {
					that.next(5);
					return Token.UNTIL;
				}
			}
			else if(c === 119) {
				if((that.charAt(1) === 104) && (that.charAt(2) === 105) && (that.charAt(3) === 108) && (that.charAt(4) === 101) && that.isBoundary(5)) {
					that.next(5);
					return Token.WHILE;
				}
			}
			return Token.INVALID;
		}
		function TEMPLATE(that, index) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(that === void 0 || that === null) {
				throw new TypeError("'that' is not nullable");
			}
			if(index === void 0 || index === null) {
				throw new TypeError("'index' is not nullable");
			}
			var c = that._data.charCodeAt(++index);
			var match, __ks_0;
			if((c === 92) && (that._data.charCodeAt(index + 1) === 40)) {
				that.next(2);
				return Token.TEMPLATE_ELEMENT;
			}
			else if(c === 96) {
				return Token.TEMPLATE_END;
			}
			else if(Type.isValue(__ks_0 = regex.template.exec(that._data.substr(index))) ? (match = __ks_0, true) : false) {
				that.next(match[0].length);
				return Token.TEMPLATE_VALUE;
			}
			return Token.INVALID;
		}
		function TYPE_OPERATOR(that, index) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(that === void 0 || that === null) {
				throw new TypeError("'that' is not nullable");
			}
			if(index === void 0 || index === null) {
				throw new TypeError("'index' is not nullable");
			}
			var c = that.skip(index);
			if(c === -1) {
				return Token.EOF;
			}
			else if(index === that._index) {
				return Token.INVALID;
			}
			else if(c === 97) {
				if((that.charAt(1) === 115) && that.isBoundary(2)) {
					that.next(2);
					return Token.AS;
				}
			}
			else if(c === 105) {
				if(that.charAt(1) === 115) {
					if(((c = that.charAt(2)) === 9) || (c === 32)) {
						if(that.charAt(3) === 110) {
							if((that.charAt(4) === 111) && (that.charAt(5) === 116) && that.isBoundary(6)) {
								that.next(6);
								return Token.IS_NOT;
							}
						}
						else {
							that.next(2);
							return Token.IS;
						}
					}
					else if(that.isBoundary(2)) {
						that.next(2);
						return Token.IS;
					}
				}
			}
			return Token.INVALID;
		}
		return {
			BINARY_OPERATOR: BINARY_OPERATOR,
			EXPORT_STATEMENT: EXPORT_STATEMENT,
			EXTERN_STATEMENT: EXTERN_STATEMENT,
			MACRO: MACRO,
			MODULE_STATEMENT: MODULE_STATEMENT,
			NUMBER: NUMBER,
			OPERAND: OPERAND,
			OPERAND_JUNCTION: OPERAND_JUNCTION,
			POSTFIX_OPERATOR: POSTFIX_OPERATOR,
			PREFIX_OPERATOR: PREFIX_OPERATOR,
			STATEMENT: STATEMENT,
			TEMPLATE: TEMPLATE,
			TYPE_OPERATOR: TYPE_OPERATOR
		};
	})();
	var recognize = {};
	recognize[Token.ABSTRACT] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 97) && (that.charAt(1) === 98) && (that.charAt(2) === 115) && (that.charAt(3) === 116) && (that.charAt(4) === 114) && (that.charAt(5) === 97) && (that.charAt(6) === 99) && (that.charAt(7) === 116) && that.isBoundary(8)) {
			return that.next(8);
		}
		else {
			return false;
		}
	};
	recognize[Token.ASTERISK] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 42) && ((c = that.charAt(1)) !== 42) && (c !== 36) && (c !== 61)) {
			return that.next(1);
		}
		else {
			return false;
		}
	};
	recognize[Token.AS] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 97) && (that.charAt(1) === 115) && that.isBoundary(2)) {
			return that.next(2);
		}
		else {
			return false;
		}
	};
	recognize[Token.ASYNC] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 97) && (that.charAt(1) === 115) && (that.charAt(2) === 121) && (that.charAt(3) === 110) && (that.charAt(4) === 99) && that.isBoundary(5)) {
			return that.next(5);
		}
		else {
			return false;
		}
	};
	recognize[Token.AT] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if(c === 64) {
			return that.next(1);
		}
		else {
			return false;
		}
	};
	recognize[Token.AWAIT] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 97) && (that.charAt(1) === 119) && (that.charAt(2) === 97) && (that.charAt(3) === 105) && (that.charAt(4) === 116) && that.isBoundary(5)) {
			return that.next(5);
		}
		else {
			return false;
		}
	};
	recognize[Token.BY] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 98) && (that.charAt(1) === 121) && that.isBoundary(2)) {
			return that.next(2);
		}
		else {
			return false;
		}
	};
	recognize[Token.CATCH] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 99) && (that.charAt(1) === 97) && (that.charAt(2) === 116) && (that.charAt(3) === 99) && (that.charAt(4) === 104) && that.isBoundary(5)) {
			return that.next(5);
		}
		else {
			return false;
		}
	};
	recognize[Token.COLON] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if(c === 58) {
			c = that.charAt(1);
			return ((c === 58) || (c === 61)) ? false : that.next(1);
		}
		else {
			return false;
		}
	};
	recognize[Token.COLON_EQUALS] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 58) && (that.charAt(1) === 61)) {
			return that.next(2);
		}
		else {
			return false;
		}
	};
	recognize[Token.COMMA] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if(c === 44) {
			return that.next(1);
		}
		else {
			return false;
		}
	};
	recognize[Token.CLASS] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 99) && (that.charAt(1) === 108) && (that.charAt(2) === 97) && (that.charAt(3) === 115) && (that.charAt(4) === 115) && that.isBoundary(5)) {
			return that.next(5);
		}
		else {
			return false;
		}
	};
	recognize[Token.CLASS_VERSION] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		var match, __ks_0;
		if(Type.isValue(__ks_0 = regex.class_version.exec(that.substringAt(0))) ? (match = __ks_0, true) : false) {
			return that.next(match[0].length);
		}
		else {
			return false;
		}
	};
	recognize[Token.DESC] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 100) && (that.charAt(1) === 101) && (that.charAt(2) === 115) && (that.charAt(3) === 99) && that.isBoundary(4)) {
			return that.next(4);
		}
		else {
			return false;
		}
	};
	recognize[Token.DOT] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 46) && (that.charAt(1) !== 46)) {
			return that.next(1);
		}
		else {
			return false;
		}
	};
	recognize[Token.DOT_DOT] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 46) && (that.charAt(1) === 46) && (that.charAt(2) !== 46)) {
			return that.next(2);
		}
		else {
			return false;
		}
	};
	recognize[Token.DOT_DOT_DOT] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 46) && (that.charAt(1) === 46) && (that.charAt(2) === 46)) {
			return that.next(3);
		}
		else {
			return false;
		}
	};
	recognize[Token.ELSE] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 101) && (that.charAt(1) === 108) && (that.charAt(2) === 115) && (that.charAt(3) === 101) && that.isBoundary(4)) {
			return that.next(4);
		}
		else {
			return false;
		}
	};
	recognize[Token.ELSE_IF] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 101) && (that.charAt(1) === 108) && (that.charAt(2) === 115) && (that.charAt(3) === 101) && (that.charAt(4) === 32) && (that.charAt(5) === 105) && (that.charAt(6) === 102) && that.isBoundary(7)) {
			return that.next(7);
		}
		else {
			return false;
		}
	};
	recognize[Token.EQUALS] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 61) && ((c = that.charAt(1)) !== 61) && (c !== 62)) {
			return that.next(1);
		}
		else {
			return false;
		}
	};
	recognize[Token.EQUALS_RIGHT_ANGLE] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 61) && (that.charAt(1) === 62)) {
			return that.next(2);
		}
		else {
			return false;
		}
	};
	recognize[Token.EXTENDS] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 101) && (that.charAt(1) === 120) && (that.charAt(2) === 116) && (that.charAt(3) === 101) && (that.charAt(4) === 110) && (that.charAt(5) === 100) && (that.charAt(6) === 115) && that.isBoundary(7)) {
			return that.next(7);
		}
		else {
			return false;
		}
	};
	recognize[Token.FINALLY] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 102) && (that.charAt(1) === 105) && (that.charAt(2) === 110) && (that.charAt(3) === 97) && (that.charAt(4) === 108) && (that.charAt(5) === 108) && (that.charAt(6) === 121) && that.isBoundary(7)) {
			return that.next(7);
		}
		else {
			return false;
		}
	};
	recognize[Token.FOR] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 102) && (that.charAt(1) === 111) && (that.charAt(2) === 114) && that.isBoundary(3)) {
			return that.next(3);
		}
		else {
			return false;
		}
	};
	recognize[Token.FROM] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 102) && (that.charAt(1) === 114) && (that.charAt(2) === 111) && (that.charAt(3) === 109) && that.isBoundary(4)) {
			return that.next(4);
		}
		else {
			return false;
		}
	};
	recognize[Token.FUNC] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 102) && (that.charAt(1) === 117) && (that.charAt(2) === 110) && (that.charAt(3) === 99) && that.isBoundary(4)) {
			return that.next(4);
		}
		else {
			return false;
		}
	};
	recognize[Token.GET] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 103) && (that.charAt(1) === 101) && (that.charAt(2) === 116) && that.isBoundary(3)) {
			return that.next(3);
		}
		else {
			return false;
		}
	};
	recognize[Token.HASH_EXCLAMATION_LEFT_SQUARE] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 35) && (that.charAt(1) === 33) && (that.charAt(2) === 91)) {
			return that.next(3);
		}
		else {
			return false;
		}
	};
	recognize[Token.HASH_LEFT_SQUARE] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 35) && (that.charAt(1) === 91)) {
			return that.next(2);
		}
		else {
			return false;
		}
	};
	recognize[Token.IDENTIFIER] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 36) || (c === 95) || ((c >= 65) && (c <= 90)) || ((c >= 97) && (c <= 122))) {
			that.scanIdentifier(false);
			return true;
		}
		else {
			return false;
		}
	};
	recognize[Token.IF] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 105) && (that.charAt(1) === 102) && that.isBoundary(2)) {
			return that.next(2);
		}
		else {
			return false;
		}
	};
	recognize[Token.IN] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 105) && (that.charAt(1) === 110) && that.isBoundary(2)) {
			return that.next(2);
		}
		else {
			return false;
		}
	};
	recognize[Token.IS] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 105) && (that.charAt(1) === 115) && that.isBoundary(2)) {
			return that.next(2);
		}
		else {
			return false;
		}
	};
	recognize[Token.LEFT_ANGLE] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if(c === 60) {
			c = that.charAt(1);
			return ((c === 60) || (c === 61)) ? false : that.next(1);
		}
		else {
			return false;
		}
	};
	recognize[Token.LEFT_CURLY] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if(c === 123) {
			return that.next(1);
		}
		else {
			return false;
		}
	};
	recognize[Token.LEFT_ROUND] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if(c === 40) {
			return that.next(1);
		}
		else {
			return false;
		}
	};
	recognize[Token.LEFT_SQUARE] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if(c === 91) {
			return that.next(1);
		}
		else {
			return false;
		}
	};
	recognize[Token.LET] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 108) && (that.charAt(1) === 101) && (that.charAt(2) === 116) && that.isBoundary(3)) {
			return that.next(3);
		}
		else {
			return false;
		}
	};
	recognize[Token.MACRO] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 109) && (that.charAt(1) === 97) && (that.charAt(2) === 99) && (that.charAt(3) === 114) && (that.charAt(4) === 111) && that.isBoundary(5)) {
			return that.next(5);
		}
		else {
			return false;
		}
	};
	recognize[Token.MINUS] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 45) && ((c = that.charAt(1)) !== 61)) {
			return that.next(1);
		}
		else {
			return false;
		}
	};
	recognize[Token.NEWLINE] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 13) && (that.charAt(1) === 10)) {
			return that.nextLine(2);
		}
		else if((c === 10) || (c === 13)) {
			return that.nextLine(1);
		}
		return false;
	};
	recognize[Token.OF] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 111) && (that.charAt(1) === 102) && that.isBoundary(2)) {
			return that.next(2);
		}
		else {
			return false;
		}
	};
	recognize[Token.ON] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 111) && (that.charAt(1) === 110) && that.isBoundary(2)) {
			return that.next(2);
		}
		else {
			return false;
		}
	};
	recognize[Token.PIPE] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 124) && (that.charAt(1) !== 61)) {
			return that.next(1);
		}
		else {
			return false;
		}
	};
	recognize[Token.PRIVATE] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 112) && (that.charAt(1) === 114) && (that.charAt(2) === 105) && (that.charAt(3) === 118) && (that.charAt(4) === 97) && (that.charAt(5) === 116) && (that.charAt(6) === 101) && that.isBoundary(7)) {
			return that.next(7);
		}
		else {
			return false;
		}
	};
	recognize[Token.PROTECTED] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 112) && (that.charAt(1) === 114) && (that.charAt(2) === 111) && (that.charAt(3) === 116) && (that.charAt(4) === 101) && (that.charAt(5) === 99) && (that.charAt(6) === 116) && (that.charAt(7) === 101) && (that.charAt(8) === 100) && that.isBoundary(9)) {
			return that.next(9);
		}
		else {
			return false;
		}
	};
	recognize[Token.PUBLIC] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 112) && (that.charAt(1) === 117) && (that.charAt(2) === 98) && (that.charAt(3) === 108) && (that.charAt(4) === 105) && (that.charAt(5) === 99) && that.isBoundary(6)) {
			return that.next(6);
		}
		else {
			return false;
		}
	};
	recognize[Token.QUESTION] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if(c === 63) {
			return (((c = that.charAt(1)) === 40) || (c === 46) || (c === 61) || (c === 63) || (c === 91)) ? false : that.next(1);
		}
		else {
			return false;
		}
	};
	recognize[Token.RETURN] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 114) && (that.charAt(1) === 101) && (that.charAt(2) === 116) && (that.charAt(3) === 117) && (that.charAt(4) === 114) && (that.charAt(5) === 110) && that.isBoundary(6)) {
			return that.next(6);
		}
		else {
			return false;
		}
	};
	recognize[Token.RIGHT_ANGLE] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if(c === 62) {
			c = that.charAt(1);
			return ((c === 61) || (c === 62)) ? false : that.next(1);
		}
		else {
			return false;
		}
	};
	recognize[Token.RIGHT_CURLY] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if(c === 125) {
			return that.next(1);
		}
		else {
			return false;
		}
	};
	recognize[Token.RIGHT_ROUND] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if(c === 41) {
			return that.next(1);
		}
		else {
			return false;
		}
	};
	recognize[Token.RIGHT_SQUARE] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if(c === 93) {
			return that.next(1);
		}
		else {
			return false;
		}
	};
	recognize[Token.SET] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 115) && (that.charAt(1) === 101) && (that.charAt(2) === 116) && that.isBoundary(3)) {
			return that.next(3);
		}
		else {
			return false;
		}
	};
	recognize[Token.STATIC] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 115) && (that.charAt(1) === 116) && (that.charAt(2) === 97) && (that.charAt(3) === 116) && (that.charAt(4) === 105) && (that.charAt(5) === 99) && that.isBoundary(6)) {
			return that.next(6);
		}
		else {
			return false;
		}
	};
	recognize[Token.STRING] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if(c === 34) {
			var match, __ks_0;
			if(Type.isValue(__ks_0 = regex.double_quote.exec(that.substringAt(1))) ? (match = __ks_0, true) : false) {
				return that.next(match[0].length + 1);
			}
		}
		else if(c === 39) {
			var match;
			if(Type.isValue(__ks_0 = regex.single_quote.exec(that.substringAt(1))) ? (match = __ks_0, true) : false) {
				return that.next(match[0].length + 1);
			}
		}
		return false;
	};
	recognize[Token.SWITCH] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 115) && (that.charAt(1) === 119) && (that.charAt(2) === 105) && (that.charAt(3) === 116) && (that.charAt(4) === 99) && (that.charAt(5) === 104) && that.isBoundary(6)) {
			return that.next(6);
		}
		else {
			return false;
		}
	};
	recognize[Token.TEMPLATE_BEGIN] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if(c === 96) {
			return that.next(1);
		}
		else {
			return false;
		}
	};
	recognize[Token.TEMPLATE_END] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if(c === 96) {
			return that.next(1);
		}
		else {
			return false;
		}
	};
	recognize[Token.THROW] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 116) && (that.charAt(1) === 104) && (that.charAt(2) === 114) && (that.charAt(3) === 111) && (that.charAt(4) === 119) && that.isBoundary(5)) {
			return that.next(5);
		}
		else {
			return false;
		}
	};
	recognize[Token.TIL] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 116) && (that.charAt(1) === 105) && (that.charAt(2) === 108) && that.isBoundary(3)) {
			return that.next(3);
		}
		else {
			return false;
		}
	};
	recognize[Token.TILDE] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if(c === 126) {
			return that.next(1);
		}
		else {
			return false;
		}
	};
	recognize[Token.TO] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 116) && (that.charAt(1) === 111) && that.isBoundary(2)) {
			return that.next(2);
		}
		else {
			return false;
		}
	};
	recognize[Token.UNLESS] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 117) && (that.charAt(1) === 110) && (that.charAt(2) === 108) && (that.charAt(3) === 101) && (that.charAt(4) === 115) && (that.charAt(5) === 115) && that.isBoundary(6)) {
			return that.next(6);
		}
		else {
			return false;
		}
	};
	recognize[Token.UNTIL] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 117) && (that.charAt(1) === 110) && (that.charAt(2) === 116) && (that.charAt(3) === 105) && (that.charAt(4) === 108) && that.isBoundary(5)) {
			return that.next(5);
		}
		else {
			return false;
		}
	};
	recognize[Token.WHEN] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 119) && (that.charAt(1) === 104) && (that.charAt(2) === 101) && (that.charAt(3) === 110) && that.isBoundary(4)) {
			return that.next(4);
		}
		else {
			return false;
		}
	};
	recognize[Token.WHERE] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 119) && (that.charAt(1) === 104) && (that.charAt(2) === 101) && (that.charAt(3) === 114) && (that.charAt(4) === 101) && that.isBoundary(5)) {
			return that.next(5);
		}
		else {
			return false;
		}
	};
	recognize[Token.WHILE] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 119) && (that.charAt(1) === 104) && (that.charAt(2) === 105) && (that.charAt(3) === 108) && (that.charAt(4) === 101) && that.isBoundary(5)) {
			return that.next(5);
		}
		else {
			return false;
		}
	};
	recognize[Token.WITH] = function(that, c) {
		if(arguments.length < 2) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
		}
		if(that === void 0 || that === null) {
			throw new TypeError("'that' is not nullable");
		}
		if(c === void 0 || c === null) {
			throw new TypeError("'c' is not nullable");
		}
		if((c === 119) && (that.charAt(1) === 105) && (that.charAt(2) === 116) && (that.charAt(3) === 104) && that.isBoundary(4)) {
			return that.next(4);
		}
		else {
			return false;
		}
	};
	var Scanner = Helper.class({
		$name: "Scanner",
		$create: function() {
			this.__ks_init();
			this.__ks_cons(arguments);
		},
		__ks_init_1: function() {
			this._column = 1;
			this._eof = false;
			this._index = 0;
			this._line = 1;
			this._nextColumn = 1;
			this._nextIndex = 0;
			this._nextLine = 1;
		},
		__ks_init: function() {
			Scanner.prototype.__ks_init_1.call(this);
		},
		__ks_cons_0: function(data) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			else if(!Type.isString(data)) {
				throw new TypeError("'data' is not of type 'String'");
			}
			this._data = data;
			this._length = this._data.length;
		},
		__ks_cons: function(args) {
			if(args.length === 1) {
				Scanner.prototype.__ks_cons_0.apply(this, args);
			}
			else {
				throw new SyntaxError("wrong number of arguments");
			}
		},
		__ks_func_charAt_0: function(d) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(d === void 0 || d === null) {
				throw new TypeError("'d' is not nullable");
			}
			return this._data.charCodeAt(this._index + d);
		},
		charAt: function() {
			if(arguments.length === 1) {
				return Scanner.prototype.__ks_func_charAt_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_char_0: function() {
			return this._eof ? "EOF" : this._data[this._index];
		},
		char: function() {
			if(arguments.length === 0) {
				return Scanner.prototype.__ks_func_char_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_column_0: function() {
			return this._column;
		},
		column: function() {
			if(arguments.length === 0) {
				return Scanner.prototype.__ks_func_column_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_commit_0: function() {
			if(this._eof) {
				return null;
			}
			else {
				this._column = this._nextColumn;
				this._line = this._nextLine;
				this._index = this._nextIndex;
				return Token.INVALID;
			}
		},
		commit: function() {
			if(arguments.length === 0) {
				return Scanner.prototype.__ks_func_commit_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_endPosition_0: function() {
			return {
				line: this._nextLine,
				column: this._nextColumn
			};
		},
		endPosition: function() {
			if(arguments.length === 0) {
				return Scanner.prototype.__ks_func_endPosition_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_eof_0: function() {
			this._eof = true;
			return Token.EOF;
		},
		eof: function() {
			if(arguments.length === 0) {
				return Scanner.prototype.__ks_func_eof_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_isBoundary_0: function(d) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(d === void 0 || d === null) {
				throw new TypeError("'d' is not nullable");
			}
			var c = this._data.charCodeAt(this._index + d);
			return (c === 9) || (c === 10) || (c === 13) || (c === 32) || !(((c >= 48) && (c <= 57)) || ((c >= 65) && (c <= 90)) || ((c >= 97) && (c <= 122)) || (c === 95) || (c === 36));
		},
		isBoundary: function() {
			if(arguments.length === 1) {
				return Scanner.prototype.__ks_func_isBoundary_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_isEOF_0: function() {
			return this._eof;
		},
		isEOF: function() {
			if(arguments.length === 0) {
				return Scanner.prototype.__ks_func_isEOF_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_line_0: function() {
			return this._line;
		},
		line: function() {
			if(arguments.length === 0) {
				return Scanner.prototype.__ks_func_line_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_mark_0: function() {
			return {
				eof: this._eof,
				index: this._index,
				line: this._line,
				column: this._column
			};
		},
		mark: function() {
			if(arguments.length === 0) {
				return Scanner.prototype.__ks_func_mark_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_match_0: function() {
			var tokens = Array.prototype.slice.call(arguments, 0, arguments.length);
			if(this._eof) {
				return Token.EOF;
			}
			else {
				var c = this.skip(this._index - 1);
				if(c === -1) {
					return this.eof();
				}
				for(var __ks_0 = 0, __ks_1 = tokens.length, token; __ks_0 < __ks_1; ++__ks_0) {
					token = tokens[__ks_0];
					if(recognize[token](this, c)) {
						return token;
					}
				}
				return Token.INVALID;
			}
		},
		match: function() {
			return Scanner.prototype.__ks_func_match_0.apply(this, arguments);
		},
		__ks_func_matchM_0: function(matcher) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(matcher === void 0 || matcher === null) {
				throw new TypeError("'matcher' is not nullable");
			}
			else if(!Type.isFunction(matcher)) {
				throw new TypeError("'matcher' is not of type 'Function'");
			}
			if(this._eof) {
				return Token.EOF;
			}
			else {
				return matcher(this, this._index - 1);
			}
		},
		matchM: function() {
			if(arguments.length === 1) {
				return Scanner.prototype.__ks_func_matchM_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_next_0: function(length) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(length === void 0 || length === null) {
				throw new TypeError("'length' is not nullable");
			}
			this._nextIndex = this._index + length;
			this._nextColumn = this._column + length;
			return true;
		},
		next: function() {
			if(arguments.length === 1) {
				return Scanner.prototype.__ks_func_next_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_nextLine_0: function(length) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(length === void 0 || length === null) {
				throw new TypeError("'length' is not nullable");
			}
			this._nextIndex = this._index + length;
			this._nextColumn = 1;
			this._nextLine = this._line + 1;
			return true;
		},
		nextLine: function() {
			if(arguments.length === 1) {
				return Scanner.prototype.__ks_func_nextLine_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_position_0: function() {
			return {
				start: {
					line: this._line,
					column: this._column
				},
				end: {
					line: this._nextLine,
					column: this._nextColumn
				}
			};
		},
		position: function() {
			if(arguments.length === 0) {
				return Scanner.prototype.__ks_func_position_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_rollback_0: function(mark) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(mark === void 0 || mark === null) {
				throw new TypeError("'mark' is not nullable");
			}
			this._eof = mark.eof;
			this._index = mark.index;
			this._line = mark.line;
			this._column = mark.column;
			return true;
		},
		rollback: function() {
			if(arguments.length === 1) {
				return Scanner.prototype.__ks_func_rollback_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_scanIdentifier_0: function(substr) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(substr === void 0 || substr === null) {
				throw new TypeError("'substr' is not nullable");
			}
			var index = this._index - 1;
			var c;
			while((++index < this._length) && (((c = this._data.charCodeAt(index)) === 36) || ((c >= 48) && (c <= 57)) || ((c >= 65) && (c <= 90)) || (c === 95) || ((c >= 97) && (c <= 122)))) {
			}
			if(substr) {
				var identifier = this._data.substring(this._index + 1, index);
				this.next(index - this._index);
				return identifier;
			}
			else {
				this.next(index - this._index);
			}
		},
		scanIdentifier: function() {
			if(arguments.length === 1) {
				return Scanner.prototype.__ks_func_scanIdentifier_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_skip_0: function() {
			this.skip(this._index - 1);
		},
		__ks_func_skip_1: function(index) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(index === void 0 || index === null) {
				throw new TypeError("'index' is not nullable");
			}
			var c;
			while(++index < this._length) {
				c = this._data.charCodeAt(index);
				if((c === 32) || (c === 9)) {
					this._column++;
				}
				else if(c === 47) {
					c = this._data.charCodeAt(index + 1);
					if(c === 42) {
						var oldIndex = index;
						var line = this._line;
						var column = this._column;
						var left = 1;
						var lineIndex = index - this._column;
						++index;
						while(++index < this._length) {
							c = this._data.charCodeAt(index);
							if(c === 10) {
								line++;
								column = 1;
								lineIndex = index;
							}
							else if((c === 42) && (this._data.charCodeAt(index + 1) === 47)) {
								--left;
								if(left === 0) {
									++index;
									column += index - lineIndex;
									break;
								}
							}
							else if((c === 47) && (this._data.charCodeAt(index + 1) === 42)) {
								++left;
							}
						}
						if(left !== 0) {
							this._nextIndex = this._index = oldIndex;
							this._nextColumn = this._column;
							this._nextLine = this._line;
							return 47;
						}
						this._line = line;
						this._column = column;
					}
					else if(c === 47) {
						var lineIndex = index;
						while((++index < this._length) && (this._data.charCodeAt(index + 1) !== 10)) {
						}
						this._column += index - lineIndex;
					}
					else {
						this._nextIndex = this._index = index;
						this._nextColumn = this._column;
						this._nextLine = this._line;
						return 47;
					}
				}
				else {
					this._nextIndex = this._index = index;
					this._nextColumn = this._column;
					this._nextLine = this._line;
					return c;
				}
			}
			this._nextIndex = this._index = index;
			this._nextColumn = this._column;
			this._nextLine = this._line;
			this.eof();
			return -1;
		},
		skip: function() {
			if(arguments.length === 0) {
				return Scanner.prototype.__ks_func_skip_0.apply(this);
			}
			else if(arguments.length === 1) {
				return Scanner.prototype.__ks_func_skip_1.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_skipNewLine_0: function(index) {
			if(index === void 0 || index === null) {
				index = this._index - 1;
			}
			var c;
			while(++index < this._length) {
				c = this._data.charCodeAt(index);
				if((c === 13) && (this._data.charCodeAt(index + 1) === 10)) {
					this._line++;
					this._column = 1;
					++index;
				}
				else if((c === 10) || (c === 13)) {
					this._line++;
					this._column = 1;
				}
				else if((c === 32) || (c === 9)) {
					this._column++;
				}
				else if(c === 47) {
					c = this._data.charCodeAt(index + 1);
					if(c === 42) {
						var oldIndex = index;
						var line = this._line;
						var column = this._column;
						var left = 1;
						var lineIndex = index - this._column;
						++index;
						while(++index < this._length) {
							c = this._data.charCodeAt(index);
							if(c === 10) {
								line++;
								column = 1;
								lineIndex = index;
							}
							else if((c === 42) && (this._data.charCodeAt(index + 1) === 47)) {
								--left;
								if(left === 0) {
									++index;
									column += index - lineIndex;
									break;
								}
							}
							else if((c === 47) && (this._data.charCodeAt(index + 1) === 42)) {
								++left;
							}
						}
						if(left !== 0) {
							this._nextIndex = this._index = oldIndex;
							this._nextColumn = this._column;
							this._nextLine = this._line;
							return 47;
						}
						this._line = line;
						this._column = column;
					}
					else if(c === 47) {
						var lineIndex = index;
						while((++index < this._length) && (this._data.charCodeAt(index + 1) !== 10)) {
						}
						this._column += index - lineIndex;
					}
					else {
						this._nextIndex = this._index = index;
						this._nextColumn = this._column;
						this._nextLine = this._line;
						return 47;
					}
				}
				else {
					this._nextIndex = this._index = index;
					this._nextColumn = this._column;
					this._nextLine = this._line;
					return c;
				}
			}
			this._nextIndex = this._index = index;
			this._nextColumn = this._column;
			this._nextLine = this._line;
			this.eof();
			return -1;
		},
		skipNewLine: function() {
			if(arguments.length >= 0 && arguments.length <= 1) {
				return Scanner.prototype.__ks_func_skipNewLine_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_startPosition_0: function() {
			return {
				line: this._line,
				column: this._column
			};
		},
		startPosition: function() {
			if(arguments.length === 0) {
				return Scanner.prototype.__ks_func_startPosition_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_substringAt_0: function(d) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(d === void 0 || d === null) {
				throw new TypeError("'d' is not nullable");
			}
			return this._data.substr(this._index + d);
		},
		substringAt: function() {
			if(arguments.length === 1) {
				return Scanner.prototype.__ks_func_substringAt_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_test_0: function(token) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(token === void 0 || token === null) {
				throw new TypeError("'token' is not nullable");
			}
			else if(!Type.is(token, Token)) {
				throw new TypeError("'token' is not of type 'Token'");
			}
			if(this._eof) {
				return false;
			}
			else {
				var c = this.skip(this._index - 1);
				if(c === -1) {
					return this.eof() === token;
				}
				else {
					return recognize[token](this, c);
				}
			}
		},
		test: function() {
			if(arguments.length === 1) {
				return Scanner.prototype.__ks_func_test_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_testNS_0: function(token) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(token === void 0 || token === null) {
				throw new TypeError("'token' is not nullable");
			}
			else if(!Type.is(token, Token)) {
				throw new TypeError("'token' is not of type 'Token'");
			}
			if(this._eof) {
				return false;
			}
			else {
				return recognize[token](this, this._data.charCodeAt(this._index));
			}
		},
		testNS: function() {
			if(arguments.length === 1) {
				return Scanner.prototype.__ks_func_testNS_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_toQuote_0: function() {
			if(this._eof) {
				return "\"EOF\"";
			}
			else if((this._index + 1) >= this._nextIndex) {
				var c = this._data.charCodeAt(this._index);
				if(c === 10) {
					return "\"NewLine\"";
				}
				else {
					return "\"" + this._data[this._index] + "\"";
				}
			}
			else {
				return "\"" + this._data.substring(this._index, this._nextIndex) + "\"";
			}
		},
		toQuote: function() {
			if(arguments.length === 0) {
				return Scanner.prototype.__ks_func_toQuote_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_value_0: function() {
			return this._data.substring(this._index, this._nextIndex);
		},
		__ks_func_value_1: function(token) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(token === void 0 || token === null) {
				throw new TypeError("'token' is not nullable");
			}
			else if(!Type.is(token, Token)) {
				throw new TypeError("'token' is not of type 'Token'");
			}
			if(Type.isFunction(overhauls[token])) {
				return overhauls[token](this._data.substring(this._index, this._nextIndex));
			}
			else {
				return this._data.substring(this._index, this._nextIndex);
			}
		},
		value: function() {
			if(arguments.length === 0) {
				return Scanner.prototype.__ks_func_value_0.apply(this);
			}
			else if(arguments.length === 1) {
				return Scanner.prototype.__ks_func_value_1.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		}
	});
	var ExpressionMode = {
		Default: 0,
		NoAnonymousFunction: 1,
		NoAwait: 2,
		NoObject: 4,
		WithMacro: 8
	};
	var MacroTerminator = {
		COMMA: 0,
		NEWLINE: 1,
		RIGHT_CURLY: 2,
		RIGHT_ROUND: 4,
		RIGHT_SQUARE: 8
	};
	MacroTerminator.Array = MacroTerminator.COMMA | MacroTerminator.NEWLINE | MacroTerminator.RIGHT_SQUARE;
	MacroTerminator.List = MacroTerminator.COMMA | MacroTerminator.NEWLINE | MacroTerminator.RIGHT_ROUND;
	MacroTerminator.Object = MacroTerminator.COMMA | MacroTerminator.NEWLINE | MacroTerminator.RIGHT_CURLY;
	MacroTerminator.Parenthesis = MacroTerminator.NEWLINE | MacroTerminator.RIGHT_ROUND;
	var ParameterMode = {
		Function: 1,
		Macro: 2,
		Method: 3
	};
	var ParserMode = {
		Default: 0,
		MacroExpression: 1
	};
	var NO = {
		ok: false
	};
	var Parser = Helper.class({
		$name: "Parser",
		$create: function() {
			this.__ks_init();
			this.__ks_cons(arguments);
		},
		__ks_init_1: function() {
			this._history = [];
			this._mode = ParserMode.Default;
		},
		__ks_init: function() {
			Parser.prototype.__ks_init_1.call(this);
		},
		__ks_cons_0: function(data) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(data === void 0 || data === null) {
				throw new TypeError("'data' is not nullable");
			}
			else if(!Type.isString(data)) {
				throw new TypeError("'data' is not of type 'String'");
			}
			this._scanner = new Scanner(data);
		},
		__ks_cons: function(args) {
			if(args.length === 1) {
				Parser.prototype.__ks_cons_0.apply(this, args);
			}
			else {
				throw new SyntaxError("wrong number of arguments");
			}
		},
		__ks_func_commit_0: function() {
			this._token = this._scanner.commit();
			return this;
		},
		commit: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_commit_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_mark_0: function() {
			return this._scanner.mark();
		},
		mark: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_mark_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_match_0: function() {
			var tokens = Array.prototype.slice.call(arguments, 0, arguments.length);
			return this._token = this._scanner.match.apply(this._scanner, tokens);
		},
		match: function() {
			return Parser.prototype.__ks_func_match_0.apply(this, arguments);
		},
		__ks_func_matchM_0: function(matcher) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(matcher === void 0 || matcher === null) {
				throw new TypeError("'matcher' is not nullable");
			}
			else if(!Type.isFunction(matcher)) {
				throw new TypeError("'matcher' is not of type 'Function'");
			}
			return this._token = this._scanner.matchM(matcher);
		},
		matchM: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_matchM_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_position_0: function() {
			return this._scanner.position();
		},
		position: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_position_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_relocate_0: function(node, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(node === void 0 || node === null) {
				throw new TypeError("'node' is not nullable");
			}
			if(first === void 0) {
				first = null;
			}
			if(last === void 0) {
				last = null;
			}
			if(first !== null) {
				node.start = node.value.start = first.start;
			}
			if(last !== null) {
				node.end = node.value.end = last.end;
			}
			return node;
		},
		relocate: function() {
			if(arguments.length === 3) {
				return Parser.prototype.__ks_func_relocate_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_rollback_0: function(mark) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(mark === void 0 || mark === null) {
				throw new TypeError("'mark' is not nullable");
			}
			this._token = mark.token;
			return this._scanner.rollback(mark);
		},
		rollback: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_rollback_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_skipNewLine_0: function() {
			if(this._scanner.skipNewLine() === -1) {
				this._token = Token.EOF;
			}
			else {
				this._token = Token.INVALID;
			}
		},
		skipNewLine: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_skipNewLine_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_test_0: function(token) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(token === void 0 || token === null) {
				throw new TypeError("'token' is not nullable");
			}
			if(this._scanner.test(token)) {
				this._token = token;
				return true;
			}
			else {
				return false;
			}
		},
		test: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_test_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_testNS_0: function(token) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(token === void 0 || token === null) {
				throw new TypeError("'token' is not nullable");
			}
			if(this._scanner.testNS(token)) {
				this._token = token;
				return true;
			}
			else {
				return false;
			}
		},
		testNS: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_testNS_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_throw_0: function() {
			throw new SyntaxError("Unexpected " + this._scanner.toQuote() + " at line " + this._scanner.line() + " and column " + this._scanner.column());
		},
		__ks_func_throw_1: function(expected) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(expected === void 0 || expected === null) {
				throw new TypeError("'expected' is not nullable");
			}
			else if(!Type.isString(expected)) {
				throw new TypeError("'expected' is not of type 'String'");
			}
			throw new SyntaxError("Expecting \"" + expected + "\" but got " + this._scanner.toQuote() + " at line " + this._scanner.line() + " and column " + this._scanner.column());
		},
		__ks_func_throw_2: function(expecteds) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(expecteds === void 0 || expecteds === null) {
				throw new TypeError("'expecteds' is not nullable");
			}
			else if(!Type.isArray(expecteds)) {
				throw new TypeError("'expecteds' is not of type 'Array'");
			}
			throw new SyntaxError("Expecting \"" + expecteds.slice(0, expecteds.length - 1).join("\", \"") + "\" or \"" + expecteds[expecteds.length - 1] + "\" but got " + this._scanner.toQuote() + " at line " + this._scanner.line() + " and column " + this._scanner.column());
		},
		throw: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_throw_0.apply(this);
			}
			else if(arguments.length === 1) {
				if(Type.isString(arguments[0])) {
					return Parser.prototype.__ks_func_throw_1.apply(this, arguments);
				}
				else {
					return Parser.prototype.__ks_func_throw_2.apply(this, arguments);
				}
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_value_0: function() {
			return this._scanner.value(this._token);
		},
		value: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_value_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_yep_0: function() {
			var position = this._scanner.position();
			return {
				ok: true,
				start: position.start,
				end: position.end
			};
		},
		__ks_func_yep_1: function(value) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(value === void 0 || value === null) {
				throw new TypeError("'value' is not nullable");
			}
			return {
				ok: true,
				value: value,
				start: value.start,
				end: value.end
			};
		},
		__ks_func_yep_2: function(value, first, last) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(value === void 0 || value === null) {
				throw new TypeError("'value' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(last === void 0 || last === null) {
				throw new TypeError("'last' is not nullable");
			}
			return {
				ok: true,
				value: value,
				start: first.start,
				end: last.end
			};
		},
		yep: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_yep_0.apply(this);
			}
			else if(arguments.length === 1) {
				return Parser.prototype.__ks_func_yep_1.apply(this, arguments);
			}
			else if(arguments.length === 3) {
				return Parser.prototype.__ks_func_yep_2.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_yes_0: function() {
			var position = this._scanner.position();
			this.commit();
			return {
				ok: true,
				start: position.start,
				end: position.end
			};
		},
		__ks_func_yes_1: function(value) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(value === void 0 || value === null) {
				throw new TypeError("'value' is not nullable");
			}
			var start = Type.isValue(value.start) ? value.start : this._scanner.startPosition();
			var end = Type.isValue(value.end) ? value.end : this._scanner.endPosition();
			this.commit();
			return {
				ok: true,
				value: value,
				start: start,
				end: end
			};
		},
		yes: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_yes_0.apply(this);
			}
			else if(arguments.length === 1) {
				return Parser.prototype.__ks_func_yes_1.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_NL_0M_0: function() {
			this.skipNewLine();
		},
		NL_0M: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_NL_0M_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_altArrayComprehension_0: function(expression, first) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(expression === void 0 || expression === null) {
				throw new TypeError("'expression' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var loop = this.reqForExpression(this.yes());
			this.NL_0M();
			if(!this.test(Token.RIGHT_SQUARE)) {
				this.throw("]");
			}
			return this.yep(AST.ArrayComprehension(expression, loop, first, this.yes()));
		},
		altArrayComprehension: function() {
			if(arguments.length === 2) {
				return Parser.prototype.__ks_func_altArrayComprehension_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_altArrayList_0: function(expression, first) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(expression === void 0 || expression === null) {
				throw new TypeError("'expression' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var values = [expression];
			while(this.match(Token.RIGHT_SQUARE, Token.COMMA, Token.NEWLINE) !== null) {
				if(this._token === Token.RIGHT_SQUARE) {
					return this.yep(AST.ArrayExpression(values, first, this.yes()));
				}
				else if(this._token === Token.COMMA) {
					this.commit().NL_0M();
					values.push(this.reqExpression(null, MacroTerminator.Array));
				}
				else if(this._token === Token.NEWLINE) {
					this.commit().NL_0M();
					if(this.match(Token.RIGHT_SQUARE, Token.COMMA) === Token.COMMA) {
						this.commit().NL_0M();
						values.push(this.reqExpression(null, MacroTerminator.Array));
					}
					else if(this._token === Token.RIGHT_SQUARE) {
						return this.yep(AST.ArrayExpression(values, first, this.yes()));
					}
					else {
						values.push(this.reqExpression(null, MacroTerminator.Array));
					}
				}
				else {
					this.throw("]");
				}
			}
			this.throw("]");
		},
		altArrayList: function() {
			if(arguments.length === 2) {
				return Parser.prototype.__ks_func_altArrayList_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_altDestructuringObjectItem_0: function(name) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(name === void 0 || name === null) {
				throw new TypeError("'name' is not nullable");
			}
			if(this.match(Token.EQUALS, Token.COLON) === Token.EQUALS) {
				this.commit();
				var defaultValue = this.reqExpression(ExpressionMode.Default);
				return this.yep(AST.BindingElement(name, null, null, defaultValue, name, defaultValue));
			}
			else if(this._token === Token.COLON) {
				this.commit();
				var alias = this.reqVariableIdentifier();
				if(this.test(Token.EQUALS)) {
					this.commit();
					var defaultValue = this.reqExpression(ExpressionMode.Default);
					return this.yep(AST.BindingElement(alias, name, null, defaultValue, name, defaultValue));
				}
				else {
					return this.yep(AST.BindingElement(alias, name, null, null, name, alias));
				}
			}
			else {
				return this.yep(AST.BindingElement(name, null, null, null, name, name));
			}
		},
		altDestructuringObjectItem: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_altDestructuringObjectItem_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_altForExpressionFrom_0: function(declaration, variable, first) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(declaration === void 0 || declaration === null) {
				throw new TypeError("'declaration' is not nullable");
			}
			if(variable === void 0 || variable === null) {
				throw new TypeError("'variable' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			this.commit();
			var from = this.reqExpression(ExpressionMode.Default);
			var til, to;
			if(this.match(Token.TIL, Token.TO) === Token.TIL) {
				this.commit();
				til = this.reqExpression(ExpressionMode.Default);
			}
			else if(this._token === Token.TO) {
				this.commit();
				to = this.reqExpression(ExpressionMode.Default);
			}
			else {
				this.throw(["til", "to"]);
			}
			var by;
			if(this.test(Token.BY)) {
				this.commit();
				by = this.reqExpression(ExpressionMode.Default);
			}
			var until, __ks_while_1;
			if(this.match(Token.UNTIL, Token.WHILE) === Token.UNTIL) {
				this.commit();
				until = this.reqExpression(ExpressionMode.Default);
			}
			else if(this._token === Token.WHILE) {
				this.commit();
				__ks_while_1 = this.reqExpression(ExpressionMode.Default);
			}
			this.NL_0M();
			var whenExp;
			if(this.test(Token.WHEN)) {
				var __ks_first_1 = this.yes();
				whenExp = this.relocate(this.reqExpression(ExpressionMode.Default), __ks_first_1, null);
			}
			return this.yep(AST.ForFromStatement(declaration, variable, from, til, to, by, until, __ks_while_1, whenExp, first, Type.isValue(whenExp) ? whenExp : Type.isValue(__ks_while_1) ? __ks_while_1 : Type.isValue(until) ? until : Type.isValue(by) ? by : Type.isValue(to) ? to : Type.isValue(til) ? til : from));
		},
		altForExpressionFrom: function() {
			if(arguments.length === 3) {
				return Parser.prototype.__ks_func_altForExpressionFrom_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_altForExpressionIn_0: function(declaration, value, index, expression, first) {
			if(arguments.length < 5) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(declaration === void 0 || declaration === null) {
				throw new TypeError("'declaration' is not nullable");
			}
			if(value === void 0) {
				value = null;
			}
			if(index === void 0) {
				index = null;
			}
			if(expression === void 0 || expression === null) {
				throw new TypeError("'expression' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var desc = null;
			if(this.test(Token.DESC)) {
				desc = this.yes();
			}
			this.NL_0M();
			var from, til, to;
			if(this.test(Token.FROM)) {
				this.commit();
				from = this.reqExpression(ExpressionMode.Default);
			}
			if(this.match(Token.TIL, Token.TO) === Token.TIL) {
				this.commit();
				til = this.reqExpression(ExpressionMode.Default);
			}
			else if(this._token === Token.TO) {
				this.commit();
				to = this.reqExpression(ExpressionMode.Default);
			}
			this.NL_0M();
			var until, __ks_while_1;
			if(this.match(Token.UNTIL, Token.WHILE) === Token.UNTIL) {
				this.commit();
				until = this.reqExpression(ExpressionMode.Default);
			}
			else if(this._token === Token.WHILE) {
				this.commit();
				__ks_while_1 = this.reqExpression(ExpressionMode.Default);
			}
			this.NL_0M();
			var whenExp;
			if(this.test(Token.WHEN)) {
				var __ks_first_1 = this.yes();
				whenExp = this.relocate(this.reqExpression(ExpressionMode.Default), __ks_first_1, null);
			}
			return this.yep(AST.ForInStatement(declaration, value, index, expression, desc, from, til, to, until, __ks_while_1, whenExp, first, Type.isValue(whenExp) ? whenExp : Type.isValue(__ks_while_1) ? __ks_while_1 : Type.isValue(until) ? until : Type.isValue(to) ? to : Type.isValue(til) ? til : Type.isValue(from) ? from : Type.isValue(desc) ? desc : expression));
		},
		altForExpressionIn: function() {
			if(arguments.length === 5) {
				return Parser.prototype.__ks_func_altForExpressionIn_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_altForExpressionInRange_0: function(declaration, value, index, first) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(declaration === void 0 || declaration === null) {
				throw new TypeError("'declaration' is not nullable");
			}
			if(value === void 0) {
				value = null;
			}
			if(index === void 0) {
				index = null;
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			this.commit();
			var number1;
			if((number1 = this.tryNumber()).ok) {
				if(this.match(Token.DOT_DOT_DOT, Token.DOT_DOT) === Token.DOT_DOT_DOT) {
					this.commit();
					var number2 = this.reqNumber();
					if(this.test(Token.DOT_DOT)) {
						this.commit();
						return this.altForExpressionRange(declaration, value, index, number1, number2, null, this.reqNumber(), first);
					}
					else {
						return this.altForExpressionRange(declaration, value, index, number1, number2, null, null, first);
					}
				}
				else if(this._token === Token.DOT_DOT) {
					this.commit();
					var number2 = this.reqNumber();
					if(this.test(Token.DOT_DOT)) {
						this.commit();
						return this.altForExpressionRange(declaration, value, index, number1, null, number2, this.reqNumber(), first);
					}
					else {
						return this.altForExpressionRange(declaration, value, index, number1, null, number2, null, first);
					}
				}
				else {
					return this.altForExpressionIn(declaration, value, index, this.reqOperation(ExpressionMode.Default, number1), first);
				}
			}
			else {
				return this.altForExpressionIn(declaration, value, index, this.reqExpression(ExpressionMode.Default), first);
			}
		},
		altForExpressionInRange: function() {
			if(arguments.length === 4) {
				return Parser.prototype.__ks_func_altForExpressionInRange_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_altForExpressionOf_0: function(declaration, key, value, first) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(declaration === void 0 || declaration === null) {
				throw new TypeError("'declaration' is not nullable");
			}
			if(key === void 0) {
				key = null;
			}
			if(value === void 0) {
				value = null;
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			this.commit();
			var expression = this.reqExpression(ExpressionMode.Default);
			var until, __ks_while_1;
			if(this.match(Token.UNTIL, Token.WHILE) === Token.UNTIL) {
				this.commit();
				until = this.reqExpression(ExpressionMode.Default);
			}
			else if(this._token === Token.WHILE) {
				this.commit();
				__ks_while_1 = this.reqExpression(ExpressionMode.Default);
			}
			this.NL_0M();
			var whenExp;
			if(this.test(Token.WHEN)) {
				var __ks_first_1 = this.yes();
				whenExp = this.relocate(this.reqExpression(ExpressionMode.Default), __ks_first_1, null);
			}
			return this.yep(AST.ForOfStatement(declaration, key, value, expression, until, __ks_while_1, whenExp, first, Type.isValue(whenExp) ? whenExp : Type.isValue(__ks_while_1) ? __ks_while_1 : Type.isValue(until) ? until : expression));
		},
		altForExpressionOf: function() {
			if(arguments.length === 4) {
				return Parser.prototype.__ks_func_altForExpressionOf_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_altForExpressionRange_0: function(declaration, value, index, from, til, to, by, first) {
			if(arguments.length < 8) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 8)");
			}
			if(declaration === void 0 || declaration === null) {
				throw new TypeError("'declaration' is not nullable");
			}
			if(value === void 0 || value === null) {
				throw new TypeError("'value' is not nullable");
			}
			if(index === void 0) {
				index = null;
			}
			if(from === void 0 || from === null) {
				throw new TypeError("'from' is not nullable");
			}
			if(til === void 0) {
				til = null;
			}
			if(to === void 0) {
				to = null;
			}
			if(by === void 0) {
				by = null;
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var until, __ks_while_1;
			if(this.match(Token.UNTIL, Token.WHILE) === Token.UNTIL) {
				this.commit();
				until = this.reqExpression(ExpressionMode.Default);
			}
			else if(this._token === Token.WHILE) {
				this.commit();
				__ks_while_1 = this.reqExpression(ExpressionMode.Default);
			}
			this.NL_0M();
			var whenExp;
			if(this.test(Token.WHEN)) {
				var __ks_first_1 = this.yes();
				whenExp = this.relocate(this.reqExpression(ExpressionMode.Default), __ks_first_1, null);
			}
			return this.yep(AST.ForRangeStatement(declaration, value, index, from, til, to, by, until, __ks_while_1, whenExp, first, Type.isValue(whenExp) ? whenExp : Type.isValue(__ks_while_1) ? __ks_while_1 : Type.isValue(until) ? until : Type.isValue(by) ? by : Type.isValue(to) ? to : Type.isValue(til) ? til : from));
		},
		altForExpressionRange: function() {
			if(arguments.length === 8) {
				return Parser.prototype.__ks_func_altForExpressionRange_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_altLetStatementAwait_0: function(first, variables, equals) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(variables === void 0 || variables === null) {
				throw new TypeError("'variables' is not nullable");
			}
			if(equals === void 0 || equals === null) {
				throw new TypeError("'equals' is not nullable");
			}
			if(!this.test(Token.AWAIT)) {
				this.throw("await");
			}
			this.commit();
			var operand = this.reqPrefixedOperand(ExpressionMode.Default);
			return this.yep(AST.VariableDeclaration(variables, true, equals, true, operand, first, operand));
		},
		altLetStatementAwait: function() {
			if(arguments.length === 3) {
				return Parser.prototype.__ks_func_altLetStatementAwait_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_altLetStatementEquals_0: function(first, variables, equals) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(variables === void 0 || variables === null) {
				throw new TypeError("'variables' is not nullable");
			}
			if(equals === void 0 || equals === null) {
				throw new TypeError("'equals' is not nullable");
			}
			if(this.test(Token.AWAIT)) {
				this.commit();
				var operand = this.reqPrefixedOperand(ExpressionMode.Default);
				return this.yep(AST.VariableDeclaration(variables, true, equals, true, operand, first, operand));
			}
			else {
				var init = this.reqExpression(ExpressionMode.Default);
				if(this.match(Token.IF, Token.UNLESS) === Token.IF) {
					var __ks_first_1 = this.yes();
					var condition = this.reqExpression(ExpressionMode.Default);
					if(this.test(Token.ELSE)) {
						this.commit();
						var whenFalse = this.reqExpression(ExpressionMode.Default);
						init = this.yep(AST.IfExpression(condition, init, whenFalse, init, whenFalse));
					}
					else {
						init = this.yep(AST.IfExpression(condition, init, null, init, condition));
					}
				}
				else if(this._token === Token.UNLESS) {
					this.commit();
					var condition = this.reqExpression(ExpressionMode.Default);
					init = this.yep(AST.UnlessExpression(condition, init, init, condition));
				}
				var statement;
				return statement = this.yep(AST.VariableDeclaration(variables, true, equals, false, init, first, init));
			}
		},
		altLetStatementEquals: function() {
			if(arguments.length === 3) {
				return Parser.prototype.__ks_func_altLetStatementEquals_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqArray_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(this.test(Token.RIGHT_SQUARE)) {
				return this.yep(AST.ArrayExpression([], first, this.yes()));
			}
			var operand = this.tryPrefixedOperand(ExpressionMode.Default);
			if(operand.ok && ((this.match(Token.LEFT_ANGLE, Token.DOT_DOT) === Token.LEFT_ANGLE) || (this._token === Token.DOT_DOT))) {
				var then = this._token === Token.LEFT_ANGLE;
				if(then) {
					this.commit();
					if(!this.test(Token.DOT_DOT)) {
						this.throw("..");
					}
					this.commit();
				}
				else {
					this.commit();
				}
				var til = this.test(Token.LEFT_ANGLE);
				if(til) {
					this.commit();
				}
				var toOperand = this.reqPrefixedOperand(ExpressionMode.Default);
				var byOperand;
				if(this.test(Token.DOT_DOT)) {
					this.commit();
					byOperand = this.reqPrefixedOperand(ExpressionMode.Default);
				}
				if(!this.test(Token.RIGHT_SQUARE)) {
					this.throw("]");
				}
				if(then) {
					if(til) {
						return this.yep(AST.ArrayRangeTI(operand, toOperand, byOperand, first, this.yes()));
					}
					else {
						return this.yep(AST.ArrayRangeTO(operand, toOperand, byOperand, first, this.yes()));
					}
				}
				else {
					if(til) {
						return this.yep(AST.ArrayRangeFI(operand, toOperand, byOperand, first, this.yes()));
					}
					else {
						return this.yep(AST.ArrayRangeFO(operand, toOperand, byOperand, first, this.yes()));
					}
				}
			}
			else {
				var expression;
				if(operand.ok) {
					expression = this.reqOperation(ExpressionMode.Default, operand);
				}
				else {
					this.NL_0M();
					if(this.test(Token.RIGHT_SQUARE)) {
						return this.yep(AST.ArrayExpression([], first, this.yes()));
					}
					expression = this.reqExpression(null, MacroTerminator.Array);
				}
				if(this.match(Token.RIGHT_SQUARE, Token.FOR, Token.NEWLINE) === Token.RIGHT_SQUARE) {
					return this.yep(AST.ArrayExpression([expression], first, this.yes()));
				}
				else if(this._token === Token.FOR) {
					return this.altArrayComprehension(expression, first);
				}
				else if(this._token === Token.NEWLINE) {
					var mark = this.mark();
					this.commit().NL_0M();
					if(this.match(Token.RIGHT_SQUARE, Token.FOR) === Token.RIGHT_SQUARE) {
						return this.yep(AST.ArrayExpression([expression], first, this.yes()));
					}
					else if(this._token === Token.FOR) {
						return this.altArrayComprehension(expression, first);
					}
					else {
						this.rollback(mark);
						return this.altArrayList(expression, first);
					}
				}
				else {
					return this.altArrayList(expression, first);
				}
			}
		},
		reqArray: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqArray_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqAttribute_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var declaration = this.reqAttributeMember();
			if(!this.test(Token.RIGHT_SQUARE)) {
				this.throw("]");
			}
			var last = this.yes();
			if(!this.test(Token.NEWLINE)) {
				this.throw("NewLine");
			}
			this.commit();
			return this.yep(AST.AttributeDeclaration(declaration, first, last));
		},
		reqAttribute: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqAttribute_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqAttributeBlock_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var declaration = this.reqAttributeMember();
			if(!this.test(Token.RIGHT_SQUARE)) {
				this.throw("]");
			}
			var last = this.yes();
			this.reqNL_EOF_1M();
			return this.yep(AST.AttributeDeclaration(declaration, first, last));
		},
		reqAttributeBlock: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqAttributeBlock_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqAttributeList_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var attributes = [this.reqAttribute(first)];
			while(this.test(Token.HASH_LEFT_SQUARE)) {
				attributes.push(this.reqAttribute(this.yes()));
			}
			return this.yep(attributes);
		},
		reqAttributeList: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqAttributeList_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqAttributeMember_0: function() {
			var identifier = this.reqIdentifier();
			if(this.match(Token.MINUS, Token.EQUALS, Token.LEFT_ROUND) === Token.MINUS) {
				var plus;
				do {
					this.commit();
					plus = this.reqIdentifier();
					identifier.value.name += "-" + plus.value.name;
					identifier.value.end = identifier.end = plus.end;
				}
				while(this.test(Token.MINUS))
				return identifier;
			}
			else if(this._token === Token.EQUALS) {
				this.commit();
				var value = this.reqString();
				return this.yep(AST.AttributeOperation(identifier, value, identifier, value));
			}
			else if(this._token === Token.LEFT_ROUND) {
				this.commit();
				var __ks_arguments_1 = [this.reqAttributeMember()];
				while(this.test(Token.COMMA)) {
					this.commit();
					__ks_arguments_1.push(this.reqAttributeMember());
				}
				if(!this.test(Token.RIGHT_ROUND)) {
					this.throw(")");
				}
				return this.yep(AST.AttributeExpression(identifier, __ks_arguments_1, identifier, this.yes()));
			}
			else {
				return identifier;
			}
		},
		reqAttributeMember: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqAttributeMember_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqAwaitExpression_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var operand = this.reqPrefixedOperand(ExpressionMode.Default);
			return this.yep(AST.AwaitExpression(null, false, operand, first, operand));
		},
		reqAwaitExpression: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqAwaitExpression_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqBinaryOperand_0: function() {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			var __ks_i = -1;
			var mode = arguments[++__ks_i];
			if(mode === void 0 || mode === null) {
				throw new TypeError("'mode' is not nullable");
			}
			var __ks__;
			var operand = arguments.length > 1 && (__ks__ = arguments[++__ks_i]) !== void 0 ? __ks__ : null;
			if(operand === null) {
				var mark = this.mark();
				var expression;
				if((expression = this.tryFunctionExpression(mode)).ok) {
					return expression;
				}
				else if(this.rollback(mark) && (expression = this.trySwitchExpression(mode)).ok) {
					return expression;
				}
				this.rollback(mark);
			}
			operand = this.reqPrefixedOperand(mode, operand);
			var operator;
			var __ks_0 = this.matchM(M.TYPE_OPERATOR);
			if(__ks_0 === Token.AS) {
				operator = this.yep(AST.BinaryOperator(BinaryOperatorKind.TypeCasting, this.yes()));
			}
			else if(__ks_0 === Token.IS) {
				operator = this.yep(AST.BinaryOperator(BinaryOperatorKind.TypeEquality, this.yes()));
			}
			else if(__ks_0 === Token.IS_NOT) {
				operator = this.yep(AST.BinaryOperator(BinaryOperatorKind.TypeInequality, this.yes()));
			}
			else {
				return operand;
			}
			return this.yep(AST.BinaryExpression(operand, operator, this.reqTypeEntity(NO)));
		},
		reqBinaryOperand: function() {
			if(arguments.length >= 1 && arguments.length <= 2) {
				return Parser.prototype.__ks_func_reqBinaryOperand_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqBlock_0: function(first) {
			if(first === void 0 || first === null) {
				first = NO;
			}
			if(!first.ok) {
				if(!this.test(Token.LEFT_CURLY)) {
					this.throw("{");
				}
				first = this.yes();
			}
			this.NL_0M();
			var attributes = [];
			var statements = [];
			var statement, attrs;
			while((this.match(Token.RIGHT_CURLY, Token.HASH_EXCLAMATION_LEFT_SQUARE, Token.HASH_LEFT_SQUARE) !== Token.EOF) && (this._token !== Token.RIGHT_CURLY)) {
				if(this._token === Token.HASH_EXCLAMATION_LEFT_SQUARE) {
					attributes.push(this.reqAttributeBlock(this.yes()));
				}
				else {
					if(this._token === Token.HASH_LEFT_SQUARE) {
						attrs = this.reqAttributeList(this.yes());
					}
					else {
						attrs = null;
					}
					statements.push(statement = this.reqStatement());
					if(attrs === null) {
						statement.value.attributes = [];
					}
					else {
						statement.value.attributes = Helper.mapArray(attrs.value, function(attr) {
							return attr.value;
						});
						statement.value.start = statement.start = statement.value.attributes[0].start;
					}
				}
				this.NL_0M();
			}
			if(!this.test(Token.RIGHT_CURLY)) {
				this.throw("}");
			}
			return this.yep(AST.Block(attributes, statements, first, this.yes()));
		},
		reqBlock: function() {
			if(arguments.length >= 0 && arguments.length <= 1) {
				return Parser.prototype.__ks_func_reqBlock_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqBreakStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			return this.yep(AST.BreakStatement(first));
		},
		reqBreakStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqBreakStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqCatchOnClause_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var type = this.reqIdentifier();
			var binding;
			if(this.test(Token.CATCH)) {
				this.commit();
				binding = this.reqIdentifier();
			}
			this.NL_0M();
			var body = this.reqBlock();
			return this.yep(AST.CatchClause(binding, type, body, first, body));
		},
		reqCatchOnClause: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqCatchOnClause_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqClassAbstractMethod_0: function(attributes, modifiers, first) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(attributes === void 0) {
				attributes = null;
			}
			if(modifiers === void 0 || modifiers === null) {
				throw new TypeError("'modifiers' is not nullable");
			}
			if(first === void 0) {
				first = null;
			}
			return this.reqClassAbstractMethodBody(attributes, modifiers, this.reqNameIST.bind(this), first);
		},
		reqClassAbstractMethod: function() {
			if(arguments.length === 3) {
				return Parser.prototype.__ks_func_reqClassAbstractMethod_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqClassAbstractMethodBody_0: function(attributes, modifiers, name, first) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(attributes === void 0) {
				attributes = null;
			}
			if(modifiers === void 0 || modifiers === null) {
				throw new TypeError("'modifiers' is not nullable");
			}
			if(name === void 0 || name === null) {
				throw new TypeError("'name' is not nullable");
			}
			if(first === void 0) {
				first = null;
			}
			var parameters = this.reqClassMethodParameterList();
			var mods = this.reqFunctionModifiers();
			var type = this.reqFunctionReturns();
			var __ks_throws_1 = this.reqFunctionThrows();
			this.reqNL_1M();
			if(mods !== null) {
				modifiers = [].concat(modifiers, mods.value);
			}
			return this.yep(AST.MethodDeclaration(attributes, modifiers, name, parameters, type, __ks_throws_1, null, first, Type.isValue(__ks_throws_1) ? __ks_throws_1 : Type.isValue(type) ? type : Type.isValue(mods) ? mods : parameters));
		},
		reqClassAbstractMethodBody: function() {
			if(arguments.length === 4) {
				return Parser.prototype.__ks_func_reqClassAbstractMethodBody_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqClassField_0: function(attributes, modifiers, name, type, first) {
			if(arguments.length < 5) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(attributes === void 0) {
				attributes = null;
			}
			if(modifiers === void 0 || modifiers === null) {
				throw new TypeError("'modifiers' is not nullable");
			}
			if(name === void 0 || name === null) {
				throw new TypeError("'name' is not nullable");
			}
			if(type === void 0) {
				type = null;
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var defaultValue;
			if(this.test(Token.EQUALS)) {
				this.commit();
				defaultValue = this.reqExpression(ExpressionMode.Default);
			}
			this.reqNL_1M();
			return this.yep(AST.FieldDeclaration(attributes, modifiers, name, type, defaultValue, first, Type.isValue(defaultValue) ? defaultValue : Type.isValue(type) ? type : name));
		},
		reqClassField: function() {
			if(arguments.length === 5) {
				return Parser.prototype.__ks_func_reqClassField_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqClassMember_0: function(attributes, modifiers, first) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(attributes === void 0) {
				attributes = null;
			}
			if(modifiers === void 0 || modifiers === null) {
				throw new TypeError("'modifiers' is not nullable");
			}
			if(first === void 0) {
				first = null;
			}
			return this.reqClassMemberBody(attributes, modifiers, this.reqNameIST(), first);
		},
		reqClassMember: function() {
			if(arguments.length === 3) {
				return Parser.prototype.__ks_func_reqClassMember_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqClassMemberBody_0: function(attributes, modifiers, name, first) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(attributes === void 0) {
				attributes = null;
			}
			if(modifiers === void 0 || modifiers === null) {
				throw new TypeError("'modifiers' is not nullable");
			}
			if(name === void 0 || name === null) {
				throw new TypeError("'name' is not nullable");
			}
			if(first === void 0) {
				first = null;
			}
			if(this.match(Token.COLON, Token.LEFT_CURLY, Token.LEFT_ROUND) === Token.COLON) {
				this.commit();
				var type = this.reqTypeVar();
				if(this.test(Token.LEFT_CURLY)) {
					this.commit();
					return this.reqClassProperty(attributes, modifiers, name, type, Type.isValue(first) ? first : name);
				}
				else {
					return this.reqClassField(attributes, modifiers, name, type, Type.isValue(first) ? first : name);
				}
			}
			else if(this._token === Token.LEFT_CURLY) {
				this.commit();
				return this.reqClassProperty(attributes, modifiers, name, null, Type.isValue(first) ? first : name);
			}
			else if(this._token === Token.LEFT_ROUND) {
				return this.reqClassMethod(attributes, modifiers, name, this.yes(), Type.isValue(first) ? first : name);
			}
			else {
				return this.reqClassField(attributes, modifiers, name, null, Type.isValue(first) ? first : name);
			}
		},
		reqClassMemberBody: function() {
			if(arguments.length === 4) {
				return Parser.prototype.__ks_func_reqClassMemberBody_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqClassMemberList_0: function(members) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(members === void 0 || members === null) {
				throw new TypeError("'members' is not nullable");
			}
			var first = null;
			var attributes = null;
			if(this.test(Token.HASH_LEFT_SQUARE)) {
				attributes = this.reqAttributeList(first = this.yes());
			}
			var mark1 = this.mark();
			if(this.test(Token.MACRO)) {
				first = this.yes();
				if(this.test(Token.IDENTIFIER)) {
					var statement = this.tryMacroStatement(first);
					if(statement.ok) {
						this.reqNL_1M();
						if(attributes === null) {
							statement.attributes = [];
						}
						else {
							statement.attributes = attributes;
						}
						members.push(statement);
						return;
					}
				}
				this.rollback(mark1);
				first = null;
			}
			var modifiers = [];
			if(this.match(Token.PRIVATE, Token.PROTECTED, Token.PUBLIC) === Token.PRIVATE) {
				modifiers.push(this.yep(AST.Modifier(ModifierKind.Private, this.yes())));
			}
			else if(this._token === Token.PROTECTED) {
				modifiers.push(this.yep(AST.Modifier(ModifierKind.Protected, this.yes())));
			}
			else if(this._token === Token.PUBLIC) {
				modifiers.push(this.yep(AST.Modifier(ModifierKind.Public, this.yes())));
			}
			var mark2 = this.mark();
			if(this.test(Token.ABSTRACT)) {
				modifiers.push(this.yep(AST.Modifier(ModifierKind.Abstract, this.yes())));
				if((first === null) && (modifiers.length !== 0)) {
					first = modifiers[0];
				}
				if(this.test(Token.LEFT_CURLY)) {
					if(first === null) {
						first = this.yes();
					}
					else {
						this.commit();
					}
					this.NL_0M();
					var attrs;
					while(!(this.test(Token.RIGHT_CURLY))) {
						if(this.test(Token.HASH_LEFT_SQUARE)) {
							attrs = this.reqAttributeList(first = this.yes());
							if(attributes !== null) {
								attrs.value = [].concat(attributes.value, attrs.value);
							}
						}
						else {
							attrs = attributes;
							first = null;
						}
						members.push(this.reqClassAbstractMethod(attrs, modifiers, first));
					}
					if(!this.test(Token.RIGHT_CURLY)) {
						this.throw("}");
					}
					this.commit();
					this.reqNL_1M();
				}
				else {
					var member = this.tryClassAbstractMethod(attributes, modifiers, first);
					if(member.ok) {
						members.push(member);
					}
					else {
						this.rollback(mark2);
						modifiers.pop();
						members.push(this.reqClassMember(attributes, modifiers, first));
					}
				}
			}
			else {
				if(this.test(Token.STATIC)) {
					modifiers.push(this.yep(AST.Modifier(ModifierKind.Static, this.yes())));
				}
				if((first === null) && (modifiers.length !== 0)) {
					first = modifiers[0];
				}
				if(this.test(Token.LEFT_CURLY)) {
					if(first === null) {
						first = this.yes();
					}
					else {
						this.commit();
					}
					this.NL_0M();
					var attrs;
					while(!(this.test(Token.RIGHT_CURLY))) {
						if(this.test(Token.HASH_LEFT_SQUARE)) {
							attrs = this.reqAttributeList(first = this.yes());
							if(attributes !== null) {
								attrs.value = [].concat(attributes.value, attrs.value);
							}
						}
						else {
							attrs = attributes;
							first = null;
						}
						members.push(this.reqClassMember(attrs, modifiers, first));
					}
					if(!this.test(Token.RIGHT_CURLY)) {
						this.throw("}");
					}
					this.commit();
					this.reqNL_1M();
				}
				else {
					var member = this.tryClassMember(attributes, modifiers, first);
					if(member.ok) {
						members.push(member);
					}
					else {
						if(modifiers.length === 2) {
							this.rollback(mark2);
						}
						else {
							this.rollback(mark1);
						}
						modifiers.pop();
						members.push(this.reqClassMember(attributes, modifiers, first));
					}
				}
			}
		},
		reqClassMemberList: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqClassMemberList_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqClassMethod_0: function(attributes, modifiers, name, round, first) {
			if(arguments.length < 5) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(attributes === void 0) {
				attributes = null;
			}
			if(modifiers === void 0 || modifiers === null) {
				throw new TypeError("'modifiers' is not nullable");
			}
			if(name === void 0 || name === null) {
				throw new TypeError("'name' is not nullable");
			}
			if(round === void 0 || round === null) {
				throw new TypeError("'round' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var parameters = this.reqClassMethodParameterList(round);
			if(this.test(Token.NEWLINE)) {
				this.commit().NL_0M();
				return this.yep(AST.MethodDeclaration(attributes, modifiers, name, parameters, null, null, null, first, parameters));
			}
			else {
				var mods = this.reqFunctionModifiers();
				var type = this.reqFunctionReturns();
				var __ks_throws_1 = this.reqFunctionThrows();
				var body = this.reqFunctionBody();
				this.reqNL_1M();
				if(mods !== null) {
					modifiers = [].concat(modifiers, mods.value);
				}
				return this.yep(AST.MethodDeclaration(attributes, modifiers, name, parameters, type, __ks_throws_1, body, first, body));
			}
		},
		reqClassMethod: function() {
			if(arguments.length === 5) {
				return Parser.prototype.__ks_func_reqClassMethod_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqClassMethodParameterList_0: function(top) {
			if(top === void 0 || top === null) {
				top = NO;
			}
			if(!top.ok) {
				if(!this.test(Token.LEFT_ROUND)) {
					this.throw("(");
				}
				top = this.yes();
			}
			var parameters = [];
			if(!this.test(Token.RIGHT_ROUND)) {
				while(this.reqParameter(parameters, ParameterMode.Method)) {
				}
			}
			if(!this.test(Token.RIGHT_ROUND)) {
				this.throw(")");
			}
			return this.yep(parameters, top, this.yes());
		},
		reqClassMethodParameterList: function() {
			if(arguments.length >= 0 && arguments.length <= 1) {
				return Parser.prototype.__ks_func_reqClassMethodParameterList_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqClassProperty_0: function(attributes, modifiers, name, type, first) {
			if(arguments.length < 5) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 5)");
			}
			if(attributes === void 0) {
				attributes = null;
			}
			if(modifiers === void 0 || modifiers === null) {
				throw new TypeError("'modifiers' is not nullable");
			}
			if(name === void 0 || name === null) {
				throw new TypeError("'name' is not nullable");
			}
			if(type === void 0) {
				type = null;
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var defaultValue, accessor, mutator;
			if(this.test(Token.NEWLINE)) {
				this.commit().NL_0M();
				if(this.match(Token.GET, Token.SET) === Token.GET) {
					var __ks_first_1 = this.yes();
					if(this.match(Token.EQUALS_RIGHT_ANGLE, Token.LEFT_CURLY) === Token.EQUALS_RIGHT_ANGLE) {
						this.commit();
						var expression = this.reqExpression(ExpressionMode.Default);
						accessor = this.yep(AST.AccessorDeclaration(expression, __ks_first_1, expression));
					}
					else if(this._token === Token.LEFT_CURLY) {
						var block = this.reqBlock();
						accessor = this.yep(AST.AccessorDeclaration(block, __ks_first_1, block));
					}
					else {
						accessor = this.yep(AST.AccessorDeclaration(__ks_first_1));
					}
					this.reqNL_1M();
					if(this.test(Token.SET)) {
						var __ks_first_2 = this.yes();
						if(this.match(Token.EQUALS_RIGHT_ANGLE, Token.LEFT_CURLY) === Token.EQUALS_RIGHT_ANGLE) {
							this.commit();
							var expression = this.reqExpression(ExpressionMode.Default);
							mutator = this.yep(AST.MutatorDeclaration(expression, __ks_first_2, expression));
						}
						else if(this._token === Token.LEFT_CURLY) {
							var block = this.reqBlock();
							mutator = this.yep(AST.MutatorDeclaration(block, __ks_first_2, block));
						}
						else {
							mutator = this.yep(AST.MutatorDeclaration(__ks_first_2));
						}
						this.reqNL_1M();
					}
				}
				else if(this._token === Token.SET) {
					var __ks_first_3 = this.yes();
					if(this.match(Token.EQUALS_RIGHT_ANGLE, Token.LEFT_CURLY) === Token.EQUALS_RIGHT_ANGLE) {
						this.commit();
						var expression = this.reqExpression(ExpressionMode.Default);
						mutator = this.yep(AST.MutatorDeclaration(expression, __ks_first_3, expression));
					}
					else if(this._token === Token.LEFT_CURLY) {
						var block = this.reqBlock();
						mutator = this.yep(AST.MutatorDeclaration(block, __ks_first_3, block));
					}
					else {
						mutator = this.yep(AST.MutatorDeclaration(__ks_first_3));
					}
					this.reqNL_1M();
				}
				else {
					this.throw(["get", "set"]);
				}
			}
			else {
				if(this.match(Token.GET, Token.SET) === Token.GET) {
					accessor = this.yep(AST.AccessorDeclaration(this.yes()));
					if(this.test(Token.COMMA)) {
						this.commit();
						if(this.test(Token.SET)) {
							mutator = this.yep(AST.MutatorDeclaration(this.yes()));
						}
						else {
							this.throw("set");
						}
					}
				}
				else if(this._token === Token.SET) {
					mutator = this.yep(AST.MutatorDeclaration(this.yes()));
				}
				else {
					this.throw(["get", "set"]);
				}
			}
			if(!this.test(Token.RIGHT_CURLY)) {
				this.throw("}");
			}
			var last = this.yes();
			if(this.test(Token.EQUALS)) {
				this.commit();
				defaultValue = this.reqExpression(ExpressionMode.Default);
			}
			this.reqNL_1M();
			return this.yep(AST.PropertyDeclaration(attributes, modifiers, name, type, defaultValue, accessor, mutator, first, Type.isValue(defaultValue) ? defaultValue : last));
		},
		reqClassProperty: function() {
			if(arguments.length === 5) {
				return Parser.prototype.__ks_func_reqClassProperty_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqClassStatement_0: function() {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			var __ks_i = -1;
			var first = arguments[++__ks_i];
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var __ks__;
			var modifiers = arguments.length > 1 && (__ks__ = arguments[++__ks_i]) !== void 0 && __ks__ !== null ? __ks__ : [];
			return this.reqClassStatementBody(this.reqIdentifier(), first, modifiers);
		},
		reqClassStatement: function() {
			if(arguments.length >= 1 && arguments.length <= 2) {
				return Parser.prototype.__ks_func_reqClassStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqClassStatementBody_0: function() {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			var __ks_i = -1;
			var name = arguments[++__ks_i];
			if(name === void 0 || name === null) {
				throw new TypeError("'name' is not nullable");
			}
			var first = arguments[++__ks_i];
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var __ks__;
			var modifiers = arguments.length > 2 && (__ks__ = arguments[++__ks_i]) !== void 0 && __ks__ !== null ? __ks__ : [];
			var generic;
			if(this.test(Token.LEFT_ANGLE)) {
				generic = this.reqTypeGeneric(this.yes());
			}
			var version;
			if(this.test(Token.AT)) {
				this.commit();
				if(!this.test(Token.CLASS_VERSION)) {
					this.throw("Class Version");
				}
				var data = this.value();
				version = this.yes({
					major: data[0],
					minor: (data.length > 1) ? data[1] : 0,
					patch: (data.length > 2) ? data[2] : 0
				});
				version.value.start = version.start;
				version.value.end = version.end;
			}
			var __ks_extends_1;
			if(this.test(Token.EXTENDS)) {
				this.commit();
				__ks_extends_1 = this.reqIdentifier();
				if(this.testNS(Token.DOT)) {
					var property;
					do {
						this.commit();
						property = this.reqIdentifier();
						__ks_extends_1 = this.yep(AST.MemberExpression(__ks_extends_1, property, false, false));
					}
					while(this.testNS(Token.DOT))
				}
			}
			if(!this.test(Token.LEFT_CURLY)) {
				this.throw("{");
			}
			this.commit().NL_0M();
			var members = [];
			while(!(this.test(Token.RIGHT_CURLY))) {
				this.reqClassMemberList(members);
			}
			if(!this.test(Token.RIGHT_CURLY)) {
				this.throw("}");
			}
			return this.yep(AST.ClassDeclaration(name, version, __ks_extends_1, modifiers, members, first, this.yes()));
		},
		reqClassStatementBody: function() {
			if(arguments.length >= 2 && arguments.length <= 3) {
				return Parser.prototype.__ks_func_reqClassStatementBody_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqConstStatement_0: function() {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			var __ks_i = -1;
			var first = arguments[++__ks_i];
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var __ks__;
			var mode = arguments.length > 1 && (__ks__ = arguments[++__ks_i]) !== void 0 && __ks__ !== null ? __ks__ : ExpressionMode.Default;
			var variable = this.reqTypedVariable();
			if(this.test(Token.COMMA)) {
				var variables = [variable];
				do {
					this.commit();
					variables.push(this.reqTypedVariable());
				}
				while(this.test(Token.COMMA))
				var equals = this.reqVariableEquals();
				if(!this.test(Token.AWAIT)) {
					this.throw("await");
				}
				this.commit();
				var operand = this.reqPrefixedOperand(mode);
				return this.yep(AST.VariableDeclaration(variables, false, equals, true, operand, first, operand));
			}
			else {
				var equals = this.reqVariableEquals();
				if(this.test(Token.AWAIT)) {
					this.commit();
					var operand = this.reqPrefixedOperand(mode);
					return this.yep(AST.VariableDeclaration([variable], false, equals, true, operand, first, operand));
				}
				else {
					var expression = this.reqExpression(mode);
					return this.yep(AST.VariableDeclaration([variable], false, equals, false, expression, first, expression));
				}
			}
		},
		reqConstStatement: function() {
			if(arguments.length >= 1 && arguments.length <= 2) {
				return Parser.prototype.__ks_func_reqConstStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqContinueStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			return this.yep(AST.ContinueStatement(first));
		},
		reqContinueStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqContinueStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqCreateExpression_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var __ks_class_1, last;
			if(this.match(Token.IDENTIFIER, Token.LEFT_ROUND, Token.AT) === Token.IDENTIFIER) {
				__ks_class_1 = this.reqIdentifier();
				while(this.test(Token.DOT)) {
					this.commit();
					var property = this.reqIdentifier();
					__ks_class_1 = this.yep(AST.MemberExpression(__ks_class_1, property, false, false));
				}
				if(this.match(Token.LEFT_ANGLE, Token.LEFT_SQUARE) === Token.LEFT_ANGLE) {
					var generic = this.reqTypeGeneric(this.yes());
					__ks_class_1 = this.yep(AST.TypeReference(__ks_class_1, generic, null, __ks_class_1, generic));
				}
				else if(this._token === Token.LEFT_SQUARE) {
					var reference = false;
					__ks_class_1 = this.reqVariableName(__ks_class_1);
				}
			}
			else if(this._token === Token.LEFT_ROUND) {
				this.commit();
				__ks_class_1 = this.reqExpression(ExpressionMode.Default);
				if(!this.test(Token.RIGHT_ROUND)) {
					this.throw(")");
				}
				last = this.yes();
			}
			else if(this._token === Token.AT) {
				__ks_class_1 = this.reqThisExpression(this.yes());
			}
			else {
				this.throw(["Identifier", "("]);
			}
			if(this.test(Token.LEFT_ROUND)) {
				this.commit();
				return this.yep(AST.CreateExpression(__ks_class_1, this.reqExpression0CNList(), first, this.yes()));
			}
			else {
				return this.yep(AST.CreateExpression(__ks_class_1, this.yep([]), first, last));
			}
		},
		reqCreateExpression: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqCreateExpression_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqDestructuringArray_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			this.NL_0M();
			var elements = [];
			while(true) {
				elements.push(this.reqDestructuringArrayItem());
				if((this.match(Token.COMMA, Token.NEWLINE) === Token.COMMA) || (this._token === Token.NEWLINE)) {
					this.commit().NL_0M();
				}
				else {
					break;
				}
				if(this.test(Token.RIGHT_SQUARE)) {
					break;
				}
			}
			if(!this.test(Token.RIGHT_SQUARE)) {
				this.throw("]");
			}
			return this.yep(AST.ArrayBinding(elements, first, this.yes()));
		},
		reqDestructuringArray: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqDestructuringArray_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqDestructuringArrayItem_0: function() {
			var spread, name, defaultValue;
			if(this.test(Token.DOT_DOT_DOT)) {
				spread = this.yes();
				if(this.test(Token.IDENTIFIER)) {
					name = this.yep(AST.Identifier(this._scanner.value(), this.yes()));
					if(this.test(Token.EQUALS)) {
						this.commit();
						defaultValue = this.reqExpression(ExpressionMode.Default);
					}
					return this.yep(AST.BindingElement(name, null, spread, defaultValue, spread, Type.isValue(defaultValue) ? defaultValue : name));
				}
				else {
					return this.yep(AST.OmittedExpression(true, spread));
				}
			}
			else {
				if(this.match(Token.LEFT_CURLY, Token.LEFT_SQUARE, Token.IDENTIFIER) === Token.LEFT_CURLY) {
					name = this.reqDestructuringObject(this.yes());
				}
				else if(this._token === Token.LEFT_SQUARE) {
					name = this.reqDestructuringArray(this.yes());
				}
				else if(this._token === Token.IDENTIFIER) {
					name = this.yep(AST.Identifier(this._scanner.value(), this.yes()));
				}
				else {
					return this.yep(AST.OmittedExpression(false, this.yep()));
				}
				if(this.test(Token.EQUALS)) {
					this.commit();
					defaultValue = this.reqExpression(ExpressionMode.Default);
				}
				return this.yep(AST.BindingElement(name, null, spread, defaultValue, name, Type.isValue(defaultValue) ? defaultValue : name));
			}
		},
		reqDestructuringArrayItem: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqDestructuringArrayItem_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqDestructuringObject_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			this.NL_0M();
			var elements = [];
			while(true) {
				elements.push(this.reqDestructuringObjectItem());
				if((this.match(Token.COMMA, Token.NEWLINE) === Token.COMMA) || (this._token === Token.NEWLINE)) {
					this.commit().NL_0M();
				}
				else {
					break;
				}
				if(this.test(Token.RIGHT_CURLY)) {
					break;
				}
			}
			if(!this.test(Token.RIGHT_CURLY)) {
				this.throw("}");
			}
			return this.yep(AST.ObjectBinding(elements, first, this.yes()));
		},
		reqDestructuringObject: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqDestructuringObject_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqDestructuringObjectItem_0: function() {
			if(this.match(Token.LEFT_CURLY, Token.LEFT_SQUARE, Token.IDENTIFIER) === Token.LEFT_CURLY) {
				return this.yep(AST.BindingElement(this.reqDestructuringObject(this.yes())));
			}
			else if(this._token === Token.LEFT_SQUARE) {
				var square = this.yes();
				if(this.test(Token.IDENTIFIER)) {
					var identifier = this.yep(AST.Identifier(this._scanner.value(), this.yes()));
					if(this.test(Token.RIGHT_SQUARE)) {
						identifier.value.computed = true;
						this.relocate(identifier, square, this.yes());
						return this.altDestructuringObjectItem(identifier);
					}
					else {
						return this.yep(AST.BindingElement(this.reqDestructuringArray(square, identifier)));
					}
				}
				else {
					return this.yep(AST.BindingElement(this.reqDestructuringArray(square)));
				}
			}
			else if(this._token === Token.IDENTIFIER) {
				return this.altDestructuringObjectItem(this.yep(AST.Identifier(this._scanner.value(), this.yes())));
			}
			else {
				this.throw(["Identifier", "{", "["]);
			}
		},
		reqDestructuringObjectItem: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqDestructuringObjectItem_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqDoStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			this.NL_0M();
			var body = this.reqBlock();
			this.reqNL_1M();
			if(this.match(Token.UNTIL, Token.WHILE) === Token.UNTIL) {
				this.commit();
				var condition = this.reqExpression(ExpressionMode.Default);
				return this.yep(AST.DoUntilStatement(condition, body, first, condition));
			}
			else if(this._token === Token.WHILE) {
				this.commit();
				var condition = this.reqExpression(ExpressionMode.Default);
				return this.yep(AST.DoWhileStatement(condition, body, first, condition));
			}
			else {
				this.throw(["until", "while"]);
			}
		},
		reqDoStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqDoStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqEnumStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var name = this.reqIdentifier();
			var type;
			if(this.test(Token.LEFT_ANGLE)) {
				this.commit();
				type = this.reqTypeEntity(NO);
				if(!this.test(Token.RIGHT_ANGLE)) {
					this.throw(">");
				}
				this.commit();
			}
			if(!this.test(Token.LEFT_CURLY)) {
				this.throw("{");
			}
			this.commit();
			this.NL_0M();
			var members = [];
			var identifier;
			while(!(this.test(Token.RIGHT_CURLY))) {
				identifier = this.reqIdentifier();
				if(this.test(Token.EQUALS)) {
					this.commit();
					members.push(AST.EnumMember(identifier, this.reqExpression(ExpressionMode.Default)));
				}
				else {
					members.push(AST.EnumMember(identifier));
				}
				if(this.test(Token.COMMA)) {
					this.commit().NL_0M();
				}
				else if(this.test(Token.NEWLINE)) {
					this.commit().NL_0M();
					if(this.test(Token.COMMA)) {
						this.commit().NL_0M();
					}
				}
				else {
					break;
				}
			}
			if(!this.test(Token.RIGHT_CURLY)) {
				this.throw("}");
			}
			return this.yep(AST.EnumDeclaration(name, type, members, first, this.yes()));
		},
		reqEnumStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqEnumStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqExportDeclarator_0: function() {
			var __ks_0 = this.matchM(M.EXPORT_STATEMENT);
			if(__ks_0 === Token.ABSTRACT) {
				var first = this.yes();
				if(this.test(Token.CLASS)) {
					this.commit();
					var modifiers = [this.yep(AST.Modifier(ModifierKind.Abstract, first))];
					return this.yep(AST.ExportDeclarationSpecifier(this.reqClassStatement(first, modifiers)));
				}
				else {
					this.throw("class");
				}
			}
			else if(__ks_0 === Token.CLASS) {
				return this.yep(AST.ExportDeclarationSpecifier(this.reqClassStatement(this.yes())));
			}
			else if(__ks_0 === Token.CONST) {
				return this.yep(AST.ExportDeclarationSpecifier(this.reqConstStatement(this.yes(), ExpressionMode.NoAwait)));
			}
			else if(__ks_0 === Token.IDENTIFIER) {
				var value = this.reqIdentifier();
				var identifier = null;
				if(this.testNS(Token.DOT)) {
					do {
						this.commit();
						if(this.testNS(Token.ASTERISK)) {
							return this.yep(AST.ExportWildcardSpecifier(value, this.yes()));
						}
						else {
							identifier = this.reqIdentifier();
							value = this.yep(AST.MemberExpression(value, identifier, false, false));
						}
					}
					while(this.testNS(Token.DOT))
				}
				if(this.test(Token.EQUALS_RIGHT_ANGLE)) {
					this.commit();
					return this.yep(AST.ExportNamedSpecifier(value, this.reqIdentifier()));
				}
				else if(this.test(Token.FOR)) {
					this.commit();
					if(this.test(Token.ASTERISK)) {
						return this.yep(AST.ExportWildcardSpecifier(value, this.yes()));
					}
					else if(this.test(Token.LEFT_CURLY)) {
						var members = [];
						this.commit().NL_0M();
						while(!(this.test(Token.RIGHT_CURLY))) {
							identifier = this.reqIdentifier();
							if(this.test(Token.EQUALS_RIGHT_ANGLE)) {
								this.commit();
								members.push(AST.ExportNamedSpecifier(identifier, this.reqIdentifier()));
							}
							else {
								members.push(AST.ExportNamedSpecifier(identifier, identifier));
							}
							if(this.test(Token.COMMA)) {
								this.commit();
							}
							this.reqNL_1M();
						}
						if(!this.test(Token.RIGHT_CURLY)) {
							this.throw("}");
						}
						return this.yep(AST.ExportPropertiesSpecifier(value, members, this.yes()));
					}
					else {
						var members = [];
						identifier = this.reqIdentifier();
						if(this.test(Token.EQUALS_RIGHT_ANGLE)) {
							this.commit();
							members.push(AST.ExportNamedSpecifier(identifier, this.reqIdentifier()));
						}
						else {
							members.push(AST.ExportNamedSpecifier(identifier, identifier));
						}
						while(this.test(Token.COMMA)) {
							this.commit();
							identifier = this.reqIdentifier();
							if(this.test(Token.EQUALS_RIGHT_ANGLE)) {
								this.commit();
								members.push(AST.ExportNamedSpecifier(identifier, this.reqIdentifier()));
							}
							else {
								members.push(AST.ExportNamedSpecifier(identifier, identifier));
							}
						}
						return this.yep(AST.ExportPropertiesSpecifier(value, members, this.yep()));
					}
				}
				else {
					return this.yep(AST.ExportNamedSpecifier(value, Type.isValue(identifier) ? identifier : value));
				}
			}
			else if(__ks_0 === Token.ENUM) {
				return this.yep(AST.ExportDeclarationSpecifier(this.reqEnumStatement(this.yes())));
			}
			else if(__ks_0 === Token.FUNC) {
				return this.yep(AST.ExportDeclarationSpecifier(this.reqFunctionStatement(this.yes())));
			}
			else if(__ks_0 === Token.LET) {
				return this.yep(AST.ExportDeclarationSpecifier(this.reqLetStatement(this.yes(), ExpressionMode.NoAwait)));
			}
			else if(__ks_0 === Token.NAMESPACE) {
				return this.yep(AST.ExportDeclarationSpecifier(this.reqNamespaceStatement(this.yes())));
			}
			else if(__ks_0 === Token.SEALED) {
				var first = this.yes();
				var modifiers = [this.yep(AST.Modifier(ModifierKind.Sealed, first))];
				if(this.test(Token.CLASS)) {
					this.commit();
					return this.yep(AST.ExportDeclarationSpecifier(this.reqClassStatement(first, modifiers)));
				}
				else if(this.test(Token.ABSTRACT)) {
					modifiers.push(this.yep(AST.Modifier(ModifierKind.Abstract, this.yes())));
					if(this.test(Token.CLASS)) {
						this.commit();
						return this.yep(AST.ExportDeclarationSpecifier(this.reqClassStatement(first, modifiers)));
					}
					else {
						this.throw("class");
					}
				}
				else {
					this.throw("class");
				}
			}
			else if(__ks_0 === Token.TYPE) {
				return this.yep(AST.ExportDeclarationSpecifier(this.reqTypeStatement(this.yes())));
			}
			else {
				this.throw();
			}
		},
		reqExportDeclarator: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqExportDeclarator_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqExportStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var declarations = [];
			var last;
			if(this.test(Token.LEFT_CURLY)) {
				this.commit().NL_0M();
				while(!(this.test(Token.RIGHT_CURLY))) {
					declarations.push(this.reqExportDeclarator());
					this.reqNL_1M();
				}
				if(!this.test(Token.RIGHT_CURLY)) {
					this.throw("}");
				}
				last = this.yes();
			}
			else {
				declarations.push(this.reqExportDeclarator());
				while(this.test(Token.COMMA)) {
					this.commit();
					declarations.push(this.reqExportDeclarator());
				}
				last = declarations[declarations.length - 1];
			}
			this.reqNL_EOF_1M();
			return this.yep(AST.ExportDeclaration(declarations, first, last));
		},
		reqExportStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqExportStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqExpression_0: function() {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			var __ks_i = -1;
			var mode = arguments[++__ks_i];
			if(mode === void 0) {
				mode = null;
			}
			var __ks__;
			var terminator = arguments.length > 1 && (__ks__ = arguments[++__ks_i]) !== void 0 ? __ks__ : null;
			if(mode === null) {
				if(((this._mode & ParserMode.MacroExpression) !== 0) && this._scanner.test(Token.IDENTIFIER) && (this._scanner.value() === "macro")) {
					return this.reqMacroExpression(this.yes(), terminator);
				}
				else {
					mode = ExpressionMode.Default;
				}
			}
			var operation = this.reqOperation(mode);
			if(this.test(Token.QUESTION)) {
				this.commit();
				var whenTrue = this.reqExpression(ExpressionMode.Default);
				if(!this.test(Token.COLON)) {
					this.throw(":");
				}
				this.commit();
				var whenFalse = this.reqExpression(ExpressionMode.Default);
				return this.yep(AST.ConditionalExpression(operation, whenTrue, whenFalse));
			}
			else {
				return operation;
			}
		},
		reqExpression: function() {
			if(arguments.length >= 1 && arguments.length <= 2) {
				return Parser.prototype.__ks_func_reqExpression_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqExpression0CNList_0: function() {
			this.NL_0M();
			if(this.test(Token.RIGHT_ROUND)) {
				return this.yep([]);
			}
			else {
				var expressions = [];
				while(true) {
					expressions.push(this.reqExpression(null, MacroTerminator.List));
					if((this.match(Token.COMMA, Token.NEWLINE) === Token.COMMA) || (this._token === Token.NEWLINE)) {
						this.commit().NL_0M();
					}
					else {
						break;
					}
					if(this.test(Token.RIGHT_ROUND)) {
						break;
					}
				}
				if(!this.test(Token.RIGHT_ROUND)) {
					this.throw(")");
				}
				return this.yep(expressions);
			}
		},
		reqExpression0CNList: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqExpression0CNList_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqExpressionStatement_0: function() {
			var expression = this.reqExpression(ExpressionMode.Default);
			if(this.match(Token.FOR, Token.IF, Token.UNLESS) === Token.FOR) {
				var statement = this.reqForExpression(this.yes());
				statement.value.body = expression.value;
				this.relocate(statement, expression, null);
				return statement;
			}
			else if(this._token === Token.IF) {
				this.commit();
				var condition = this.reqExpression(ExpressionMode.Default);
				return this.yep(AST.IfStatement(condition, expression, null, expression, condition));
			}
			else if(this._token === Token.UNLESS) {
				this.commit();
				var condition = this.reqExpression(ExpressionMode.Default);
				return this.yep(AST.UnlessStatement(condition, expression, expression, condition));
			}
			else {
				return expression;
			}
		},
		reqExpressionStatement: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqExpressionStatement_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqExternClassDeclaration_0: function() {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			var __ks_i = -1;
			var first = arguments[++__ks_i];
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var __ks__;
			var modifiers = arguments.length > 1 && (__ks__ = arguments[++__ks_i]) !== void 0 && __ks__ !== null ? __ks__ : [];
			var name = this.reqIdentifier();
			var generic;
			if(this.test(Token.LEFT_ANGLE)) {
				generic = this.reqTypeGeneric(this.yes());
			}
			var __ks_extends_1;
			if(this.test(Token.EXTENDS)) {
				this.commit();
				__ks_extends_1 = this.reqIdentifier();
			}
			if(this.test(Token.LEFT_CURLY)) {
				this.commit().NL_0M();
				var members = [];
				while(!(this.test(Token.RIGHT_CURLY))) {
					this.reqExternClassMemberList(members);
				}
				if(!this.test(Token.RIGHT_CURLY)) {
					this.throw("}");
				}
				return this.yep(AST.ClassDeclaration(name, null, __ks_extends_1, modifiers, members, first, this.yes()));
			}
			else {
				return this.yep(AST.ClassDeclaration(name, null, __ks_extends_1, modifiers, [], first, Type.isValue(__ks_extends_1) ? __ks_extends_1 : Type.isValue(generic) ? generic : name));
			}
		},
		reqExternClassDeclaration: function() {
			if(arguments.length >= 1 && arguments.length <= 2) {
				return Parser.prototype.__ks_func_reqExternClassDeclaration_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqExternClassMember_0: function(modifiers, first) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(modifiers === void 0 || modifiers === null) {
				throw new TypeError("'modifiers' is not nullable");
			}
			if(first === void 0) {
				first = null;
			}
			var name = this.reqNameIST();
			if(this.match(Token.COLON, Token.LEFT_CURLY, Token.LEFT_ROUND) === Token.COLON) {
				this.commit();
				var type = this.reqTypeVar();
				if(this.test(Token.LEFT_CURLY)) {
					this.commit();
					return this.reqExternClassProperty(modifiers, name, type, Type.isValue(first) ? first : name);
				}
				else {
					return this.reqExternClassField(modifiers, name, type, Type.isValue(first) ? first : name);
				}
			}
			else if(this._token === Token.LEFT_CURLY) {
				this.commit();
				return this.reqExternClassProperty(modifiers, name, null, Type.isValue(first) ? first : name);
			}
			else if(this._token === Token.LEFT_ROUND) {
				return this.reqExternClassMethod(modifiers, name, this.yes(), Type.isValue(first) ? first : name);
			}
			else {
				return this.reqExternClassField(modifiers, name, null, Type.isValue(first) ? first : name);
			}
		},
		reqExternClassMember: function() {
			if(arguments.length === 2) {
				return Parser.prototype.__ks_func_reqExternClassMember_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqExternClassMemberList_0: function(members) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(members === void 0 || members === null) {
				throw new TypeError("'members' is not nullable");
			}
			var first = null;
			var modifiers = [];
			if(this.match(Token.PRIVATE, Token.PROTECTED, Token.PUBLIC) === Token.PRIVATE) {
				modifiers.push(this.yep(AST.Modifier(ModifierKind.Private, this.yes())));
			}
			else if(this._token === Token.PROTECTED) {
				modifiers.push(this.yep(AST.Modifier(ModifierKind.Protected, this.yes())));
			}
			else if(this._token === Token.PUBLIC) {
				modifiers.push(this.yep(AST.Modifier(ModifierKind.Public, this.yes())));
			}
			if(this.test(Token.ABSTRACT)) {
				modifiers.push(this.yep(AST.Modifier(ModifierKind.Abstract, this.yes())));
				first = modifiers[0];
				if(this.test(Token.LEFT_CURLY)) {
					this.commit().NL_0M();
					while(!(this.test(Token.RIGHT_CURLY))) {
						members.push(this.reqClassAbstractMethod(null, modifiers, first));
					}
					if(!this.test(Token.RIGHT_CURLY)) {
						this.throw("}");
					}
					this.commit().reqNL_1M();
				}
				else {
					members.push(this.reqClassAbstractMethod(null, modifiers, first));
				}
			}
			else {
				if(this.test(Token.STATIC)) {
					modifiers.push(this.yep(AST.Modifier(ModifierKind.Static, this.yes())));
				}
				if((first === null) && (modifiers.length !== 0)) {
					first = modifiers[0];
				}
				if(this.test(Token.LEFT_CURLY)) {
					if(first === null) {
						first = this.yes();
					}
					else {
						this.commit();
					}
					this.NL_0M();
					while(!(this.test(Token.RIGHT_CURLY))) {
						members.push(this.reqExternClassMember(modifiers, first));
					}
					if(!this.test(Token.RIGHT_CURLY)) {
						this.throw("}");
					}
					this.commit();
					this.reqNL_1M();
				}
				else {
					members.push(this.reqExternClassMember(modifiers, first));
				}
			}
		},
		reqExternClassMemberList: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqExternClassMemberList_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqExternClassMethod_0: function(modifiers, name, round, first) {
			if(arguments.length < 4) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 4)");
			}
			if(modifiers === void 0 || modifiers === null) {
				throw new TypeError("'modifiers' is not nullable");
			}
			if(name === void 0 || name === null) {
				throw new TypeError("'name' is not nullable");
			}
			if(round === void 0 || round === null) {
				throw new TypeError("'round' is not nullable");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var parameters = this.reqClassMethodParameterList(round);
			var mods = this.reqFunctionModifiers();
			var type = this.reqFunctionReturns();
			this.reqNL_1M();
			if(mods !== null) {
				modifiers = [].concat(modifiers, mods.value);
			}
			return this.yep(AST.MethodDeclaration(null, modifiers, name, parameters, type, null, null, first, Type.isValue(type) ? type : Type.isValue(mods) ? mods : parameters));
		},
		reqExternClassMethod: function() {
			if(arguments.length === 4) {
				return Parser.prototype.__ks_func_reqExternClassMethod_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqExternDeclarator_0: function(ns) {
			if(ns === void 0 || ns === null) {
				ns = false;
			}
			var __ks_0 = this.matchM(M.EXTERN_STATEMENT);
			if(__ks_0 === Token.ABSTRACT) {
				var __ks_abstract_1 = this.yep(AST.Modifier(ModifierKind.Abstract, this.yes()));
				if(this.test(Token.CLASS)) {
					this.commit();
					return this.reqExternClassDeclaration(__ks_abstract_1, [__ks_abstract_1]);
				}
				else {
					this.throw("class");
				}
			}
			else if(__ks_0 === Token.CLASS) {
				return this.reqExternClassDeclaration(this.yes(), []);
			}
			else if(__ks_0 === Token.CONST && ns) {
				var first = this.yes();
				var name = this.reqIdentifier();
				if(this.test(Token.COLON)) {
					this.commit();
					var type = this.reqTypeVar();
					return this.yep(AST.VariableDeclarator(name, type, true, first, type));
				}
				else {
					return this.yep(AST.VariableDeclarator(name, null, true, first, name));
				}
			}
			else if(__ks_0 === Token.ENUM) {
				return this.reqExternEnumDeclaration(this.yes());
			}
			else if(__ks_0 === Token.FUNC) {
				var first = this.yes();
				var name = this.reqIdentifier();
				if(this.test(Token.LEFT_ROUND)) {
					var parameters = this.reqFunctionParameterList();
					var modifiers = this.reqFunctionModifiers();
					var type = this.reqFunctionReturns();
					return this.yep(AST.FunctionDeclaration(name, parameters, modifiers, type, null, null, first, Type.isValue(type) ? type : Type.isValue(modifiers) ? modifiers : parameters));
				}
				else {
					return this.yep(AST.FunctionDeclaration(name, null, null, null, null, null, first, name));
				}
			}
			else if(__ks_0 === Token.IDENTIFIER) {
				var name = this.reqIdentifier();
				if(this.match(Token.COLON, Token.LEFT_ROUND) === Token.COLON) {
					this.commit();
					var type = this.reqTypeVar();
					return this.yep(AST.VariableDeclarator(name, type));
				}
				else if(this._token === Token.LEFT_ROUND) {
					var parameters = this.reqFunctionParameterList();
					var modifiers = this.reqFunctionModifiers();
					var type = this.reqFunctionReturns();
					return this.yep(AST.FunctionDeclaration(name, parameters, modifiers, type, null, null, name, Type.isValue(type) ? type : Type.isValue(modifiers) ? modifiers : parameters));
				}
				else {
					return this.yep(AST.VariableDeclarator(name));
				}
			}
			else if(__ks_0 === Token.NAMESPACE) {
				return this.reqExternNamespaceDeclaration(this.yes(), []);
			}
			else if(__ks_0 === Token.SEALED) {
				var __ks_sealed_1 = this.yep(AST.Modifier(ModifierKind.Sealed, this.yes()));
				if(this.matchM(M.EXTERN_STATEMENT) === Token.ABSTRACT) {
					var __ks_abstract_1 = this.yep(AST.Modifier(ModifierKind.Abstract, this.yes()));
					if(this.test(Token.CLASS)) {
						this.commit();
						return this.reqExternClassDeclaration(__ks_sealed_1, [__ks_sealed_1, __ks_abstract_1]);
					}
					else {
						this.throw("class");
					}
				}
				else if(this._token === Token.CLASS) {
					this.commit();
					return this.reqExternClassDeclaration(__ks_sealed_1, [__ks_sealed_1]);
				}
				else if(this._token === Token.IDENTIFIER) {
					var name = this.reqIdentifier();
					if(this.test(Token.COLON)) {
						this.commit();
						var type = this.reqTypeVar();
						return this.yep(AST.VariableDeclarator(name, type, true, __ks_sealed_1, type));
					}
					else {
						return this.yep(AST.VariableDeclarator(name, null, true, __ks_sealed_1, name));
					}
				}
				else if(this._token === Token.NAMESPACE) {
					this.commit();
					return this.reqExternNamespaceDeclaration(__ks_sealed_1, [__ks_sealed_1]);
				}
				else {
					this.throw(["class", "namespace"]);
				}
			}
			else if(__ks_0 === Token.LET && ns) {
				var first = this.yes();
				var name = this.reqIdentifier();
				if(this.test(Token.COLON)) {
					this.commit();
					var type = this.reqTypeVar();
					return this.yep(AST.VariableDeclarator(name, type, false, first, type));
				}
				else {
					return this.yep(AST.VariableDeclarator(name, null, false, first, name));
				}
			}
			else {
				this.throw();
			}
		},
		reqExternDeclarator: function() {
			if(arguments.length >= 0 && arguments.length <= 1) {
				return Parser.prototype.__ks_func_reqExternDeclarator_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqExternEnumDeclaration_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var name = this.reqIdentifier();
			var type;
			if(this.test(Token.LEFT_ANGLE)) {
				this.commit();
				type = this.reqTypeEntity(NO);
				if(!this.test(Token.RIGHT_ANGLE)) {
					this.throw(">");
				}
				this.commit();
			}
			if(!this.test(Token.LEFT_CURLY)) {
				this.throw("{");
			}
			this.commit();
			this.NL_0M();
			var members = [];
			while(!(this.test(Token.RIGHT_CURLY))) {
				members.push(AST.EnumMember(this.reqIdentifier()));
				if(this.test(Token.COMMA)) {
					this.commit().NL_0M();
				}
				else if(this.test(Token.NEWLINE)) {
					this.commit().NL_0M();
					if(this.test(Token.COMMA)) {
						this.commit().NL_0M();
					}
				}
				else {
					break;
				}
			}
			if(!this.test(Token.RIGHT_CURLY)) {
				this.throw("}");
			}
			return this.yep(AST.EnumDeclaration(name, type, members, first, this.yes()));
		},
		reqExternEnumDeclaration: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqExternEnumDeclaration_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqExternNamespaceDeclaration_0: function() {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			var __ks_i = -1;
			var first = arguments[++__ks_i];
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var __ks__;
			var modifiers = arguments.length > 1 && (__ks__ = arguments[++__ks_i]) !== void 0 && __ks__ !== null ? __ks__ : [];
			var name = this.reqIdentifier();
			if(this.test(Token.LEFT_CURLY)) {
				this.commit().NL_0M();
				var statements = [];
				while(!(this.test(Token.RIGHT_CURLY))) {
					statements.push(this.reqExternDeclarator(true));
					this.reqNL_1M();
				}
				if(!this.test(Token.RIGHT_CURLY)) {
					this.throw("}");
				}
				return this.yep(AST.NamespaceDeclaration(modifiers, name, statements, first, this.yes()));
			}
			else {
				return this.yep(AST.NamespaceDeclaration(modifiers, name, [], first, name));
			}
		},
		reqExternNamespaceDeclaration: function() {
			if(arguments.length >= 1 && arguments.length <= 2) {
				return Parser.prototype.__ks_func_reqExternNamespaceDeclaration_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqExternOrRequireStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var declarations = [];
			var last;
			if(this.test(Token.LEFT_CURLY)) {
				this.commit().NL_0M();
				while(!(this.test(Token.RIGHT_CURLY))) {
					declarations.push(this.reqExternDeclarator());
					this.reqNL_1M();
				}
				if(!this.test(Token.RIGHT_CURLY)) {
					this.throw("}");
				}
				last = this.yes();
			}
			else {
				declarations.push(this.reqExternDeclarator());
				while(this.test(Token.COMMA)) {
					this.commit();
					declarations.push(this.reqExternDeclarator());
				}
				last = declarations[declarations.length - 1];
			}
			this.reqNL_EOF_1M();
			return this.yep(AST.ExternOrRequireDeclaration(declarations, first, last));
		},
		reqExternOrRequireStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqExternOrRequireStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqExternStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var declarations = [];
			var last;
			if(this.test(Token.LEFT_CURLY)) {
				this.commit().NL_0M();
				while(!(this.test(Token.RIGHT_CURLY))) {
					declarations.push(this.reqExternDeclarator());
					this.reqNL_1M();
				}
				if(!this.test(Token.RIGHT_CURLY)) {
					this.throw("}");
				}
				last = this.yes();
			}
			else {
				declarations.push(this.reqExternDeclarator());
				while(this.test(Token.COMMA)) {
					this.commit();
					declarations.push(this.reqExternDeclarator());
				}
				last = declarations[declarations.length - 1];
			}
			this.reqNL_EOF_1M();
			return this.yep(AST.ExternDeclaration(declarations, first, last));
		},
		reqExternStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqExternStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqForExpression_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var declaration = false;
			if(this.test(Token.LET)) {
				this.commit();
				declaration = true;
			}
			var identifier1, identifier2;
			if(this.test(Token.COLON)) {
				this.commit();
				identifier2 = this.reqIdentifier();
			}
			else {
				identifier1 = this.reqIdentifier();
				if(this.test(Token.COMMA)) {
					this.commit();
					identifier2 = this.reqIdentifier();
				}
			}
			this.NL_0M();
			if(Type.isValue(identifier2)) {
				if(this.match(Token.IN, Token.OF) === Token.IN) {
					return this.altForExpressionInRange(declaration, identifier1, identifier2, first);
				}
				else if(this._token === Token.OF) {
					return this.altForExpressionOf(declaration, identifier1, identifier2, first);
				}
				else {
					this.throw(["in", "of"]);
				}
			}
			else {
				if(this.match(Token.FROM, Token.IN, Token.OF) === Token.FROM) {
					return this.altForExpressionFrom(declaration, identifier1, first);
				}
				else if(this._token === Token.IN) {
					return this.altForExpressionInRange(declaration, identifier1, identifier2, first);
				}
				else if(this._token === Token.OF) {
					return this.altForExpressionOf(declaration, identifier1, identifier2, first);
				}
				else {
					this.throw(["from", "in", "of"]);
				}
			}
		},
		reqForExpression: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqForExpression_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqForStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var statement = this.reqForExpression(first);
			this.NL_0M();
			var block = this.reqBlock();
			statement.value.body = block.value;
			this.relocate(statement, null, block);
			return statement;
		},
		reqForStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqForStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqFunctionBody_0: function() {
			if(this.match(Token.LEFT_CURLY, Token.EQUALS_RIGHT_ANGLE) === Token.LEFT_CURLY) {
				return this.reqBlock(this.yes());
			}
			else if(this._token === Token.EQUALS_RIGHT_ANGLE) {
				this.commit();
				return this.reqExpression(ExpressionMode.Default);
			}
			else {
				this.throw(["{", "=>"]);
			}
		},
		reqFunctionBody: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqFunctionBody_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqFunctionModifiers_0: function() {
			if(this.test(Token.ASYNC)) {
				return this.yep([this.yep(AST.Modifier(ModifierKind.Async, this.yes()))]);
			}
			else {
				return null;
			}
		},
		reqFunctionModifiers: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqFunctionModifiers_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqFunctionParameterList_0: function() {
			if(!this.test(Token.LEFT_ROUND)) {
				this.throw("(");
			}
			var first = this.yes();
			var parameters = [];
			if(!this.test(Token.RIGHT_ROUND)) {
				while(this.reqParameter(parameters, ParameterMode.Function)) {
				}
				if(!this.test(Token.RIGHT_ROUND)) {
					this.throw(")");
				}
			}
			return this.yep(parameters, first, this.yes());
		},
		reqFunctionParameterList: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqFunctionParameterList_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqFunctionReturns_0: function() {
			if(this.test(Token.COLON)) {
				this.commit();
				return this.reqTypeVar();
			}
			else {
				return null;
			}
		},
		reqFunctionReturns: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqFunctionReturns_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqFunctionStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var identifier = this.reqIdentifier();
			var parameters = this.reqFunctionParameterList();
			var modifiers = this.reqFunctionModifiers();
			var type = this.reqFunctionReturns();
			var __ks_throws_1 = this.reqFunctionThrows();
			var body = this.reqFunctionBody();
			return this.yep(AST.FunctionDeclaration(identifier, parameters, modifiers, type, __ks_throws_1, body, first, body));
		},
		reqFunctionStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqFunctionStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqFunctionThrows_0: function() {
			if(this.test(Token.TILDE)) {
				this.commit();
				var exceptions = [this.reqIdentifier()];
				while(this.test(Token.COMMA)) {
					this.commit();
					exceptions.push(this.reqIdentifier());
				}
				return this.yep(exceptions);
			}
			else {
				return null;
			}
		},
		reqFunctionThrows: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqFunctionThrows_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqIdentifier_0: function() {
			if(this._scanner.test(Token.IDENTIFIER)) {
				return this.yep(AST.Identifier(this._scanner.value(), this.yes()));
			}
			else {
				this.throw("Identifier");
			}
		},
		reqIdentifier: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqIdentifier_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqIfStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			this.NL_0M();
			var condition = this.reqExpression(ExpressionMode.NoAnonymousFunction);
			this.NL_0M();
			var whenTrue = this.reqBlock();
			if(this.test(Token.NEWLINE)) {
				var mark = this.mark();
				this.commit().NL_0M();
				if(this.match(Token.ELSE_IF, Token.ELSE) === Token.ELSE_IF) {
					var position = this.yes();
					position.start.column += 5;
					var whenFalse = this.reqIfStatement(position);
					return this.yep(AST.IfStatement(condition, whenTrue, whenFalse, first, whenFalse));
				}
				else if(this._token === Token.ELSE) {
					this.commit().NL_0M();
					var whenFalse = this.reqBlock();
					return this.yep(AST.IfStatement(condition, whenTrue, whenFalse, first, whenFalse));
				}
				else {
					this.rollback(mark);
					return this.yep(AST.IfStatement(condition, whenTrue, null, first, whenTrue));
				}
			}
			else {
				return this.yep(AST.IfStatement(condition, whenTrue, null, first, whenTrue));
			}
		},
		reqIfStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqIfStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqImplementStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var variable = this.reqIdentifier();
			if(this.test(Token.LEFT_ANGLE)) {
				this.reqTypeGeneric(this.yes());
			}
			if(!this.test(Token.LEFT_CURLY)) {
				this.throw("{");
			}
			this.commit().NL_0M();
			var members = [];
			while(!(this.test(Token.RIGHT_CURLY))) {
				this.reqClassMemberList(members);
			}
			if(!this.test(Token.RIGHT_CURLY)) {
				this.throw("}");
			}
			return this.yep(AST.ImplementDeclaration(variable, members, first, this.yes()));
		},
		reqImplementStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqImplementStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqImportDeclarator_0: function() {
			var source = this.reqString();
			var last = source;
			var __ks_arguments_1 = null;
			if(this.test(Token.LEFT_ROUND)) {
				this.commit();
				__ks_arguments_1 = [];
				var identifier;
				while(!(this.test(Token.RIGHT_ROUND))) {
					identifier = this.reqIdentifier();
					if(this.test(Token.COLON)) {
						this.commit();
						__ks_arguments_1.push(this.yep(AST.NamedArgument(identifier, this.reqIdentifier())));
					}
					else {
						__ks_arguments_1.push(identifier);
					}
					if(this.test(Token.COMMA)) {
						this.commit();
					}
				}
				if(!this.test(Token.RIGHT_ROUND)) {
					this.throw(")");
				}
				this.commit();
			}
			var specifiers = [];
			if(this.match(Token.EQUALS_RIGHT_ANGLE, Token.FOR, Token.LEFT_CURLY) === Token.EQUALS_RIGHT_ANGLE) {
				this.commit();
				last = this.reqIdentifier();
				if(this.test(Token.LEFT_CURLY)) {
					specifiers.push(this.yep(AST.ImportNamespaceSpecifier(last, this.reqImportSpecifiers([]), last, this.yes())));
				}
				else {
					specifiers.push(this.yep(AST.ImportNamespaceSpecifier(last, null, last, last)));
				}
			}
			else if(this._token === Token.FOR) {
				this.commit();
				var imported, local;
				while(!(this.test(Token.NEWLINE))) {
					imported = this.reqIdentifier();
					if(this.test(Token.EQUALS_RIGHT_ANGLE)) {
						this.commit();
						local = this.reqIdentifier();
						specifiers.push(this.yep(AST.ImportSpecifier(this.yep(AST.VariableDeclarator(imported)), local, imported, local)));
					}
					else {
						specifiers.push(this.yep(AST.ImportSpecifier(this.yep(AST.VariableDeclarator(imported)), imported, imported, imported)));
					}
					if(this.test(Token.COMMA)) {
						this.commit();
					}
					else {
						break;
					}
				}
			}
			else if(this._token === Token.LEFT_CURLY) {
				this.reqImportSpecifiers(specifiers);
				last = this.yes();
			}
			return this.yep(AST.ImportDeclarator(source, specifiers, __ks_arguments_1, source, last));
		},
		reqImportDeclarator: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqImportDeclarator_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqImportSpecifiers_0: function(specifiers) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(specifiers === void 0 || specifiers === null) {
				throw new TypeError("'specifiers' is not nullable");
			}
			this.commit().reqNL_1M();
			var first, imported, local;
			while(!(this.test(Token.RIGHT_CURLY))) {
				if(this.match(Token.ASTERISK) === Token.ASTERISK) {
					first = this.yes();
					if(!this.test(Token.EQUALS_RIGHT_ANGLE)) {
						this.throw("=>");
					}
					this.commit();
					local = this.reqIdentifier();
					specifiers.push(this.yep(AST.ImportNamespaceSpecifier(local, null, first, local)));
				}
				else {
					imported = this.reqExternDeclarator();
					if(this.test(Token.EQUALS_RIGHT_ANGLE)) {
						this.commit();
						local = this.reqIdentifier();
						specifiers.push(this.yep(AST.ImportSpecifier(imported, local, imported, local)));
					}
					else {
						specifiers.push(this.yep(AST.ImportSpecifier(imported, this.yep(imported.value.name), imported, imported)));
					}
				}
				if(this.test(Token.NEWLINE)) {
					this.commit().NL_0M();
				}
				else {
					break;
				}
			}
			if(!this.test(Token.RIGHT_CURLY)) {
				this.throw("}");
			}
			return specifiers;
		},
		reqImportSpecifiers: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqImportSpecifiers_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqImportStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			this.NL_0M();
			var declarations = [];
			var last;
			if(this.test(Token.LEFT_CURLY)) {
				this.commit().reqNL_1M();
				while(!(this.test(Token.RIGHT_CURLY))) {
					declarations.push(this.reqImportDeclarator());
					if(this.test(Token.NEWLINE)) {
						this.commit().NL_0M();
					}
					else {
						break;
					}
				}
				if(!this.test(Token.RIGHT_CURLY)) {
					this.throw("}");
				}
				last = this.yes();
			}
			else {
				declarations.push(last = this.reqImportDeclarator());
			}
			return this.yep(AST.ImportDeclaration(declarations, first, last));
		},
		reqImportStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqImportStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqIncludeStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(this.test(Token.LEFT_CURLY)) {
				this.commit().reqNL_1M();
				var files = [];
				while(!(this.test(Token.RIGHT_CURLY))) {
					if(this.test(Token.STRING)) {
						files.push(this.value());
						this.commit().reqNL_1M();
					}
					else {
						break;
					}
				}
				if(!this.test(Token.RIGHT_CURLY)) {
					this.throw("}");
				}
				var last = this.yes();
				this.reqNL_EOF_1M();
				return this.yep(AST.IncludeDeclaration(files, first, last));
			}
			else {
				if(!this.test(Token.STRING)) {
					this.throw("String");
				}
				var files = [this.value()];
				var last = this.yes();
				this.reqNL_EOF_1M();
				return this.yep(AST.IncludeDeclaration(files, first, last));
			}
		},
		reqIncludeStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqIncludeStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqIncludeAgainStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(this.test(Token.LEFT_CURLY)) {
				this.commit().reqNL_1M();
				var files = [];
				while(!(this.test(Token.RIGHT_CURLY))) {
					if(this.test(Token.STRING)) {
						files.push(this.value());
						this.commit().reqNL_1M();
					}
					else {
						break;
					}
				}
				if(!this.test(Token.RIGHT_CURLY)) {
					this.throw("}");
				}
				var last = this.yes();
				this.reqNL_EOF_1M();
				return this.yep(AST.IncludeAgainDeclaration(files, first, last));
			}
			else {
				if(!this.test(Token.STRING)) {
					this.throw("String");
				}
				var files = [this.value()];
				var last = this.yes();
				this.reqNL_EOF_1M();
				return this.yep(AST.IncludeAgainDeclaration(files, first, last));
			}
		},
		reqIncludeAgainStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqIncludeAgainStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqLetStatement_0: function() {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			var __ks_i = -1;
			var first = arguments[++__ks_i];
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var __ks__;
			var mode = arguments.length > 1 && (__ks__ = arguments[++__ks_i]) !== void 0 && __ks__ !== null ? __ks__ : ExpressionMode.Default;
			if(this.match(Token.LEFT_CURLY, Token.LEFT_SQUARE) === Token.LEFT_CURLY) {
				var variables = [];
				variables.push(this.yep(AST.VariableDeclarator(this.reqDestructuringObject(this.yes()))));
				if(this.test(Token.COMMA)) {
					do {
						this.commit();
						if(this.match(Token.LEFT_CURLY, Token.LEFT_SQUARE) === Token.LEFT_CURLY) {
							variables.push(this.yep(AST.VariableDeclarator(this.reqDestructuringObject(this.yes()))));
						}
						else if(this._token === Token.LEFT_SQUARE) {
							variables.push(this.yep(AST.VariableDeclarator(this.reqDestructuringArray(this.yes()))));
						}
						else {
							variables.push(this.reqTypedIdentifier());
						}
					}
					while(this.test(Token.COMMA))
					return this.altLetStatementAwait(first, variables, this.reqVariableEquals());
				}
				else {
					return this.altLetStatementEquals(first, variables, this.reqVariableEquals());
				}
			}
			else if(this._token === Token.LEFT_SQUARE) {
				var variables = [];
				variables.push(this.yep(AST.VariableDeclarator(this.reqDestructuringArray(this.yes()))));
				if(this.test(Token.COMMA)) {
					do {
						this.commit();
						if(this.match(Token.LEFT_CURLY, Token.LEFT_SQUARE) === Token.LEFT_CURLY) {
							variables.push(this.yep(AST.VariableDeclarator(this.reqDestructuringObject(this.yes()))));
						}
						else if(this._token === Token.LEFT_SQUARE) {
							variables.push(this.yep(AST.VariableDeclarator(this.reqDestructuringArray(this.yes()))));
						}
						else {
							variables.push(this.reqTypedIdentifier());
						}
					}
					while(this.test(Token.COMMA))
					return this.altLetStatementAwait(first, variables, this.reqVariableEquals());
				}
				else {
					return this.altLetStatementEquals(first, variables, this.reqVariableEquals());
				}
			}
			else {
				var identifier = this.reqTypedIdentifier();
				if(this.test(Token.COMMA)) {
					var variables = [identifier];
					var onlyIdentifiers = true;
					do {
						this.commit();
						if(this.match(Token.LEFT_CURLY, Token.LEFT_SQUARE) === Token.LEFT_CURLY) {
							variables.push(this.yep(AST.VariableDeclarator(this.reqDestructuringObject(this.yes()))));
							onlyIdentifiers = false;
						}
						else if(this._token === Token.LEFT_SQUARE) {
							variables.push(this.yep(AST.VariableDeclarator(this.reqDestructuringArray(this.yes()))));
							onlyIdentifiers = false;
						}
						else {
							variables.push(this.reqTypedIdentifier());
						}
					}
					while(this.test(Token.COMMA))
					if(onlyIdentifiers) {
						var equals = this.tryVariableEquals();
						if(equals.ok) {
							return this.altLetStatementAwait(first, variables, equals);
						}
						else {
							return this.yep(AST.VariableDeclaration(variables, true, first, variables[variables.length - 1]));
						}
					}
					else {
						return this.altLetStatementAwait(first, variables, this.reqVariableEquals());
					}
				}
				else {
					var equals = this.tryVariableEquals();
					if(equals.ok) {
						return this.altLetStatementEquals(first, [identifier], equals);
					}
					else {
						return this.yep(AST.VariableDeclaration([identifier], true, first, identifier));
					}
				}
			}
		},
		reqLetStatement: function() {
			if(arguments.length >= 1 && arguments.length <= 2) {
				return Parser.prototype.__ks_func_reqLetStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqMacroElements_0: function(elements, terminator) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(elements === void 0 || elements === null) {
				throw new TypeError("'elements' is not nullable");
			}
			if(terminator === void 0 || terminator === null) {
				throw new TypeError("'terminator' is not nullable");
			}
			var history = [];
			var literal = null;
			var first, last;
			var addLiteral = Helper.vcurry(function() {
				if(literal !== null) {
					elements.push(this.yep(AST.MacroElementLiteral(literal, first, last)));
					literal = null;
				}
			}, this);
			var addToLiteral = Helper.vcurry(function() {
				if(literal === null) {
					literal = this._scanner.value();
					first = last = this.yep();
				}
				else {
					literal += this._scanner.value();
					last = this.yep();
				}
				this.commit();
			}, this);
			while(true) {
				var __ks_0 = this.matchM(M.MACRO);
				if(__ks_0 === Token.EOF) {
					if((history.length === 0) && ((terminator & MacroTerminator.NEWLINE) === 0)) {
						this.throw();
					}
					break;
				}
				else if(__ks_0 === Token.HASH) {
					addLiteral();
					var __ks_first_1 = this.yes();
					if(this.testNS(Token.IDENTIFIER)) {
						var identifier = this._scanner.value();
						var __ks_last_1 = this.yes();
						var mark = this.mark();
						if((identifier.length === 1) && ((identifier === "a") || (identifier === "b") || (identifier === "e") || (identifier === "i")) && this.test(Token.LEFT_ROUND)) {
							var reification = AST.MacroReification(identifier, __ks_last_1);
							this.commit();
							var expression = this.reqExpression(ExpressionMode.Default);
							if(!this.test(Token.RIGHT_ROUND)) {
								this.throw(")");
							}
							elements.push(this.yep(AST.MacroElementExpression(expression, reification, __ks_first_1, this.yes())));
						}
						else {
							this.rollback(mark);
							var expression = this.yep(AST.Identifier(identifier, __ks_last_1));
							elements.push(this.yep(AST.MacroElementExpression(expression, null, __ks_first_1, expression)));
						}
					}
					else if(this.testNS(Token.LEFT_ROUND)) {
						this.commit();
						var expression = this.reqExpression(ExpressionMode.Default);
						if(!this.test(Token.RIGHT_ROUND)) {
							this.throw(")");
						}
						elements.push(this.yep(AST.MacroElementExpression(expression, null, __ks_first_1, this.yes())));
					}
					else {
						this.throw();
					}
				}
				else if(__ks_0 === Token.INVALID) {
					addToLiteral();
				}
				else if(__ks_0 === Token.LEFT_CURLY) {
					addToLiteral();
					history.unshift(Token.RIGHT_CURLY);
				}
				else if(__ks_0 === Token.LEFT_ROUND) {
					addToLiteral();
					history.unshift(Token.RIGHT_ROUND);
				}
				else if(__ks_0 === Token.NEWLINE) {
					if((history.length === 0) && ((terminator & MacroTerminator.NEWLINE) !== 0)) {
						break;
					}
					else {
						addLiteral();
						elements.push(this.yep(AST.MacroElementNewLine(this.yes())));
						this._scanner.skip();
					}
				}
				else if(__ks_0 === Token.RIGHT_CURLY) {
					if(history.length === 0) {
						if((terminator & MacroTerminator.RIGHT_CURLY) === 0) {
							addToLiteral();
						}
						else {
							break;
						}
					}
					else {
						addToLiteral();
						if(history[0] === Token.RIGHT_CURLY) {
							history.shift();
						}
					}
				}
				else if(__ks_0 === Token.RIGHT_ROUND) {
					if(history.length === 0) {
						if((terminator & MacroTerminator.RIGHT_ROUND) === 0) {
							addToLiteral();
						}
						else {
							break;
						}
					}
					else {
						addToLiteral();
						if(history[0] === Token.RIGHT_ROUND) {
							history.shift();
						}
					}
				}
			}
			if(!(history.length === 0)) {
				this.throw();
			}
			if(literal !== null) {
				elements.push(this.yep(AST.MacroElementLiteral(literal, first, last)));
			}
		},
		reqMacroElements: function() {
			if(arguments.length === 2) {
				return Parser.prototype.__ks_func_reqMacroElements_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqMacroExpression_0: function() {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			var __ks_i = -1;
			var first = arguments[++__ks_i];
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var __ks__;
			var terminator = arguments.length > 1 && (__ks__ = arguments[++__ks_i]) !== void 0 && __ks__ !== null ? __ks__ : MacroTerminator.NEWLINE;
			var elements = [];
			if(this.test(Token.LEFT_CURLY)) {
				if(first.ok) {
					this.commit();
				}
				else {
					first = this.yes();
				}
				this.reqNL_1M();
				this.reqMacroElements(elements, MacroTerminator.RIGHT_CURLY);
				if(!this.test(Token.RIGHT_CURLY)) {
					this.throw("}");
				}
				return this.yep(AST.MacroExpression(elements, true, first, this.yes()));
			}
			else {
				if(!first.ok) {
					first = this.yep();
				}
				this.reqMacroElements(elements, terminator);
				return this.yep(AST.MacroExpression(elements, false, first, elements[elements.length - 1]));
			}
		},
		reqMacroExpression: function() {
			if(arguments.length >= 1 && arguments.length <= 2) {
				return Parser.prototype.__ks_func_reqMacroExpression_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqMacroParameterList_0: function() {
			if(!this.test(Token.LEFT_ROUND)) {
				this.throw("(");
			}
			var first = this.yes();
			var parameters = [];
			if(!this.test(Token.RIGHT_ROUND)) {
				while(this.reqParameter(parameters, ParameterMode.Macro)) {
				}
				if(!this.test(Token.RIGHT_ROUND)) {
					this.throw(")");
				}
			}
			return this.yep(parameters, first, this.yes());
		},
		reqMacroParameterList: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqMacroParameterList_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqMacroBody_0: function() {
			if(this.match(Token.LEFT_CURLY, Token.EQUALS_RIGHT_ANGLE) === Token.LEFT_CURLY) {
				this._mode |= ParserMode.MacroExpression;
				var body = this.reqBlock(this.yes());
				this._mode ^= ParserMode.MacroExpression;
				return body;
			}
			else if(this._token === Token.EQUALS_RIGHT_ANGLE) {
				return this.reqMacroExpression(this.yes());
			}
			else {
				this.throw(["{", "=>"]);
			}
		},
		reqMacroBody: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqMacroBody_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqModule_0: function() {
			this.NL_0M();
			var attributes = [];
			var body = [];
			var statement, attrs;
			while(!(this._scanner.isEOF())) {
				if(this.test(Token.HASH_EXCLAMATION_LEFT_SQUARE)) {
					attributes.push(this.reqAttributeBlock(this.yes()));
				}
				else {
					if(this.test(Token.HASH_LEFT_SQUARE)) {
						attrs = this.reqAttributeList(this.yes());
					}
					else {
						attrs = null;
					}
					var __ks_0 = this.matchM(M.MODULE_STATEMENT);
					if(__ks_0 === Token.EXPORT) {
						statement = this.reqExportStatement(this.yes()).value;
					}
					else if(__ks_0 === Token.EXTERN) {
						statement = this.reqExternStatement(this.yes()).value;
					}
					else if(__ks_0 === Token.EXTERN_REQUIRE) {
						statement = this.reqExternOrRequireStatement(this.yes()).value;
					}
					else if(__ks_0 === Token.INCLUDE) {
						statement = this.reqIncludeStatement(this.yes()).value;
					}
					else if(__ks_0 === Token.INCLUDE_AGAIN) {
						statement = this.reqIncludeAgainStatement(this.yes()).value;
					}
					else if(__ks_0 === Token.REQUIRE) {
						statement = this.reqRequireStatement(this.yes()).value;
					}
					else if(__ks_0 === Token.REQUIRE_EXTERN) {
						statement = this.reqRequireOrExternStatement(this.yes()).value;
					}
					else if(__ks_0 === Token.REQUIRE_IMPORT) {
						statement = this.reqRequireOrImportStatement(this.yes()).value;
					}
					else {
						statement = this.reqStatement().value;
					}
					if(attrs === null) {
						statement.attributes = [];
					}
					else {
						statement.attributes = Helper.mapArray(attrs.value, function(attr) {
							return attr.value;
						});
						statement.start = statement.attributes[0].start;
					}
					body.push(statement);
				}
				this.NL_0M();
			}
			return AST.Module(attributes, body, this);
		},
		reqModule: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqModule_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqNameIST_0: function() {
			if(this.match(Token.IDENTIFIER, Token.STRING, Token.TEMPLATE_BEGIN) === Token.IDENTIFIER) {
				return this.reqIdentifier();
			}
			else if(this._token === Token.STRING) {
				return this.reqString();
			}
			else if(this._token === Token.TEMPLATE_BEGIN) {
				return this.reqTemplateExpression();
			}
			else {
				this.throw(["Identifier", "String", "Template"]);
			}
		},
		reqNameIST: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqNameIST_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqNamespaceStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var name = this.reqIdentifier();
			this.NL_0M();
			if(!this.test(Token.LEFT_CURLY)) {
				this.throw("{");
			}
			this.commit();
			this.NL_0M();
			var statements = [];
			var attrs, statement;
			while(!(this.test(Token.RIGHT_CURLY))) {
				if(this.test(Token.HASH_LEFT_SQUARE)) {
					attrs = this.reqAttributeList(this.yes());
				}
				else {
					attrs = null;
				}
				if(this.matchM(M.MODULE_STATEMENT) === Token.EXPORT) {
					statement = this.reqExportStatement(this.yes());
				}
				else if(this._token === Token.EXTERN) {
					statement = this.reqExternStatement(this.yes());
				}
				else if(this._token === Token.IMPORT) {
					statement = this.reqImportStatement(this.yes());
				}
				else if(this._token === Token.INCLUDE) {
					statement = this.reqIncludeStatement(this.yes());
				}
				else if(this._token === Token.INCLUDE_AGAIN) {
					statement = this.reqIncludeAgainStatement(this.yes());
				}
				else {
					statement = this.reqStatement();
				}
				if(attrs === null) {
					statement.value.attributes = [];
				}
				else {
					statement.value.attributes = Helper.mapArray(attrs.value, function(attr) {
						return attr.value;
					});
					statement.value.start = statement.value.attributes[0].start;
				}
				statements.push(statement);
			}
			if(!this.test(Token.RIGHT_CURLY)) {
				this.throw("}");
			}
			return this.yep(AST.NamespaceDeclaration([], name, statements, first, this.yes()));
		},
		reqNamespaceStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqNamespaceStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqNumber_0: function() {
			var value;
			if((value = this.tryNumber()).ok) {
				return value;
			}
			else {
				this.throw("Number");
			}
		},
		reqNumber: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqNumber_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqNL_1M_0: function() {
			if(this.test(Token.NEWLINE)) {
				this.commit();
				this.skipNewLine();
			}
			else {
				this.throw("NewLine");
			}
		},
		reqNL_1M: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqNL_1M_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqNL_EOF_1M_0: function() {
			if(this.match(Token.NEWLINE) === Token.NEWLINE) {
				this.commit();
				this.skipNewLine();
			}
			else if(this._token !== Token.EOF) {
				this.throw(["NewLine", "EOF"]);
			}
		},
		reqNL_EOF_1M: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqNL_EOF_1M_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqObject_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			this.NL_0M();
			var properties = [];
			while(!(this.test(Token.RIGHT_CURLY))) {
				properties.push(this.reqObjectItem());
				if(this.match(Token.COMMA, Token.NEWLINE) === Token.COMMA) {
					this.commit().NL_0M();
				}
				else if(this._token === Token.NEWLINE) {
					this.commit().NL_0M();
					if(this.test(Token.COMMA)) {
						this.commit().NL_0M();
					}
				}
				else {
					break;
				}
			}
			if(!this.test(Token.RIGHT_CURLY)) {
				this.throw("}");
			}
			return this.yep(AST.ObjectExpression(properties, first, this.yes()));
		},
		reqObject: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqObject_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqObjectItem_0: function() {
			var attributes, first;
			if(this.test(Token.HASH_LEFT_SQUARE)) {
				attributes = this.reqAttributeList(this.yes());
				first = attributes.value[0];
			}
			var name = this.reqNameIST();
			if(this.test(Token.COLON)) {
				this.commit();
				var value = this.reqExpression(null, MacroTerminator.Object);
				return this.yep(AST.ObjectMember(attributes, name, value, Type.isValue(first) ? first : name, value));
			}
			else {
				var parameters = this.reqFunctionParameterList();
				var modifiers = this.reqFunctionModifiers();
				var type = this.reqFunctionReturns();
				var body = this.reqFunctionBody();
				return this.yep(AST.ObjectMember(attributes, name, this.yep(AST.FunctionExpression(parameters, modifiers, type, body, parameters, body)), Type.isValue(first) ? first : name, body));
			}
		},
		reqObjectItem: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqObjectItem_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqOperand_0: function(mode) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(mode === void 0 || mode === null) {
				throw new TypeError("'mode' is not nullable");
			}
			var value;
			if((value = this.tryOperand(mode)).ok) {
				return value;
			}
			else {
				this.throw();
			}
		},
		reqOperand: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqOperand_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqOperation_0: function() {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			var __ks_i = -1;
			var mode = arguments[++__ks_i];
			if(mode === void 0 || mode === null) {
				throw new TypeError("'mode' is not nullable");
			}
			var __ks__;
			var operand = arguments.length > 1 && (__ks__ = arguments[++__ks_i]) !== void 0 ? __ks__ : null;
			operand = this.reqBinaryOperand(mode, operand);
			var values = [operand.value];
			var mark, operator;
			while(true) {
				mark = this.mark();
				this.NL_0M();
				if((operator = this.tryBinaryOperator()).ok) {
					values.push(AST.BinaryExpression(operator));
					this.NL_0M();
					values.push(this.reqBinaryOperand(mode).value);
				}
				else {
					this.rollback(mark);
					break;
				}
			}
			if(values.length === 1) {
				return operand;
			}
			else {
				return this.yep(AST.reorderExpression(values));
			}
		},
		reqOperation: function() {
			if(arguments.length >= 1 && arguments.length <= 2) {
				return Parser.prototype.__ks_func_reqOperation_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqParameter_0: function(parameters, mode) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(parameters === void 0 || parameters === null) {
				throw new TypeError("'parameters' is not nullable");
			}
			if(mode === void 0 || mode === null) {
				throw new TypeError("'mode' is not nullable");
			}
			var modifiers = [];
			if(this.test(Token.DOT_DOT_DOT)) {
				var first = this.yes();
				if(this.test(Token.LEFT_CURLY)) {
					this.commit();
					var min, max;
					if(this.test(Token.COMMA)) {
						this.commit();
						min = 0;
						max = this.reqNumber().value.value;
					}
					else {
						min = this.reqNumber().value.value;
						if(this.test(Token.COMMA)) {
							this.commit();
							if(this.test(Token.RIGHT_CURLY)) {
								max = Infinity;
							}
							else {
								max = this.reqNumber().value.value;
							}
						}
						else {
							max = min;
						}
					}
					if(!this.test(Token.RIGHT_CURLY)) {
						this.throw("}");
					}
					modifiers.push(AST.RestModifier(min, max, first, this.yes()));
				}
				else {
					modifiers.push(AST.RestModifier(0, Infinity, first, first));
				}
			}
			if(this.test(Token.AT)) {
				var first;
				if(mode === ParameterMode.Macro) {
					modifiers.push(AST.Modifier(ModifierKind.AutoEvaluate, first = this.yes()));
				}
				else if(mode === ParameterMode.Method) {
					modifiers.push(AST.Modifier(ModifierKind.ThisAlias, first = this.yes()));
				}
				else {
					this.throw();
				}
				parameters.push(this.reqParameterIdendifier(modifiers, first));
				if((mode === ParameterMode.Method) && this.test(Token.LEFT_ROUND)) {
					var __ks_first_1 = this.yes();
					if(!this.test(Token.RIGHT_ROUND)) {
						this.throw(")");
					}
					modifiers.push(AST.Modifier(ModifierKind.SetterAlias, __ks_first_1, this.yes()));
				}
				if(this.test(Token.COMMA)) {
					this.commit();
				}
				else {
					return false;
				}
			}
			else {
				var first = (modifiers.length === 0) ? null : modifiers[0];
				if(this.match(Token.COLON, Token.COMMA, Token.IDENTIFIER, Token.RIGHT_ROUND) === Token.COLON) {
					if(first === null) {
						first = this.yes();
					}
					else {
						this.commit();
					}
					var type = this.reqTypeVar();
					parameters.push(this.yep(AST.Parameter(null, type, modifiers, null, first, type)));
					if(this.test(Token.COMMA)) {
						this.commit();
					}
					else {
						return false;
					}
				}
				else if(this._token === Token.COMMA) {
					if(first === null) {
						first = this.yes();
						first.end = first.start;
					}
					else {
						this.commit();
					}
					parameters.push(this.yep(AST.Parameter(null, null, modifiers, null, first, first)));
				}
				else if(this._token === Token.IDENTIFIER) {
					parameters.push(this.reqParameterIdendifier(modifiers, first));
					if(this.test(Token.COMMA)) {
						this.commit();
					}
					else {
						return false;
					}
				}
				else if(this._token === Token.RIGHT_ROUND) {
					first = this.yep(this._scanner.position());
					first.end = first.start;
					parameters.push(this.yep(AST.Parameter(null, null, modifiers, null, first, first)));
					return false;
				}
				else if(modifiers.length !== 0) {
					parameters.push(this.yep(AST.Parameter(null, null, modifiers, null, first, first)));
				}
				else {
					this.throw();
				}
			}
			return true;
		},
		reqParameter: function() {
			if(arguments.length === 2) {
				return Parser.prototype.__ks_func_reqParameter_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqParameterIdendifier_0: function(modifiers, first) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(modifiers === void 0 || modifiers === null) {
				throw new TypeError("'modifiers' is not nullable");
			}
			if(first === void 0) {
				first = null;
			}
			var identifier = this.reqIdentifier();
			if(this.match(Token.COLON, Token.EQUALS, Token.QUESTION) === Token.COLON) {
				this.commit();
				var type = this.reqTypeVar();
				if(this.test(Token.EQUALS)) {
					this.commit();
					var defaultValue = this.reqExpression(ExpressionMode.Default);
					return this.yep(AST.Parameter(identifier, type, modifiers, defaultValue, Type.isValue(first) ? first : identifier, defaultValue));
				}
				else {
					return this.yep(AST.Parameter(identifier, type, modifiers, null, Type.isValue(first) ? first : identifier, type));
				}
			}
			else if(this._token === Token.EQUALS) {
				this.commit();
				var defaultValue = this.reqExpression(ExpressionMode.Default);
				return this.yep(AST.Parameter(identifier, null, modifiers, defaultValue, Type.isValue(first) ? first : identifier, defaultValue));
			}
			else if(this._token === Token.QUESTION) {
				var type = this.yep(AST.Nullable(this.yes()));
				if(this.test(Token.EQUALS)) {
					this.commit();
					var defaultValue = this.reqExpression(ExpressionMode.Default);
					return this.yep(AST.Parameter(identifier, type, modifiers, defaultValue, Type.isValue(first) ? first : identifier, defaultValue));
				}
				else {
					return this.yep(AST.Parameter(identifier, type, modifiers, null, Type.isValue(first) ? first : identifier, type));
				}
			}
			else {
				return this.yep(AST.Parameter(identifier, null, modifiers, null, Type.isValue(first) ? first : identifier, identifier));
			}
		},
		reqParameterIdendifier: function() {
			if(arguments.length === 2) {
				return Parser.prototype.__ks_func_reqParameterIdendifier_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqParenthesis_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(this.test(Token.NEWLINE)) {
				this.commit().NL_0M();
				var expression = this.reqExpression(null, MacroTerminator.Parenthesis);
				this.NL_0M();
				if(!this.test(Token.RIGHT_ROUND)) {
					this.throw(")");
				}
				this.relocate(expression, first, this.yes());
				return expression;
			}
			else {
				var expressions = [this.reqExpression(null, MacroTerminator.List)];
				while(this.test(Token.COMMA)) {
					this.commit();
					expressions.push(this.reqExpression(null, MacroTerminator.List));
				}
				if(!this.test(Token.RIGHT_ROUND)) {
					this.throw(")");
				}
				if(expressions.length === 1) {
					this.relocate(expressions[0], first, this.yes());
					return expressions[0];
				}
				else {
					return this.yep(AST.SequenceExpression(expressions, first, this.yes()));
				}
			}
		},
		reqParenthesis: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqParenthesis_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqPostfixedOperand_0: function() {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			var __ks_i = -1;
			var mode = arguments[++__ks_i];
			if(mode === void 0 || mode === null) {
				throw new TypeError("'mode' is not nullable");
			}
			var __ks__;
			var operand = arguments.length > 1 && (__ks__ = arguments[++__ks_i]) !== void 0 ? __ks__ : null;
			operand = this.reqUnaryOperand(mode, operand);
			var operator;
			var __ks_0 = this.matchM(M.POSTFIX_OPERATOR);
			if(__ks_0 === Token.MINUS_MINUS) {
				operator = this.yep(AST.UnaryOperator(UnaryOperatorKind.DecrementPostfix, this.yes()));
			}
			else if(__ks_0 === Token.PLUS_PLUS) {
				operator = this.yep(AST.UnaryOperator(UnaryOperatorKind.IncrementPostfix, this.yes()));
			}
			else if(__ks_0 === Token.QUESTION) {
				operator = this.yep(AST.UnaryOperator(UnaryOperatorKind.Existential, this.yes()));
			}
			else {
				return operand;
			}
			return this.reqPostfixedOperand(mode, this.yep(AST.UnaryExpression(operator, operand, operand, operator)));
		},
		reqPostfixedOperand: function() {
			if(arguments.length >= 1 && arguments.length <= 2) {
				return Parser.prototype.__ks_func_reqPostfixedOperand_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqPrefixedOperand_0: function() {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			var __ks_i = -1;
			var mode = arguments[++__ks_i];
			if(mode === void 0 || mode === null) {
				throw new TypeError("'mode' is not nullable");
			}
			var __ks__;
			var operand = arguments.length > 1 && (__ks__ = arguments[++__ks_i]) !== void 0 ? __ks__ : null;
			if(operand === null) {
				var __ks_0 = this.matchM(M.PREFIX_OPERATOR);
				if(__ks_0 === Token.DOT_DOT_DOT) {
					var operator = this.yep(AST.UnaryOperator(UnaryOperatorKind.Spread, this.yes()));
					var __ks_operand_1 = this.reqPrefixedOperand(mode);
					return this.yep(AST.UnaryExpression(operator, __ks_operand_1, operator, __ks_operand_1));
				}
				else if(__ks_0 === Token.EXCLAMATION) {
					var operator = this.yep(AST.UnaryOperator(UnaryOperatorKind.Negation, this.yes()));
					var __ks_operand_2 = this.reqPrefixedOperand(mode);
					return this.yep(AST.UnaryExpression(operator, __ks_operand_2, operator, __ks_operand_2));
				}
				else if(__ks_0 === Token.MINUS) {
					var first = this.yes();
					var __ks_operand_3 = this.reqPrefixedOperand(mode);
					if(__ks_operand_3.value.kind === NodeKind.NumericExpression) {
						__ks_operand_3.value.value = -__ks_operand_3.value.value;
						return this.relocate(__ks_operand_3, first, null);
					}
					else {
						var operator = this.yep(AST.UnaryOperator(UnaryOperatorKind.Negative, first));
						return this.yep(AST.UnaryExpression(operator, __ks_operand_3, operator, __ks_operand_3));
					}
				}
				else if(__ks_0 === Token.MINUS_MINUS) {
					var operator = this.yep(AST.UnaryOperator(UnaryOperatorKind.DecrementPrefix, this.yes()));
					var __ks_operand_4 = this.reqPrefixedOperand(mode);
					return this.yep(AST.UnaryExpression(operator, __ks_operand_4, operator, __ks_operand_4));
				}
				else if(__ks_0 === Token.PLUS_PLUS) {
					var operator = this.yep(AST.UnaryOperator(UnaryOperatorKind.IncrementPrefix, this.yes()));
					var __ks_operand_5 = this.reqPrefixedOperand(mode);
					return this.yep(AST.UnaryExpression(operator, __ks_operand_5, operator, __ks_operand_5));
				}
				else if(__ks_0 === Token.QUESTION) {
					var operator = this.yep(AST.UnaryOperator(UnaryOperatorKind.Existential, this.yes()));
					var __ks_operand_6 = this.reqPrefixedOperand(mode);
					return this.yep(AST.UnaryExpression(operator, __ks_operand_6, operator, __ks_operand_6));
				}
				else if(__ks_0 === Token.TILDE) {
					var operator = this.yep(AST.UnaryOperator(UnaryOperatorKind.BitwiseNot, this.yes()));
					var __ks_operand_7 = this.reqPrefixedOperand(mode);
					return this.yep(AST.UnaryExpression(operator, __ks_operand_7, operator, __ks_operand_7));
				}
				else {
					return this.reqPostfixedOperand(mode);
				}
			}
			else {
				return this.reqPostfixedOperand(mode, operand);
			}
		},
		reqPrefixedOperand: function() {
			if(arguments.length >= 1 && arguments.length <= 2) {
				return Parser.prototype.__ks_func_reqPrefixedOperand_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqRequireStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var declarations = [];
			var last;
			if(this.test(Token.LEFT_CURLY)) {
				this.commit().NL_0M();
				while(!(this.test(Token.RIGHT_CURLY))) {
					declarations.push(this.reqExternDeclarator());
					this.reqNL_1M();
				}
				if(!this.test(Token.RIGHT_CURLY)) {
					this.throw("}");
				}
				last = this.yes();
			}
			else {
				declarations.push(this.reqExternDeclarator());
				while(this.test(Token.COMMA)) {
					this.commit();
					declarations.push(this.reqExternDeclarator());
				}
				last = declarations[declarations.length - 1];
			}
			this.reqNL_EOF_1M();
			return this.yep(AST.RequireDeclaration(declarations, first, last));
		},
		reqRequireStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqRequireStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqRequireOrExternStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var declarations = [];
			var last;
			if(this.test(Token.LEFT_CURLY)) {
				this.commit().NL_0M();
				while(!(this.test(Token.RIGHT_CURLY))) {
					declarations.push(this.reqExternDeclarator());
					this.reqNL_1M();
				}
				if(!this.test(Token.RIGHT_CURLY)) {
					this.throw("}");
				}
				last = this.yes();
			}
			else {
				declarations.push(this.reqExternDeclarator());
				while(this.test(Token.COMMA)) {
					this.commit();
					declarations.push(this.reqExternDeclarator());
				}
				last = declarations[declarations.length - 1];
			}
			this.reqNL_EOF_1M();
			return this.yep(AST.RequireOrExternDeclaration(declarations, first, last));
		},
		reqRequireOrExternStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqRequireOrExternStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqRequireOrImportStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var declarations = [];
			var last;
			if(this.test(Token.LEFT_CURLY)) {
				this.commit().reqNL_1M();
				while(!(this.test(Token.RIGHT_CURLY))) {
					declarations.push(this.reqImportDeclarator());
					if(this.test(Token.NEWLINE)) {
						this.commit().NL_0M();
					}
					else {
						break;
					}
				}
				if(!this.test(Token.RIGHT_CURLY)) {
					this.throw("}");
				}
				last = this.yes();
			}
			else {
				declarations.push(last = this.reqImportDeclarator());
			}
			this.reqNL_EOF_1M();
			return this.yep(AST.RequireOrImportDeclaration(declarations, first, last));
		},
		reqRequireOrImportStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqRequireOrImportStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqReturnStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(this.match(Token.IF, Token.UNLESS, Token.NEWLINE) === Token.IF) {
				this.commit();
				var condition = this.reqExpression(ExpressionMode.Default);
				return this.yep(AST.IfStatement(condition, this.yep(AST.ReturnStatement(first)), null, first, condition));
			}
			else if((this._token === Token.NEWLINE) || (this._token === Token.EOF)) {
				return this.yep(AST.ReturnStatement(first));
			}
			else if(this._token === Token.UNLESS) {
				this.commit();
				var condition = this.reqExpression(ExpressionMode.Default);
				return this.yep(AST.UnlessStatement(condition, this.yep(AST.ReturnStatement(first)), first, condition));
			}
			else {
				var expression = this.reqExpression(ExpressionMode.Default);
				if(this.match(Token.IF, Token.UNLESS, Token.NEWLINE) === Token.IF) {
					this.commit();
					var condition = this.reqExpression(ExpressionMode.Default);
					if(this.match(Token.ELSE, Token.NEWLINE) === Token.ELSE) {
						this.commit();
						var whenFalse = this.reqExpression(ExpressionMode.Default);
						return this.yep(AST.ReturnStatement(this.yep(AST.IfExpression(condition, expression, whenFalse, expression, whenFalse)), first, whenFalse));
					}
					else if((this._token === Token.NEWLINE) || (this._token === Token.EOF)) {
						return this.yep(AST.IfStatement(condition, this.yep(AST.ReturnStatement(expression, first, expression)), null, first, condition));
					}
					else {
						this.throw();
					}
				}
				else if((this._token === Token.NEWLINE) || (this._token === Token.EOF)) {
					return this.yep(AST.ReturnStatement(expression, first, expression));
				}
				else if(this._token === Token.UNLESS) {
					this.commit();
					var condition = this.reqExpression(ExpressionMode.Default);
					return this.yep(AST.UnlessStatement(condition, this.yep(AST.ReturnStatement(expression, first, expression)), first, condition));
				}
				else {
					this.throw();
				}
			}
		},
		reqReturnStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqReturnStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqStatement_0: function() {
			var mark = this.mark();
			var statement = NO;
			var __ks_0 = this.matchM(M.STATEMENT);
			if(__ks_0 === Token.ABSTRACT) {
				var first = this.yes();
				if(this.test(Token.CLASS)) {
					this.commit();
					var modifiers = [this.yep(AST.Modifier(ModifierKind.Abstract, first))];
					statement = this.reqClassStatement(first, modifiers);
				}
				else {
					statement = NO;
				}
			}
			else if(__ks_0 === Token.BREAK) {
				statement = this.reqBreakStatement(this.yes());
			}
			else if(__ks_0 === Token.CLASS) {
				statement = this.tryClassStatement(this.yes());
			}
			else if(__ks_0 === Token.CONST) {
				statement = this.reqConstStatement(this.yes());
			}
			else if(__ks_0 === Token.CONTINUE) {
				statement = this.reqContinueStatement(this.yes());
			}
			else if(__ks_0 === Token.DELETE) {
				statement = this.tryDestroyStatement(this.yes());
			}
			else if(__ks_0 === Token.DO) {
				statement = this.reqDoStatement(this.yes());
			}
			else if(__ks_0 === Token.ENUM) {
				statement = this.reqEnumStatement(this.yes());
			}
			else if(__ks_0 === Token.FOR) {
				statement = this.reqForStatement(this.yes());
			}
			else if(__ks_0 === Token.FUNC) {
				statement = this.reqFunctionStatement(this.yes());
			}
			else if(__ks_0 === Token.IF) {
				statement = this.reqIfStatement(this.yes());
			}
			else if(__ks_0 === Token.IMPL) {
				statement = this.reqImplementStatement(this.yes());
			}
			else if(__ks_0 === Token.IMPORT) {
				statement = this.reqImportStatement(this.yes());
			}
			else if(__ks_0 === Token.LET) {
				statement = this.reqLetStatement(this.yes());
			}
			else if(__ks_0 === Token.MACRO) {
				if((this._mode & ParserMode.MacroExpression) === 0) {
					statement = this.tryMacroStatement(this.yes());
				}
				else {
					statement = this.reqMacroExpression(this.yes());
				}
			}
			else if(__ks_0 === Token.NAMESPACE) {
				statement = this.reqNamespaceStatement(this.yes());
			}
			else if(__ks_0 === Token.RETURN) {
				statement = this.reqReturnStatement(this.yes());
			}
			else if(__ks_0 === Token.SEALED) {
				var first = this.yes();
				var modifiers = [this.yep(AST.Modifier(ModifierKind.Sealed, first))];
				if(this.test(Token.CLASS)) {
					this.commit();
					statement = this.reqClassStatement(first, modifiers);
				}
				else if(this.test(Token.ABSTRACT)) {
					modifiers.push(this.yep(AST.Modifier(ModifierKind.Abstract, this.yes())));
					if(this.test(Token.CLASS)) {
						this.commit();
						statement = this.reqClassStatement(first, modifiers);
					}
					else {
						this.throw("class");
					}
				}
				else {
					statement = NO;
				}
			}
			else if(__ks_0 === Token.SWITCH) {
				statement = this.reqSwitchStatement(this.yes());
			}
			else if(__ks_0 === Token.THROW) {
				statement = this.reqThrowStatement(this.yes());
			}
			else if(__ks_0 === Token.TRY) {
				statement = this.reqTryStatement(this.yes());
			}
			else if(__ks_0 === Token.TYPE) {
				statement = this.tryTypeStatement(this.yes());
			}
			else if(__ks_0 === Token.UNLESS) {
				statement = this.reqUnlessStatement(this.yes());
			}
			else if(__ks_0 === Token.UNTIL) {
				statement = this.tryUntilStatement(this.yes());
			}
			else if(__ks_0 === Token.WHILE) {
				statement = this.tryWhileStatement(this.yes());
			}
			if(!statement.ok) {
				this.rollback(mark);
				if(!(statement = this.tryAssignementStatement()).ok) {
					this.rollback(mark);
					statement = this.reqExpressionStatement();
				}
			}
			this.reqNL_EOF_1M();
			return statement;
		},
		reqStatement: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqStatement_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqString_0: function() {
			if(this.test(Token.STRING)) {
				return this.yep(AST.Literal(this.value(), this.yes()));
			}
			else {
				this.throw("String");
			}
		},
		reqString: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqString_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqSwitchBinding_0: function() {
			var bindings = [this.reqSwitchBindingValue()];
			while(this.test(Token.COMMA)) {
				this.commit();
				bindings.push(this.reqSwitchBindingValue());
			}
			return this.yep(bindings);
		},
		reqSwitchBinding: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqSwitchBinding_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqSwitchBindingValue_0: function() {
			var __ks_0 = this.match(Token.LEFT_CURLY, Token.LEFT_SQUARE);
			if(__ks_0 === Token.LEFT_CURLY) {
				var first = this.yes();
				var elements = [];
				if(!this.test(Token.RIGHT_CURLY)) {
					var alias, name;
					while(true) {
						alias = this.reqIdentifier();
						if(!this.test(Token.COLON)) {
							this.throw(":");
						}
						this.commit();
						name = this.reqIdentifier();
						elements.push(this.yep(AST.BindingElement(name, alias, null, null, alias, name)));
						if(this.test(Token.COMMA)) {
							this.commit();
						}
						else {
							break;
						}
					}
				}
				if(!this.test(Token.RIGHT_CURLY)) {
					this.throw("}");
				}
				return this.yep(AST.ObjectBinding(elements, first, this.yes()));
			}
			else if(__ks_0 === Token.LEFT_SQUARE) {
				var first = this.yes();
				var elements = [];
				while(!(this.test(Token.RIGHT_SQUARE))) {
					if(this.test(Token.COMMA)) {
						elements.push(this.yep(AST.OmittedExpression(false, this.yep())));
					}
					else if(this.test(Token.DOT_DOT_DOT)) {
						var __ks_first_1 = this.yes();
						if(this.test(Token.COMMA) || this.test(Token.RIGHT_SQUARE)) {
							elements.push(this.yep(AST.OmittedExpression(true, __ks_first_1)));
						}
						else {
							var name = this.reqIdentifier();
							elements.push(this.yep(AST.BindingElement(name, null, true, null, __ks_first_1, name)));
							if(this.test(Token.COMMA)) {
								this.commit();
							}
						}
					}
					else {
						elements.push(this.yep(AST.BindingElement(this.reqIdentifier())));
					}
					if(this.test(Token.COMMA)) {
						this.commit();
						if(this.test(Token.RIGHT_SQUARE)) {
							elements.push(this.yep(AST.OmittedExpression(false, this.yep())));
						}
					}
				}
				if(!this.test(Token.RIGHT_SQUARE)) {
					this.throw("]");
				}
				return this.yep(AST.ArrayBinding(elements, first, this.yes()));
			}
			else {
				var name = this.reqIdentifier();
				if(this.test(Token.AS)) {
					this.commit();
					var type = this.reqTypeVar();
					return this.yep(AST.SwitchTypeCasting(name, type));
				}
				else {
					return name;
				}
			}
		},
		reqSwitchBindingValue: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqSwitchBindingValue_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqSwitchCaseExpression_0: function() {
			var __ks_0 = this.match(Token.LEFT_CURLY, Token.RETURN, Token.THROW);
			if(__ks_0 === Token.LEFT_CURLY) {
				return this.reqBlock(this.yes());
			}
			else if(__ks_0 === Token.RETURN) {
				var first = this.yes();
				var expression = this.reqExpression(ExpressionMode.Default);
				return this.yep(AST.ReturnStatement(expression, first, expression));
			}
			else if(__ks_0 === Token.THROW) {
				var first = this.yes();
				var expression = this.reqExpression(ExpressionMode.Default);
				return this.yep(AST.ThrowStatement(expression, first, expression));
			}
			else {
				return this.reqExpression(ExpressionMode.Default);
			}
		},
		reqSwitchCaseExpression: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqSwitchCaseExpression_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqSwitchCaseList_0: function() {
			this.NL_0M();
			if(!this.test(Token.LEFT_CURLY)) {
				this.throw("{");
			}
			this.commit().NL_0M();
			var clauses = [];
			var conditions, bindings, filter, body, first;
			while(!(this.test(Token.RIGHT_CURLY))) {
				conditions = bindings = filter = null;
				var __ks_0 = this.match(Token.WITH, Token.WHERE, Token.EQUALS_RIGHT_ANGLE);
				if(__ks_0 === Token.EQUALS_RIGHT_ANGLE) {
					first = this.yes();
					body = this.reqSwitchCaseExpression();
				}
				else if(__ks_0 === Token.WHERE) {
					first = this.yes();
					filter = this.reqExpression(ExpressionMode.NoAnonymousFunction);
					this.NL_0M();
					if(!this.test(Token.EQUALS_RIGHT_ANGLE)) {
						this.throw("=>");
					}
					this.commit();
					body = this.reqSwitchCaseExpression();
				}
				else if(__ks_0 === Token.WITH) {
					first = this.yes();
					bindings = this.reqSwitchBinding();
					this.NL_0M();
					var __ks_1 = this.match(Token.WHERE, Token.EQUALS_RIGHT_ANGLE);
					if(__ks_1 === Token.EQUALS_RIGHT_ANGLE) {
						this.commit();
						body = this.reqSwitchCaseExpression();
					}
					else if(__ks_1 === Token.WHERE) {
						this.commit();
						filter = this.reqExpression(ExpressionMode.NoAnonymousFunction);
						this.NL_0M();
						if(!this.test(Token.EQUALS_RIGHT_ANGLE)) {
							this.throw("=>");
						}
						this.commit();
						body = this.reqSwitchCaseExpression();
					}
					else {
						this.throw(["where", "=>"]);
					}
				}
				else {
					first = this.reqSwitchCondition();
					conditions = [first];
					while(this.test(Token.COMMA)) {
						this.commit();
						conditions.push(this.reqSwitchCondition());
					}
					this.NL_0M();
					var __ks_1 = this.match(Token.WITH, Token.WHERE, Token.EQUALS_RIGHT_ANGLE);
					if(__ks_1 === Token.EQUALS_RIGHT_ANGLE) {
						this.commit();
						body = this.reqSwitchCaseExpression();
					}
					else if(__ks_1 === Token.WHERE) {
						this.commit();
						filter = this.reqExpression(ExpressionMode.NoAnonymousFunction);
						this.NL_0M();
						if(!this.test(Token.EQUALS_RIGHT_ANGLE)) {
							this.throw("=>");
						}
						this.commit();
						body = this.reqSwitchCaseExpression();
					}
					else if(__ks_1 === Token.WITH) {
						this.commit();
						bindings = this.reqSwitchBinding();
						this.NL_0M();
						var __ks_2 = this.match(Token.WHERE, Token.EQUALS_RIGHT_ANGLE);
						if(__ks_2 === Token.EQUALS_RIGHT_ANGLE) {
							this.commit();
							body = this.reqSwitchCaseExpression();
						}
						else if(__ks_2 === Token.WHERE) {
							this.commit();
							filter = this.reqExpression(ExpressionMode.NoAnonymousFunction);
							this.NL_0M();
							if(!this.test(Token.EQUALS_RIGHT_ANGLE)) {
								this.throw("=>");
							}
							this.commit();
							body = this.reqSwitchCaseExpression();
						}
						else {
							this.throw(["where", "=>"]);
						}
					}
					else {
						this.throw(["where", "with", "=>"]);
					}
				}
				this.reqNL_1M();
				clauses.push(AST.SwitchClause(conditions, bindings, filter, body, first, body));
			}
			if(!this.test(Token.RIGHT_CURLY)) {
				this.throw("}");
			}
			return this.yes(clauses);
		},
		reqSwitchCaseList: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqSwitchCaseList_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqSwitchCondition_0: function() {
			var __ks_0 = this.match(Token.LEFT_CURLY, Token.LEFT_SQUARE, Token.IS, Token.COLON);
			if(__ks_0 === Token.COLON) {
				throw new Error("Not Implemented");
			}
			else if(__ks_0 === Token.IS) {
				var first = this.yes();
				var type = this.reqTypeVar();
				return this.yep(AST.SwitchConditionType(type, first, type));
			}
			else if(__ks_0 === Token.LEFT_CURLY) {
				var first = this.yes();
				var members = [];
				if(!this.test(Token.RIGHT_CURLY)) {
					var name;
					while(true) {
						name = this.reqIdentifier();
						if(this.test(Token.COLON)) {
							this.commit();
							members.push(this.yep(AST.ObjectMember(name, this.reqSwitchConditionValue())));
						}
						else {
							members.push(this.yep(AST.ObjectMember(name)));
						}
						if(this.test(Token.COMMA)) {
							this.commit();
						}
						else {
							break;
						}
					}
				}
				if(!this.test(Token.RIGHT_CURLY)) {
					this.throw("}");
				}
				return this.yep(AST.SwitchConditionObject(members, first, this.yes()));
			}
			else if(__ks_0 === Token.LEFT_SQUARE) {
				var first = this.yes();
				var values = [];
				while(!(this.test(Token.RIGHT_SQUARE))) {
					if(this.test(Token.COMMA)) {
						values.push(this.yep(AST.OmittedExpression(false, this.yep())));
					}
					else if(this.test(Token.DOT_DOT_DOT)) {
						values.push(this.yep(AST.OmittedExpression(true, this.yes())));
					}
					else {
						values.push(this.reqSwitchConditionValue());
					}
					if(this.test(Token.COMMA)) {
						this.commit();
						if(this.test(Token.RIGHT_SQUARE)) {
							values.push(this.yep(AST.OmittedExpression(false, this.yep())));
						}
					}
					else {
						break;
					}
				}
				if(!this.test(Token.RIGHT_SQUARE)) {
					this.throw("]");
				}
				return this.yep(AST.SwitchConditionArray(values, first, this.yes()));
			}
			else {
				return this.reqSwitchConditionValue();
			}
		},
		reqSwitchCondition: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqSwitchCondition_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqSwitchConditionValue_0: function() {
			var operand = this.reqPrefixedOperand(ExpressionMode.Default);
			if(this.match(Token.LEFT_ANGLE, Token.DOT_DOT) === Token.DOT_DOT) {
				this.commit();
				if(this.test(Token.LEFT_ANGLE)) {
					this.commit();
					return this.yep(AST.SwitchConditionRangeFI(operand, this.reqPrefixedOperand(ExpressionMode.Default)));
				}
				else {
					return this.yep(AST.SwitchConditionRangeFO(operand, this.reqPrefixedOperand(ExpressionMode.Default)));
				}
			}
			else if(this._token === Token.LEFT_ANGLE) {
				this.commit();
				if(!this.test(Token.DOT_DOT)) {
					this.throw("..");
				}
				this.commit();
				if(this.test(Token.LEFT_ANGLE)) {
					this.commit();
					return this.yep(AST.SwitchConditionRangeTI(operand, this.reqPrefixedOperand(ExpressionMode.Default)));
				}
				else {
					return this.yep(AST.SwitchConditionRangeTO(operand, this.reqPrefixedOperand(ExpressionMode.Default)));
				}
			}
			else {
				return operand;
			}
		},
		reqSwitchConditionValue: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqSwitchConditionValue_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqSwitchStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var expression = this.reqOperation(ExpressionMode.Default);
			var clauses = this.reqSwitchCaseList();
			return this.yep(AST.SwitchStatement(expression, clauses, first, clauses));
		},
		reqSwitchStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqSwitchStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqTemplateExpression_0: function() {
			var first = this.yes();
			var elements = [];
			while(true) {
				if(this.matchM(M.TEMPLATE) === Token.TEMPLATE_ELEMENT) {
					this.commit();
					elements.push(this.reqExpression(ExpressionMode.Default));
					if(!this.test(Token.RIGHT_ROUND)) {
						this.throw(")");
					}
					this.commit();
				}
				else if(this._token === Token.TEMPLATE_VALUE) {
					elements.push(this.yep(AST.Literal(this._scanner.value(), this.yes())));
				}
				else {
					break;
				}
			}
			if(!this.test(Token.TEMPLATE_END)) {
				this.throw("`");
			}
			return this.yep(AST.TemplateExpression(elements, first, this.yes()));
		},
		reqTemplateExpression: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqTemplateExpression_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqThisExpression_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var identifier = this.reqIdentifier();
			return this.yep(AST.ThisExpression(identifier, first, identifier));
		},
		reqThisExpression: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqThisExpression_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqThrowStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			if(this.match(Token.IF, Token.UNLESS, Token.NEWLINE) === Token.IF) {
				this.commit();
				var condition = this.reqExpression(ExpressionMode.Default);
				return this.yep(AST.IfStatement(condition, this.yep(AST.ThrowStatement(first)), null, first, condition));
			}
			else if((this._token === Token.NEWLINE) || (this._token === Token.EOF)) {
				return this.yep(AST.ThrowStatement(first));
			}
			else if(this._token === Token.UNLESS) {
				this.commit();
				var condition = this.reqExpression(ExpressionMode.Default);
				return this.yep(AST.UnlessStatement(condition, this.yep(AST.ThrowStatement(first)), first, condition));
			}
			else {
				var expression = this.reqExpression(ExpressionMode.Default);
				if(this.match(Token.IF, Token.UNLESS, Token.NEWLINE) === Token.IF) {
					this.commit();
					var condition = this.reqExpression(ExpressionMode.Default);
					if(this.match(Token.ELSE, Token.NEWLINE) === Token.ELSE) {
						this.commit();
						var whenFalse = this.reqExpression(ExpressionMode.Default);
						return this.yep(AST.ThrowStatement(this.yep(AST.IfExpression(condition, expression, whenFalse, expression, whenFalse)), first, whenFalse));
					}
					else if((this._token === Token.NEWLINE) || (this._token === Token.EOF)) {
						return this.yep(AST.IfStatement(condition, this.yep(AST.ThrowStatement(expression, first, expression)), null, first, condition));
					}
					else {
						this.throw();
					}
				}
				else if((this._token === Token.NEWLINE) || (this._token === Token.EOF)) {
					return this.yep(AST.ThrowStatement(expression, first, expression));
				}
				else if(this._token === Token.UNLESS) {
					this.commit();
					var condition = this.reqExpression(ExpressionMode.Default);
					return this.yep(AST.UnlessStatement(condition, this.yep(AST.ThrowStatement(expression, first, expression)), first, condition));
				}
				else {
					this.throw();
				}
			}
		},
		reqThrowStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqThrowStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqTryCatchClause_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var binding;
			if(this.test(Token.IDENTIFIER)) {
				binding = this.reqIdentifier();
			}
			this.NL_0M();
			var body = this.reqBlock();
			return this.yep(AST.CatchClause(binding, null, body, first, body));
		},
		reqTryCatchClause: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqTryCatchClause_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqTryStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			this.NL_0M();
			var body = this.reqBlock();
			var last = body;
			var mark = this.mark();
			var catchClauses = [];
			var catchClause, finalizer;
			this.NL_0M();
			if(this.test(Token.ON)) {
				do {
					catchClauses.push(last = this.reqCatchOnClause(this.yes()));
					mark = this.mark();
					this.NL_0M();
				}
				while(this.test(Token.ON))
			}
			else {
				this.rollback(mark);
				this.NL_0M();
			}
			if(this.test(Token.CATCH)) {
				catchClause = last = this.reqTryCatchClause(this.yes());
				mark = this.mark();
			}
			else {
				this.rollback(mark);
			}
			this.NL_0M();
			if(this.test(Token.FINALLY)) {
				this.commit();
				finalizer = last = this.reqBlock();
			}
			else {
				this.rollback(mark);
			}
			return this.yep(AST.TryStatement(body, catchClauses, catchClause, finalizer, first, last));
		},
		reqTryStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqTryStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqTypeEntity_0: function(nullable) {
			if(nullable === void 0) {
				nullable = null;
			}
			var name = this.reqIdentifier();
			if(this.testNS(Token.DOT)) {
				var property;
				do {
					this.commit();
					property = this.reqIdentifier();
					name = this.yep(AST.MemberExpression(name, property, false, false));
				}
				while(this.testNS(Token.DOT))
			}
			var last = name;
			var generic;
			if(this.testNS(Token.LEFT_ANGLE)) {
				generic = last = this.reqTypeGeneric(this.yes());
			}
			if((nullable === null) && this.testNS(Token.QUESTION)) {
				nullable = last = this.yes(true);
			}
			return this.yep(AST.TypeReference(name, generic, nullable, name, last));
		},
		reqTypeEntity: function() {
			if(arguments.length >= 0 && arguments.length <= 1) {
				return Parser.prototype.__ks_func_reqTypeEntity_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqTypeGeneric_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var entities = [this.reqTypeEntity()];
			while(this.test(Token.COMMA)) {
				this.commit();
				entities.push(this.reqTypeEntity());
			}
			if(!this.test(Token.RIGHT_ANGLE)) {
				this.throw(">");
			}
			return this.yes(entities);
		},
		reqTypeGeneric: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqTypeGeneric_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqTypeStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var name = this.reqIdentifier();
			if(!this.test(Token.EQUALS)) {
				this.throw("=");
			}
			this.commit();
			var type = this.reqTypeVar();
			return this.yep(AST.TypeAliasDeclaration(name, type, first, type));
		},
		reqTypeStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqTypeStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqTypeVar_0: function() {
			if(this.match(Token.LEFT_CURLY, Token.LEFT_SQUARE) === Token.LEFT_CURLY) {
				var first = this.yes();
				var properties = [];
				this.NL_0M();
				var identifier, parameters, modifiers, type;
				while(!(this.test(Token.RIGHT_CURLY))) {
					if(this.test(Token.IDENTIFIER)) {
						identifier = this.reqIdentifier();
						if(this.test(Token.COLON)) {
							this.commit();
							type = this.reqTypeVar();
						}
						else {
							parameters = this.reqFunctionParameterList();
							modifiers = this.reqFunctionModifiers();
							type = this.reqFunctionReturns();
							type = this.yep(AST.FunctionExpression(parameters, modifiers, type, null, parameters, Type.isValue(type) ? type : Type.isValue(modifiers) ? modifiers : parameters));
						}
						properties.push(AST.ObjectMemberReference(identifier, type));
					}
					else {
						this.throw("Identifier");
					}
					if(this.test(Token.COMMA)) {
						this.commit().NL_0M();
					}
					else if(this.test(Token.NEWLINE)) {
						this.commit().NL_0M();
						if(this.test(Token.COMMA)) {
							this.commit().NL_0M();
						}
					}
					else {
						break;
					}
				}
				if(!this.test(Token.RIGHT_CURLY)) {
					this.throw("}");
				}
				return this.yep(AST.ObjectReference(properties, first, this.yes()));
			}
			else if(this._token === Token.LEFT_SQUARE) {
				return this.reqTypeArray();
			}
			else {
				var type = this.reqTypeEntity();
				if(this.test(Token.PIPE)) {
					var types = [type];
					do {
						this.commit();
						types.push(this.reqTypeEntity());
					}
					while(this.test(Token.PIPE))
					return this.yep(AST.UnionType(types, type, types[types.length - 1]));
				}
				else {
					return type;
				}
			}
		},
		reqTypeVar: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqTypeVar_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqTypedIdentifier_0: function() {
			var identifier = this.reqIdentifier();
			if(this.test(Token.COLON)) {
				this.commit();
				var type = this.reqTypeVar();
				return this.yep(AST.VariableDeclarator(identifier, type));
			}
			else {
				return this.yep(AST.VariableDeclarator(identifier));
			}
		},
		reqTypedIdentifier: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqTypedIdentifier_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqTypedVariable_0: function() {
			if(this.match(Token.LEFT_CURLY, Token.LEFT_SQUARE) === Token.LEFT_CURLY) {
				return this.yep(AST.VariableDeclarator(this.reqDestructuringObject(this.yes())));
			}
			else if(this._token === Token.LEFT_SQUARE) {
				return this.yep(AST.VariableDeclarator(this.reqDestructuringArray(this.yes())));
			}
			else {
				return this.reqTypedIdentifier();
			}
		},
		reqTypedVariable: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqTypedVariable_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqUnaryOperand_0: function() {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			var __ks_i = -1;
			var mode = arguments[++__ks_i];
			if(mode === void 0 || mode === null) {
				throw new TypeError("'mode' is not nullable");
			}
			var __ks__;
			var value = arguments.length > 1 && (__ks__ = arguments[++__ks_i]) !== void 0 ? __ks__ : null;
			if(value === null) {
				value = this.reqOperand(mode);
			}
			var expression, mark, first;
			while(true) {
				var __ks_0 = this.matchM(M.OPERAND_JUNCTION);
				if(__ks_0 === Token.ASTERISK_ASTERISK_LEFT_ROUND) {
					this.commit();
					value = this.yep(AST.CallExpression(AST.Scope(ScopeKind.Null), value, this.reqExpression0CNList(), false, value, this.yes()));
				}
				else if(__ks_0 === Token.ASTERISK_DOLLAR_LEFT_ROUND) {
					this.commit();
					var __ks_arguments_1 = this.reqExpression0CNList();
					value = this.yep(AST.CallExpression(AST.Scope(ScopeKind.Argument, __ks_arguments_1.value.shift()), value, __ks_arguments_1, false, value, this.yes()));
				}
				else if(__ks_0 === Token.CARET_AT_LEFT_ROUND) {
					this.commit();
					value = this.yep(AST.CurryExpression(AST.Scope(ScopeKind.This), value, this.reqExpression0CNList(), value, this.yes()));
				}
				else if(__ks_0 === Token.CARET_CARET_LEFT_ROUND) {
					this.commit();
					value = this.yep(AST.CurryExpression(AST.Scope(ScopeKind.Null), value, this.reqExpression0CNList(), value, this.yes()));
				}
				else if(__ks_0 === Token.CARET_DOLLAR_LEFT_ROUND) {
					this.commit();
					var __ks_arguments_1 = this.reqExpression0CNList();
					value = this.yep(AST.CurryExpression(AST.Scope(ScopeKind.Argument, __ks_arguments_1.value.shift()), value, __ks_arguments_1, value, this.yes()));
				}
				else if(__ks_0 === Token.COLON) {
					first = this.yes();
					expression = this.reqIdentifier();
					value = this.yep(AST.BinaryExpression(value, this.yep(AST.BinaryOperator(BinaryOperatorKind.TypeCasting, first)), this.yep(AST.TypeReference(expression)), value, expression));
				}
				else if(__ks_0 === Token.COLON_COLON) {
					this.commit();
					expression = this.reqIdentifier();
					value = this.yep(AST.EnumExpression(value, expression));
				}
				else if(__ks_0 === Token.DOT) {
					this.commit();
					value = this.yep(AST.MemberExpression(value, this.reqIdentifier(), false, false));
				}
				else if(__ks_0 === Token.EXCLAMATION_LEFT_ROUND) {
					this.commit();
					value = this.yep(AST.CallMacroExpression(value, this.reqExpression0CNList(), value, this.yes()));
				}
				else if(__ks_0 === Token.LEFT_SQUARE) {
					this.commit();
					expression = this.reqExpression(ExpressionMode.Default);
					if(!this.test(Token.RIGHT_SQUARE)) {
						this.throw("]");
					}
					value = this.yep(AST.MemberExpression(value, expression, true, false, value, this.yes()));
				}
				else if(__ks_0 === Token.LEFT_ROUND) {
					this.commit();
					value = this.yep(AST.CallExpression(value, this.reqExpression0CNList(), value, this.yes()));
				}
				else if(__ks_0 === Token.NEWLINE) {
					mark = this.mark();
					this.commit().NL_0M();
					if(this.test(Token.DOT)) {
						this.commit();
						value = this.yep(AST.MemberExpression(value, this.reqIdentifier(), false, false));
					}
					else {
						this.rollback(mark);
						break;
					}
				}
				else if(__ks_0 === Token.QUESTION_DOT) {
					this.commit();
					expression = this.reqIdentifier();
					value = this.yep(AST.MemberExpression(value, expression, false, true, value, expression));
				}
				else if(__ks_0 === Token.QUESTION_LEFT_ROUND) {
					this.commit();
					value = this.yep(AST.CallExpression(AST.Scope(ScopeKind.This), value, this.reqExpression0CNList(), true, value, this.yes()));
				}
				else if(__ks_0 === Token.QUESTION_LEFT_SQUARE) {
					this.commit();
					expression = this.reqExpression(ExpressionMode.Default);
					if(!this.test(Token.RIGHT_SQUARE)) {
						this.throw("]");
					}
					value = this.yep(AST.MemberExpression(value, expression, true, true, value, this.yes()));
				}
				else {
					break;
				}
			}
			return value;
		},
		reqUnaryOperand: function() {
			if(arguments.length >= 1 && arguments.length <= 2) {
				return Parser.prototype.__ks_func_reqUnaryOperand_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqUnlessStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var condition = this.reqExpression(ExpressionMode.Default);
			var whenFalse = this.reqBlock();
			return this.yep(AST.UnlessStatement(condition, whenFalse, first, whenFalse));
		},
		reqUnlessStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_reqUnlessStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqVariableEquals_0: function() {
			if(this.match(Token.EQUALS, Token.COLON_EQUALS) === Token.EQUALS) {
				return this.yes(false);
			}
			else if(this._token === Token.COLON_EQUALS) {
				return this.yes(true);
			}
			else {
				this.throw(["=", ":="]);
			}
		},
		reqVariableEquals: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqVariableEquals_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqVariableIdentifier_0: function() {
			if(this.match(Token.IDENTIFIER, Token.LEFT_CURLY, Token.LEFT_SQUARE) === Token.IDENTIFIER) {
				return this.yep(AST.Identifier(this._scanner.value(), this.yes()));
			}
			else if(this._token === Token.LEFT_CURLY) {
				return this.reqDestructuringObject(this.yes());
			}
			else if(this._token === Token.LEFT_SQUARE) {
				return this.reqDestructuringArray(this.yes());
			}
			else {
				this.throw(["Identifier", "{", "["]);
			}
		},
		reqVariableIdentifier: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_reqVariableIdentifier_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_reqVariableName_0: function(object) {
			if(object === void 0 || object === null) {
				object = NO;
			}
			if(!object.ok) {
				if(this.test(Token.AT)) {
					object = this.reqThisExpression(this.yes());
				}
				else {
					object = this.reqIdentifier();
				}
			}
			var property;
			while(true) {
				if(this.match(Token.DOT, Token.LEFT_SQUARE) === Token.DOT) {
					this.commit();
					property = this.reqIdentifier();
					object = this.yep(AST.MemberExpression(object, property, false, false));
				}
				else if(this._token === Token.LEFT_SQUARE) {
					this.commit();
					property = this.reqExpression(ExpressionMode.Default);
					if(!this.test(Token.RIGHT_SQUARE)) {
						this.throw("]");
					}
					object = this.yep(AST.MemberExpression(object, property, true, false, object, this.yes()));
				}
				else {
					break;
				}
			}
			return object;
		},
		reqVariableName: function() {
			if(arguments.length >= 0 && arguments.length <= 1) {
				return Parser.prototype.__ks_func_reqVariableName_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_tryAssignementStatement_0: function() {
			var identifier = NO;
			if(this.match(Token.IDENTIFIER, Token.LEFT_CURLY, Token.LEFT_SQUARE, Token.AT) === Token.IDENTIFIER) {
				identifier = this.reqUnaryOperand(ExpressionMode.Default, this.reqIdentifier());
			}
			else if(this._token === Token.LEFT_CURLY) {
				identifier = this.tryDestructuringObject(this.yes());
			}
			else if(this._token === Token.LEFT_SQUARE) {
				identifier = this.tryDestructuringArray(this.yes());
			}
			else if(this._token === Token.AT) {
				identifier = this.reqUnaryOperand(ExpressionMode.Default, this.reqThisExpression(this.yes()));
			}
			if(!identifier.ok) {
				return NO;
			}
			var statement;
			if(this.match(Token.COMMA, Token.COLON_EQUALS, Token.EQUALS) === Token.COMMA) {
				if(!((identifier.value.kind === NodeKind.Identifier) || (identifier.value.kind === NodeKind.ArrayBinding) || (identifier.value.kind === NodeKind.ObjectBinding))) {
					return NO;
				}
				var variables = [identifier];
				do {
					this.commit();
					variables.push(this.reqVariableIdentifier());
				}
				while(this.test(Token.COMMA))
				if(this.match(Token.COLON_EQUALS, Token.EQUALS) === Token.COLON_EQUALS) {
					if(!this.test(Token.AWAIT)) {
						this.throw("await");
					}
					this.commit();
					var operand = this.reqPrefixedOperand(ExpressionMode.Default);
					statement = this.yep(AST.AwaitExpression(variables, true, operand, identifier, operand));
				}
				else if(this._token === Token.EQUALS) {
					if(!this.test(Token.AWAIT)) {
						this.throw("await");
					}
					this.commit();
					var operand = this.reqPrefixedOperand(ExpressionMode.Default);
					statement = this.yep(AST.AwaitExpression(variables, false, operand, identifier, operand));
				}
				else {
					this.throw(["=", ":="]);
				}
			}
			else if(this._token === Token.COLON_EQUALS) {
				var operator = AST.AssignmentOperator(AssignmentOperatorKind.Equality, this.yes());
				operator.autotype = true;
				var expression = this.reqExpression(ExpressionMode.Default);
				statement = this.yep(AST.BinaryExpression(identifier, this.yep(operator), expression, identifier, expression));
			}
			else if(this._token === Token.EQUALS) {
				var equals = this.yes();
				var expression = this.reqExpression(ExpressionMode.Default);
				statement = this.yep(AST.BinaryExpression(identifier, this.yep(AST.AssignmentOperator(AssignmentOperatorKind.Equality, equals)), expression, identifier, expression));
			}
			else {
				return NO;
			}
			if(this.match(Token.IF, Token.UNLESS) === Token.IF) {
				var first = this.yes();
				var condition = this.reqExpression(ExpressionMode.Default);
				if(this.test(Token.ELSE)) {
					this.commit();
					var whenFalse = this.reqExpression(ExpressionMode.Default);
					statement.value.right = AST.IfExpression(condition, this.yep(statement.value.right), whenFalse, first, whenFalse);
					this.relocate(statement, statement, whenFalse);
				}
				else {
					statement = this.yep(AST.IfExpression(condition, statement, null, statement, condition));
				}
			}
			else if(this._token === Token.UNLESS) {
				this.commit();
				var condition = this.reqExpression(ExpressionMode.Default);
				statement = this.yep(AST.UnlessExpression(condition, statement, statement, condition));
			}
			return statement;
		},
		tryAssignementStatement: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_tryAssignementStatement_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_tryBinaryOperator_0: function() {
			var __ks_0 = this.matchM(M.BINARY_OPERATOR);
			if(__ks_0 === Token.AMPERSAND) {
				return this.yep(AST.BinaryOperator(BinaryOperatorKind.BitwiseAnd, this.yes()));
			}
			else if(__ks_0 === Token.AMPERSAND_AMPERSAND) {
				return this.yep(AST.BinaryOperator(BinaryOperatorKind.And, this.yes()));
			}
			else if(__ks_0 === Token.AMPERSAND_EQUALS) {
				return this.yep(AST.AssignmentOperator(AssignmentOperatorKind.BitwiseAnd, this.yes()));
			}
			else if(__ks_0 === Token.ASTERISK) {
				return this.yep(AST.BinaryOperator(BinaryOperatorKind.Multiplication, this.yes()));
			}
			else if(__ks_0 === Token.ASTERISK_EQUALS) {
				return this.yep(AST.AssignmentOperator(AssignmentOperatorKind.Multiplication, this.yes()));
			}
			else if(__ks_0 === Token.CARET) {
				return this.yep(AST.BinaryOperator(BinaryOperatorKind.BitwiseXor, this.yes()));
			}
			else if(__ks_0 === Token.CARET_EQUALS) {
				return this.yep(AST.AssignmentOperator(AssignmentOperatorKind.BitwiseXor, this.yes()));
			}
			else if(__ks_0 === Token.EQUALS) {
				return this.yep(AST.AssignmentOperator(AssignmentOperatorKind.Equality, this.yes()));
			}
			else if(__ks_0 === Token.EQUALS_EQUALS) {
				return this.yep(AST.BinaryOperator(BinaryOperatorKind.Equality, this.yes()));
			}
			else if(__ks_0 === Token.EXCLAMATION_EQUALS) {
				return this.yep(AST.BinaryOperator(BinaryOperatorKind.Inequality, this.yes()));
			}
			else if(__ks_0 === Token.EXCLAMATION_QUESTION_EQUALS) {
				return this.yep(AST.AssignmentOperator(AssignmentOperatorKind.NonExistential, this.yes()));
			}
			else if(__ks_0 === Token.LEFT_ANGLE) {
				return this.yep(AST.BinaryOperator(BinaryOperatorKind.LessThan, this.yes()));
			}
			else if(__ks_0 === Token.LEFT_ANGLE_EQUALS) {
				return this.yep(AST.BinaryOperator(BinaryOperatorKind.LessThanOrEqual, this.yes()));
			}
			else if(__ks_0 === Token.LEFT_ANGLE_LEFT_ANGLE) {
				return this.yep(AST.BinaryOperator(BinaryOperatorKind.BitwiseLeftShift, this.yes()));
			}
			else if(__ks_0 === Token.LEFT_ANGLE_LEFT_ANGLE_EQUALS) {
				return this.yep(AST.AssignmentOperator(AssignmentOperatorKind.BitwiseLeftShift, this.yes()));
			}
			else if(__ks_0 === Token.MINUS) {
				return this.yep(AST.BinaryOperator(BinaryOperatorKind.Subtraction, this.yes()));
			}
			else if(__ks_0 === Token.MINUS_EQUALS) {
				return this.yep(AST.AssignmentOperator(AssignmentOperatorKind.Subtraction, this.yes()));
			}
			else if(__ks_0 === Token.PERCENT) {
				return this.yep(AST.BinaryOperator(BinaryOperatorKind.Modulo, this.yes()));
			}
			else if(__ks_0 === Token.PERCENT_EQUALS) {
				return this.yep(AST.AssignmentOperator(AssignmentOperatorKind.Modulo, this.yes()));
			}
			else if(__ks_0 === Token.PIPE) {
				return this.yep(AST.BinaryOperator(BinaryOperatorKind.BitwiseOr, this.yes()));
			}
			else if(__ks_0 === Token.PIPE_EQUALS) {
				return this.yep(AST.AssignmentOperator(AssignmentOperatorKind.BitwiseOr, this.yes()));
			}
			else if(__ks_0 === Token.PIPE_PIPE) {
				return this.yep(AST.BinaryOperator(BinaryOperatorKind.Or, this.yes()));
			}
			else if(__ks_0 === Token.PLUS) {
				return this.yep(AST.BinaryOperator(BinaryOperatorKind.Addition, this.yes()));
			}
			else if(__ks_0 === Token.PLUS_EQUALS) {
				return this.yep(AST.AssignmentOperator(AssignmentOperatorKind.Addition, this.yes()));
			}
			else if(__ks_0 === Token.QUESTION_EQUALS) {
				return this.yep(AST.AssignmentOperator(AssignmentOperatorKind.Existential, this.yes()));
			}
			else if(__ks_0 === Token.QUESTION_QUESTION) {
				return this.yep(AST.BinaryOperator(BinaryOperatorKind.NullCoalescing, this.yes()));
			}
			else if(__ks_0 === Token.QUESTION_QUESTION_EQUALS) {
				return this.yep(AST.AssignmentOperator(AssignmentOperatorKind.NullCoalescing, this.yes()));
			}
			else if(__ks_0 === Token.RIGHT_ANGLE) {
				return this.yep(AST.BinaryOperator(BinaryOperatorKind.GreaterThan, this.yes()));
			}
			else if(__ks_0 === Token.RIGHT_ANGLE_EQUALS) {
				return this.yep(AST.BinaryOperator(BinaryOperatorKind.GreaterThanOrEqual, this.yes()));
			}
			else if(__ks_0 === Token.RIGHT_ANGLE_RIGHT_ANGLE) {
				return this.yep(AST.BinaryOperator(BinaryOperatorKind.BitwiseRightShift, this.yes()));
			}
			else if(__ks_0 === Token.RIGHT_ANGLE_RIGHT_ANGLE_EQUALS) {
				return this.yep(AST.AssignmentOperator(AssignmentOperatorKind.BitwiseRightShift, this.yes()));
			}
			else if(__ks_0 === Token.SLASH) {
				return this.yep(AST.BinaryOperator(BinaryOperatorKind.Division, this.yes()));
			}
			else if(__ks_0 === Token.SLASH_EQUALS) {
				return this.yep(AST.AssignmentOperator(AssignmentOperatorKind.Division, this.yes()));
			}
			else {
				return NO;
			}
		},
		tryBinaryOperator: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_tryBinaryOperator_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_tryClassAbstractMethod_0: function(attributes, modifiers, first) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(attributes === void 0) {
				attributes = null;
			}
			if(modifiers === void 0 || modifiers === null) {
				throw new TypeError("'modifiers' is not nullable");
			}
			if(first === void 0) {
				first = null;
			}
			var name = this.tryNameIST();
			if(!name.ok) {
				return NO;
			}
			return this.reqClassAbstractMethodBody(attributes, modifiers, name, first);
		},
		tryClassAbstractMethod: function() {
			if(arguments.length === 3) {
				return Parser.prototype.__ks_func_tryClassAbstractMethod_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_tryClassMember_0: function(attributes, modifiers, first) {
			if(arguments.length < 3) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 3)");
			}
			if(attributes === void 0) {
				attributes = null;
			}
			if(modifiers === void 0 || modifiers === null) {
				throw new TypeError("'modifiers' is not nullable");
			}
			if(first === void 0) {
				first = null;
			}
			var name = this.tryNameIST();
			if(!name.ok) {
				return NO;
			}
			return this.reqClassMemberBody(attributes, modifiers, name, first);
		},
		tryClassMember: function() {
			if(arguments.length === 3) {
				return Parser.prototype.__ks_func_tryClassMember_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_tryClassStatement_0: function() {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			var __ks_i = -1;
			var first = arguments[++__ks_i];
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var __ks__;
			var modifiers = arguments.length > 1 && (__ks__ = arguments[++__ks_i]) !== void 0 && __ks__ !== null ? __ks__ : [];
			var name = this.tryIdentifier();
			if(!name.ok) {
				return NO;
			}
			return this.reqClassStatementBody(name, first, modifiers);
		},
		tryClassStatement: function() {
			if(arguments.length >= 1 && arguments.length <= 2) {
				return Parser.prototype.__ks_func_tryClassStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_tryDestroyStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var variable = this.tryVariableName();
			if(variable.ok) {
				return this.yep(AST.DestroyStatement(variable, first, variable));
			}
			else {
				return NO;
			}
		},
		tryDestroyStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_tryDestroyStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_tryDestructuringArray_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			try {
				return this.reqDestructuringArray(first);
			}
			catch(__ks_0) {
				return NO;
			}
		},
		tryDestructuringArray: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_tryDestructuringArray_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_tryDestructuringObject_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			try {
				return this.reqDestructuringObject(first);
			}
			catch(__ks_0) {
				return NO;
			}
		},
		tryDestructuringObject: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_tryDestructuringObject_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_tryExpression_0: function() {
			try {
				return this.reqExpression(ExpressionMode.Default);
			}
			catch(__ks_0) {
				return NO;
			}
		},
		tryExpression: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_tryExpression_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_tryFunctionExpression_0: function(mode) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(mode === void 0 || mode === null) {
				throw new TypeError("'mode' is not nullable");
			}
			if((mode & ExpressionMode.NoAnonymousFunction) !== 0) {
				return NO;
			}
			if(this.match(Token.FUNC, Token.LEFT_ROUND, Token.IDENTIFIER) === Token.FUNC) {
				var first = this.yes();
				var parameters = this.tryFunctionParameterList();
				if(!parameters.ok) {
					return NO;
				}
				var modifiers = this.reqFunctionModifiers();
				var type = this.reqFunctionReturns();
				var body = this.reqFunctionBody();
				return this.yep(AST.FunctionExpression(parameters, modifiers, type, body, first, body));
			}
			else if(this._token === Token.LEFT_ROUND) {
				var parameters = this.tryFunctionParameterList();
				var modifiers = this.reqFunctionModifiers();
				var type = this.reqFunctionReturns();
				if(!parameters.ok || !this.test(Token.EQUALS_RIGHT_ANGLE)) {
					return NO;
				}
				this.commit();
				if(this.test(Token.LEFT_CURLY)) {
					var body = this.reqBlock();
					return this.yep(AST.LambdaExpression(parameters, modifiers, type, body, parameters, body));
				}
				else {
					var body = this.reqExpression(mode | ExpressionMode.NoObject);
					return this.yep(AST.LambdaExpression(parameters, modifiers, type, body, parameters, body));
				}
			}
			else if(this._token === Token.IDENTIFIER) {
				var name = this.reqIdentifier();
				if(!this.test(Token.EQUALS_RIGHT_ANGLE)) {
					return NO;
				}
				this.commit();
				var parameters = this.yep([this.yep(AST.Parameter(name))], name, name);
				if(this.test(Token.LEFT_CURLY)) {
					var body = this.reqBlock();
					return this.yep(AST.LambdaExpression(parameters, null, null, body, parameters, body));
				}
				else {
					var body = this.reqExpression(mode | ExpressionMode.NoObject);
					return this.yep(AST.LambdaExpression(parameters, null, null, body, parameters, body));
				}
			}
			else {
				return NO;
			}
		},
		tryFunctionExpression: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_tryFunctionExpression_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_tryFunctionParameterList_0: function() {
			if(!this.test(Token.LEFT_ROUND)) {
				return NO;
			}
			var first = this.yes();
			var parameters = [];
			if(!this.test(Token.RIGHT_ROUND)) {
				while(this.tryParameter(parameters, ParameterMode.Function)) {
				}
				if(!this.test(Token.RIGHT_ROUND)) {
					return NO;
				}
			}
			return this.yep(parameters, first, this.yes());
		},
		tryFunctionParameterList: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_tryFunctionParameterList_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_tryIdentifier_0: function() {
			if(this._scanner.test(Token.IDENTIFIER)) {
				return this.yep(AST.Identifier(this._scanner.value(), this.yes()));
			}
			else {
				return NO;
			}
		},
		tryIdentifier: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_tryIdentifier_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_tryMacroStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var name = this.tryIdentifier();
			if(!name.ok) {
				return NO;
			}
			var parameters = this.reqMacroParameterList();
			var body = this.reqMacroBody();
			return this.yep(AST.MacroDeclaration(name, parameters, body, first, body));
		},
		tryMacroStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_tryMacroStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_tryNameIST_0: function() {
			if(this.match(Token.IDENTIFIER, Token.STRING, Token.TEMPLATE_BEGIN) === Token.IDENTIFIER) {
				return this.reqIdentifier();
			}
			else if(this._token === Token.STRING) {
				return this.reqString();
			}
			else if(this._token === Token.TEMPLATE_BEGIN) {
				return this.reqTemplateExpression();
			}
			else {
				return NO;
			}
		},
		tryNameIST: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_tryNameIST_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_tryNumber_0: function() {
			if(this.matchM(M.NUMBER) === Token.BINARY_NUMBER) {
				return this.yep(AST.NumericExpression(parseInt(this._scanner.value().slice(2).replace(/\_/g, ""), 2), this.yes()));
			}
			else if(this._token === Token.OCTAL_NUMBER) {
				return this.yep(AST.NumericExpression(parseInt(this._scanner.value().slice(2).replace(/\_/g, ""), 8), this.yes()));
			}
			else if(this._token === Token.HEX_NUMBER) {
				return this.yep(AST.NumericExpression(parseInt(this._scanner.value().slice(2).replace(/\_/g, ""), 16), this.yes()));
			}
			else if(this._token === Token.RADIX_NUMBER) {
				var data = /^(\d+)r(.*)$/.exec(this._scanner.value());
				return this.yep(AST.NumericExpression(parseInt(data[2].replace(/\_/g, ""), parseInt(data[1])), this.yes()));
			}
			else if(this._token === Token.DECIMAL_NUMBER) {
				return this.yep(AST.NumericExpression(parseFloat(this._scanner.value().replace(/\_/g, ""), 10), this.yes()));
			}
			else {
				return NO;
			}
		},
		tryNumber: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_tryNumber_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_tryOperand_0: function(mode) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(mode === void 0 || mode === null) {
				throw new TypeError("'mode' is not nullable");
			}
			if(this.matchM(M.OPERAND) === Token.AT) {
				return this.reqThisExpression(this.yes());
			}
			else if(this._token === Token.AWAIT) {
				return this.reqAwaitExpression(this.yes());
			}
			else if(this._token === Token.IDENTIFIER) {
				return this.yep(AST.Identifier(this._scanner.value(), this.yes()));
			}
			else if(this._token === Token.LEFT_CURLY) {
				return this.reqObject(this.yes());
			}
			else if(this._token === Token.LEFT_ROUND) {
				return this.reqParenthesis(this.yes());
			}
			else if(this._token === Token.LEFT_SQUARE) {
				return this.reqArray(this.yes());
			}
			else if(this._token === Token.NEW) {
				return this.reqCreateExpression(this.yes());
			}
			else if(this._token === Token.REGEXP) {
				return this.yep(AST.RegularExpression(this._scanner.value(), this.yes()));
			}
			else if(this._token === Token.STRING) {
				return this.yep(AST.Literal(this.value(), this.yes()));
			}
			else if(this._token === Token.TEMPLATE_BEGIN) {
				return this.reqTemplateExpression();
			}
			else {
				return this.tryNumber();
			}
		},
		tryOperand: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_tryOperand_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_tryParameter_0: function(parameters, mode) {
			if(arguments.length < 2) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 2)");
			}
			if(parameters === void 0 || parameters === null) {
				throw new TypeError("'parameters' is not nullable");
			}
			if(mode === void 0 || mode === null) {
				throw new TypeError("'mode' is not nullable");
			}
			try {
				return this.reqParameter(parameters, mode);
			}
			catch(__ks_0) {
				return false;
			}
		},
		tryParameter: function() {
			if(arguments.length === 2) {
				return Parser.prototype.__ks_func_tryParameter_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_tryPrefixedOperand_0: function(mode) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(mode === void 0 || mode === null) {
				throw new TypeError("'mode' is not nullable");
			}
			var value = this.tryOperand(mode);
			if(!value.ok) {
				return NO;
			}
			return this.reqPrefixedOperand(mode, value);
		},
		tryPrefixedOperand: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_tryPrefixedOperand_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_trySwitchExpression_0: function(mode) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(mode === void 0 || mode === null) {
				throw new TypeError("'mode' is not nullable");
			}
			if(!this.test(Token.SWITCH)) {
				return NO;
			}
			var first = this.yes();
			var expression = this.reqOperation(mode);
			var clauses = this.reqSwitchCaseList();
			return this.yep(AST.SwitchExpression(expression, clauses, first, clauses));
		},
		trySwitchExpression: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_trySwitchExpression_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_tryTypeStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var name = this.tryIdentifier();
			if(!name.ok) {
				return NO;
			}
			if(!this.test(Token.EQUALS)) {
				this.throw("=");
			}
			this.commit();
			var type = this.reqTypeVar();
			return this.yep(AST.TypeAliasDeclaration(name, type, first, type));
		},
		tryTypeStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_tryTypeStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_tryUntilStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var condition = this.tryExpression();
			if(!condition.ok) {
				return NO;
			}
			var body;
			if(this.match(Token.LEFT_CURLY, Token.EQUALS_RIGHT_ANGLE) === Token.LEFT_CURLY) {
				body = this.reqBlock(this.yes());
			}
			else if(this._token === Token.EQUALS_RIGHT_ANGLE) {
				this.commit();
				body = this.reqExpression(ExpressionMode.Default);
			}
			else {
				this.throw(["{", "=>"]);
			}
			return this.yep(AST.UntilStatement(condition, body, first, body));
		},
		tryUntilStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_tryUntilStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_tryVariableEquals_0: function() {
			if(this.match(Token.EQUALS, Token.COLON_EQUALS) === Token.EQUALS) {
				return this.yes(false);
			}
			else if(this._token === Token.COLON_EQUALS) {
				return this.yes(true);
			}
			else {
				return NO;
			}
		},
		tryVariableEquals: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_tryVariableEquals_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_tryVariableName_0: function() {
			var object;
			if(this.test(Token.AT)) {
				object = this.reqThisExpression(this.yes());
			}
			else {
				object = this.tryIdentifier();
				if(!object.ok) {
					return NO;
				}
			}
			return this.reqVariableName(object);
		},
		tryVariableName: function() {
			if(arguments.length === 0) {
				return Parser.prototype.__ks_func_tryVariableName_0.apply(this);
			}
			throw new SyntaxError("wrong number of arguments");
		},
		__ks_func_tryWhileStatement_0: function(first) {
			if(arguments.length < 1) {
				throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
			}
			if(first === void 0 || first === null) {
				throw new TypeError("'first' is not nullable");
			}
			var condition = this.tryExpression();
			if(!condition.ok) {
				return NO;
			}
			var body;
			if(this.match(Token.LEFT_CURLY, Token.EQUALS_RIGHT_ANGLE) === Token.LEFT_CURLY) {
				body = this.reqBlock(this.yes());
			}
			else if(this._token === Token.EQUALS_RIGHT_ANGLE) {
				this.commit();
				body = this.reqExpression(ExpressionMode.Default);
			}
			else {
				this.throw(["{", "=>"]);
			}
			return this.yep(AST.WhileStatement(condition, body, first, body));
		},
		tryWhileStatement: function() {
			if(arguments.length === 1) {
				return Parser.prototype.__ks_func_tryWhileStatement_0.apply(this, arguments);
			}
			throw new SyntaxError("wrong number of arguments");
		}
	});
	function parse(data) {
		if(arguments.length < 1) {
			throw new SyntaxError("wrong number of arguments (" + arguments.length + " for 1)");
		}
		if(data === void 0 || data === null) {
			throw new TypeError("'data' is not nullable");
		}
		else if(!Type.isString(data)) {
			throw new TypeError("'data' is not of type 'String'");
		}
		var parser = new Parser(data);
		return parser.reqModule();
	}
	return {
		parse: parse
	};
}